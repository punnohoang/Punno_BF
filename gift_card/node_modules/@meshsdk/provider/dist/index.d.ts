import { IFetcher, Network, AccountInfo, UTxO, IFetcherOptions, TransactionInfo, Asset, AssetMetadata, BlockInfo, Protocol, IListener, ISubmitter, IEvaluator, Action, GovernanceProposalInfo } from '@meshsdk/common';
import { MaestroSupportedNetworks as MaestroSupportedNetworks$1, TransactionsInfo, UTxO as UTxO$1, AddressInfo, TransactionsStatus } from '@meshsdk/bitcoin';

/**
 * The BeginProvider class provides methods to query Begin ID.
 *
 * To use this provider, simply create a new instance of the BeginProvider class and call the desired method.
 *
 * ```typescript
 * import { BeginProvider } from "@meshsdk/core";
 *
 * const beginProvider = new BeginProvider();
 * ```
 */
declare class BeginProvider {
    private readonly apikey;
    private readonly chainNumber;
    private readonly domainUrl;
    /**
     * Creates a new instance of the BeginProvider.
     * @param apikey The API key for querying Begin ID.
     */
    constructor(apikey?: string);
    /**
     * Given a Begin ID, resolves the address and other information.
     * @param name name of Begin ID, e.g. `mesh`
     * @param url optional URL to override the default: https://resolveidaddress-ylo5dtxzdq-uc.a.run.app
     * @returns
     * - name: string
     * - domain: string
     * - image: string
     * - address: string
     */
    resolveAddress(name: string, url?: string): Promise<{
        name: string;
        domain: string;
        image: string;
        address: string;
    }>;
    /**
     * Given an address, resolves the Begin ID and other information.
     * @param address address to resolve
     * @param url optional URL to override the default: https://resolveIdReserveAddress-ylo5dtxzdq-uc.a.run.app
     * @returns
     * - name: string
     * - domain: string
     * - image: string
     * - address: string
     */
    resolveAdressReverse(address: string, url?: string): Promise<{
        name: string;
        domain: string;
        image: string;
        address: string;
    }>;
}

type AssetAddress = {
    address: string;
    quantity: string;
};
/**
 * OfflineFetcher implements the IFetcher interface to provide offline access to blockchain data.
 * This class allows working with pre-loaded blockchain data without requiring network connectivity.
 * It's useful for testing, development, and scenarios where offline operation is needed.
 *
 * The class maintains internal storage for various blockchain data types:
 * - Account information
 * - UTXOs (Unspent Transaction Outputs)
 * - Asset addresses and metadata
 * - Block information
 * - Protocol parameters
 * - Transaction information
 *
 * Example usage:
 * ```typescript
 * import { OfflineFetcher } from '@meshsdk/core';
 *
 * // Create a new instance
 * const fetcher = new OfflineFetcher();
 * //or const fetcher = new OfflineFetcher("mainnet");
 *
 * // Add some blockchain data
 * fetcher.addAccount(address, accountInfo);
 * fetcher.addUTxOs(utxos);
 * fetcher.addSerializedTransaction("txHash");
 *
 * // Use the fetcher with MeshWallet
 * const wallet = new MeshWallet({
 *   networkId: 0,
 *   fetcher: fetcher,
 *   key: {
 *     type: 'address',
 *     address: walletAddress
 *   }
 * });
 * ```
 */
declare class OfflineFetcher implements IFetcher {
    private network?;
    private accounts;
    private utxos;
    private assetAddresses;
    private assetMetadata;
    private blocks;
    private collections;
    private protocolParameters;
    private transactions;
    constructor(network?: Network | undefined);
    private paginate;
    /**
     * Fetches account information for a given address.
     * @param address - Address to fetch info for
     * @returns Promise resolving to account information
     * @throws Error if account not found
     */
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    /**
     * Fetches UTXOs for a given address, optionally filtered by asset.
     * @param address - Address to fetch UTXOs for
     * @param asset - Optional asset ID to filter UTXOs
     * @returns Promise resolving to array of UTXOs
     */
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    /**
     * WIP - NOT IMPLEMENTED
     * @param address
     * @param options
     */
    fetchAddressTxs(address: string, options?: IFetcherOptions): Promise<TransactionInfo[]>;
    /**
     * Fetches addresses holding a specific asset.
     * @param asset - Asset identifier
     * @returns Promise resolving to array of asset addresses and quantities
     */
    fetchAssetAddresses(asset: string): Promise<AssetAddress[]>;
    /**
     * Fetches all assets associated with an address.
     * @param address - Address to fetch assets for
     * @returns Promise resolving to array of assets held by the address
     */
    fetchAddressAssets(address: string): Promise<Asset[]>;
    /**
     * Fetches metadata for a specific asset.
     * @param asset - Asset identifier
     * @returns Promise resolving to asset metadata
     * @throws Error if asset metadata not found
     */
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    /**
     * Fetches information about a specific block.
     * @param hash - Block hash
     * @returns Promise resolving to block information
     * @throws Error if block not found
     */
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    /**
     * Fetches assets in a collection (by policy ID) with pagination.
     * @param policyId - Policy ID of the collection
     * @param cursor - Optional pagination cursor
     * @returns Promise resolving to paginated assets and next cursor
     * @throws Error if collection not found or invalid cursor
     */
    fetchCollectionAssets(policyId: string, cursor?: number | string): Promise<{
        assets: Asset[];
        next?: string | number;
    }>;
    /**
     * Fetches metadata for a handle.
     * @param handle - Handle to fetch metadata for
     * @returns Promise resolving to handle metadata
     * @throws Error if handle not found or invalid
     */
    fetchHandle(handle: string): Promise<AssetMetadata>;
    /**
     * Fetches address associated with a handle.
     * @param handle - Handle to fetch address for
     * @returns Promise resolving to address
     * @throws Error if no address found for handle
     */
    fetchHandleAddress(handle: string): Promise<string>;
    /**
     * Fetches protocol parameters for a specific epoch.
     * @param epoch - Epoch number
     * @returns Promise resolving to protocol parameters
     * @throws Error if parameters not found for epoch
     */
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    /**
     * Fetches information about a specific transaction.
     * @param hash - Transaction hash
     * @returns Promise resolving to transaction information
     * @throws Error if transaction not found
     */
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    /**
     * Fetches all UTXOs associated with a specific transaction hash.
     * @param hash - Transaction hash to fetch UTXOs for
     * @returns Promise resolving to array of UTXOs associated with the transaction
     * @throws Error if no UTXOs found for the transaction hash
     */
    fetchUTxOs(hash: string): Promise<UTxO[]>;
    fetchGovernanceProposal(txHash: string, certIndex: number): Promise<any>;
    /**
     * HTTP GET method required by IFetcher interface but not implemented in OfflineFetcher.
     * @param url - URL to fetch from
     * @throws Error always, as this fetcher operates offline
     */
    get(url: string): Promise<any>;
    /**
     * Serializes fetcher data to JSON string.
     * @returns JSON string containing all fetcher data
     */
    toJSON(): string;
    /**
     * Creates an OfflineFetcher instance from JSON data.
     * @param json - JSON string containing fetcher data
     * @returns New OfflineFetcher instance
     */
    static fromJSON(json: string): OfflineFetcher;
    private static isValidHex;
    private static isValidAddress;
    private static isValidBase58;
    private static isValidBech32;
    private static isValidBech32Address;
    private static isValidBech32Pool;
    private static isValidBech32VrfVk;
    private static isIntegerString;
    private static isValidAssetOrLovelace;
    /**
     * Adds account information to the fetcher.
     * @param address - Account address
     * @param accountInfo - Account information
     * @throws Error if address or account info invalid
     */
    addAccount(address: string, accountInfo: AccountInfo): void;
    /**
     * Adds UTXOs to the fetcher.
     * @param utxos - Array of UTXOs
     * @throws Error if UTXOs invalid
     */
    addUTxOs(utxos: UTxO[]): void;
    /**
     * Adds asset address information to the fetcher.
     * @param asset - Asset identifier
     * @param addresses - Array of asset addresses
     * @throws Error if asset or addresses invalid
     */
    addAssetAddresses(asset: string, addresses: AssetAddress[]): void;
    /**
     * Adds asset metadata to the fetcher.
     * @param asset - Asset identifier
     * @param metadata - Asset metadata
     * @throws Error if asset or metadata invalid
     */
    addAssetMetadata(asset: string, metadata: AssetMetadata): void;
    /**
     * Adds collection assets to the fetcher.
     * @param assets - Array of assets
     * @throws Error if assets invalid
     */
    addCollectionAssets(assets: Asset[]): void;
    /**
     * Adds protocol parameters to the fetcher.
     * @param parameters - Protocol parameters
     * @throws Error if parameters invalid
     */
    addProtocolParameters(parameters: Protocol): void;
    /**
     * Adds transaction information to the fetcher.
     * @param txInfo - Transaction information
     * @throws Error if transaction info invalid
     */
    addTransaction(txInfo: TransactionInfo): void;
    /**
     * Adds block information to the fetcher.
     * @param blockInfo - Block information
     * @throws Error if block info invalid
     */
    addBlock(blockInfo: BlockInfo): void;
    /**
     * Adds a serialized transaction to the fetcher, it's generates pseudo block in addition to transaction.
     * Removes spent UTxOs from the fetcher and adds new UTxOs from the transaction.
     * @param txHex - Hexadecimal string of the transaction
     * @throws Error if transaction hex invalid
     */
    addSerializedTransaction(txHex: string): void;
    private slotToEpochSlot;
    private mapOutputToUTxO;
    private mapValueToAsset;
}

type BlockfrostCachingOptions = {
    enableCaching?: boolean;
    offlineFetcher?: OfflineFetcher;
};
type BlockfrostSupportedNetworks = "mainnet" | "preview" | "preprod";
/**
 * Blockfrost provides restful APIs which allows your app to access information stored on the blockchain.
 *
 * Usage:
 * ```
 * import { BlockfrostProvider } from "@meshsdk/core";
 *
 * const provider = new BlockfrostProvider('<Your-API-Key>');
 *
 * // With caching enabled
 * const providerWithCache = new BlockfrostProvider('<Your-API-Key>', 0, { enableCaching: true });
 * ```
 */
declare class BlockfrostProvider implements IFetcher, IListener, ISubmitter, IEvaluator {
    private readonly _axiosInstance;
    private readonly _network;
    private submitTxToBytes;
    private _offlineFetcher?;
    private _enableCaching;
    /**
     * If you are using a privately hosted Blockfrost instance, you can set the URL in the parameter.
     * @param baseUrl The base URL of the instance.
     * @param cachingOptions Optional caching configuration
     */
    constructor(baseUrl: string, cachingOptions?: BlockfrostCachingOptions);
    /**
     * If you are using [Blockfrost](https://blockfrost.io/) hosted instance, you can set the project ID in the parameter.
     * @param projectId The project ID of the instance.
     * @param version The version of the API. Default is 0.
     * @param cachingOptions Optional caching configuration
     */
    constructor(projectId: string, version?: number, cachingOptions?: BlockfrostCachingOptions);
    /**
     * Evaluates the resources required to execute the transaction
     * @param cbor - The transaction CBOR hex string to evaluate
     * @param additionalUtxos - Optional array of additional UTxOs to include in the evaluation context for resolving transaction inputs
     * @param additionalTxs - Optional array of transaction CBOR hex strings to provide additional UTxOs from their outputs
     */
    evaluateTx(cbor: string, additionalUtxos?: UTxO[], additionalTxs?: string[]): Promise<Omit<Action, "data">[]>;
    /**
     * Obtain information about a specific stake account.
     * @param address - Wallet address to fetch account information
     */
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    /**
     * Fetches the assets for a given address.
     * @param address - The address to fetch assets for
     * @returns A map of asset unit to quantity
     */
    fetchAddressAssets(address: string): Promise<{
        [key: string]: string;
    }>;
    /**
     * Transactions for an address. The `TransactionInfo` would only return the `hash`, `inputs`, and `outputs`.
     * @param address - The address to fetch transactions for
     * @returns - partial TransactionInfo
     */
    fetchAddressTxs(address: string, option?: IFetcherOptions): Promise<TransactionInfo[]>;
    /**
     * Deprecated, use fetchAddressTxs instead
     * @param address
     * @returns - partial TransactionInfo
     */
    fetchAddressTransactions(address: string): Promise<TransactionInfo[]>;
    /**
     * UTXOs of the address.
     * @param address - The address to fetch UTXO
     * @param asset - UTXOs of a given asset​
     * @returns - Array of UTxOs
     */
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    /**
     * Fetches the asset addresses for a given asset.
     * @param asset - The asset to fetch addresses for
     */
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    /**
     * Fetches the metadata for a given asset.
     * @param asset - The asset to fetch metadata for
     * @returns The metadata for the asset
     */
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    /**
     * Fetches the metadata for a given asset.
     * @param asset - The asset to fetch metadata for
     * @returns The metadata for the asset
     */
    fetchLatestBlock(): Promise<BlockInfo>;
    /**
     * Fetches the block information for a given block hash.
     * @param hash The block hash to fetch from
     * @returns The block information
     */
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    /**
     * Fetches the list of assets for a given policy ID.
     * @param policyId The policy ID to fetch assets for
     * @param cursor The cursor for pagination
     * @returns The list of assets and the next cursor
     */
    fetchCollectionAssets(policyId: string, cursor?: number): Promise<{
        assets: Asset[];
        next: string | number | null;
    }>;
    fetchHandle(handle: string): Promise<AssetMetadata>;
    fetchHandleAddress(handle: string): Promise<string>;
    /**
     * Fetch the latest protocol parameters.
     * @param epoch Optional - The epoch to fetch protocol parameters for
     * @returns - Protocol parameters
     */
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    /**
     * Fetches the transaction information for a given transaction hash.
     * @param hash The transaction hash to fetch
     * @returns The transaction information
     */
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    /**
     * Get UTxOs for a given hash.
     * @param hash The transaction hash
     * @param index Optional - The output index for filtering post fetching
     * @returns - Array of UTxOs
     */
    fetchUTxOs(hash: string, index?: number): Promise<UTxO[]>;
    /**
     * Fetches the governance proposal information.
     * @param txHash The transaction hash of the proposal
     * @param certIndex The certificate index of the proposal
     * @returns The governance proposal information
     */
    fetchGovernanceProposal(txHash: string, certIndex: number): Promise<GovernanceProposalInfo>;
    /**
     * A generic method to fetch data from a URL.
     * @param url - The URL to fetch data from
     * @returns - The data fetched from the URL
     */
    get(url: string): Promise<any>;
    /**
     * A generic method to post data to a URL.
     * @param url - The URL to fetch data from
     * @param body - Payload
     * @param headers - Specify headers, default: { "Content-Type": "application/json" }
     * @returns - Data
     */
    post(url: string, body: any, headers?: {
        "Content-Type": string;
    }): Promise<any>;
    /**
     * Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.
     * @param txHash - The transaction hash to listen for confirmation
     * @param callback - The callback function to call when the transaction is confirmed
     * @param limit - The number of blocks to wait for confirmation
     */
    onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;
    setSubmitTxToBytes(value: boolean): void;
    /**
     * Submit a serialized transaction to the network.
     * @param tx - The serialized transaction in hex to submit
     * @returns The transaction hash of the submitted transaction
     */
    submitTx(tx: string): Promise<string>;
    private resolveScriptRef;
    private toUTxO;
    private fetchPlutusScriptCBOR;
    private fetchNativeScriptJSON;
    /**
     * Enable or disable caching functionality.
     * @param enable - Whether to enable caching
     * @param offlineFetcher - Optional custom OfflineFetcher instance to use
     */
    setCaching(enable: boolean, offlineFetcher?: OfflineFetcher): void;
    /**
     * Get the current OfflineFetcher instance if caching is enabled.
     * @returns The OfflineFetcher instance or undefined if caching is disabled
     */
    getOfflineFetcher(): OfflineFetcher | undefined;
    /**
     * Check if caching is currently enabled.
     * @returns True if caching is enabled, false otherwise
     */
    isCachingEnabled(): boolean;
    /**
     * Export the cached data as JSON string.
     * @returns JSON string of cached data or null if caching is disabled
     */
    exportCache(): string | null;
    /**
     * Import cached data from JSON string.
     * @param jsonData - JSON string containing cached data
     * @param enableCaching - Whether to enable caching if not already enabled
     */
    importCache(jsonData: string, enableCaching?: boolean): void;
    /**
     * Clear all cached data.
     */
    clearCache(): void;
}

type KoiosSupportedNetworks = "api" | "preview" | "preprod" | "guild";
declare class KoiosProvider implements IFetcher, IListener, ISubmitter, IEvaluator {
    private readonly _axiosInstance;
    private readonly _network;
    constructor(baseUrl: string);
    constructor(network: KoiosSupportedNetworks, token: string, version?: number);
    /**
     * Obtain information about a specific stake account.
     * @param address - Wallet address to fetch account information
     */
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    /**
     * Fetches the assets for a given address.
     * @param address - The address to fetch assets for
     * @returns A map of asset unit to quantity
     */
    fetchAddressAssets(address: string): Promise<{
        [key: string]: string;
    }>;
    /**
     * Unimplemented - open for contribution, see blockfrost.ts for reference
     * @param address
     */
    fetchAddressTxs(address: string, option?: IFetcherOptions): Promise<TransactionInfo[]>;
    /**
     * UTXOs of the address.
     * @param address - The address to fetch UTXO
     * @param asset - UTXOs of a given asset​
     * @returns - Array of UTxOs
     */
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    /**
     * Fetches the asset addresses for a given asset.
     * @param asset - The asset to fetch addresses for
     */
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    /**
     * Fetches the metadata for a given asset.
     * @param asset - The asset to fetch metadata for
     * @returns The metadata for the asset
     */
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    /**
     * Fetches the block information for a given block hash.
     * @param hash The block hash to fetch from
     * @returns The block information
     */
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    /**
     * Fetches the list of assets for a given policy ID.
     * @param policyId The policy ID to fetch assets for
     * @param cursor The cursor for pagination
     * @returns The list of assets and the next cursor
     */
    fetchCollectionAssets(policyId: string): Promise<{
        assets: Asset[];
    }>;
    fetchHandle(handle: string): Promise<AssetMetadata>;
    fetchHandleAddress(handle: string): Promise<string>;
    /**
     * Fetch the latest protocol parameters.
     * @param epoch
     * @returns - Protocol parameters
     */
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    /**
     * Fetches the transaction information for a given transaction hash.
     * @param hash The transaction hash to fetch
     * @returns The transaction information
     */
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    /**
     * Get UTxOs for a given hash.
     * @param hash The transaction hash
     * @param index Optional - The output index for filtering post fetching
     * @returns - Array of UTxOs
     */
    fetchUTxOs(hash: string, index?: number): Promise<UTxO[]>;
    fetchGovernanceProposal(txHash: string, certIndex: number): Promise<GovernanceProposalInfo>;
    /**
     * A generic method to fetch data from a URL.
     * @param url - The URL to fetch data from
     * @returns - The data fetched from the URL
     */
    get(url: string): Promise<any>;
    /**
     * A generic method to post data to a URL.
     * @param url - The URL to fetch data from
     * @param body - Payload
     * @param headers - Specify headers, default: { "Content-Type": "application/json" }
     * @returns - Data
     */
    post(url: string, body: any, headers?: {
        "Content-Type": string;
    }): Promise<any>;
    /**
     * Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.
     * @param txHash - The transaction hash to listen for confirmation
     * @param callback - The callback function to call when the transaction is confirmed
     * @param limit - The number of blocks to wait for confirmation
     */
    onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;
    /**
     * Deprecated, use fetchAddressTxs instead
     * @param address
     * @returns - partial TransactionInfo
     */
    fetchAddressTransactions(address: string): Promise<TransactionInfo[]>;
    /**
     * Submit a serialized transaction to the network.
     * @param tx - The serialized transaction in hex to submit
     * @returns The transaction hash of the submitted transaction
     */
    submitTx(tx: string): Promise<string>;
    private toUTxO;
    private resolveScriptRef;
    /**
     * Evaluates the resources required to execute the transaction
     * @param cbor - The transaction CBOR hex string to evaluate
     * @param additionalUtxos - Optional array of additional UTxOs to include in the evaluation context for resolving transaction inputs
     * @param additionalTxs - Optional array of transaction CBOR hex strings to provide additional UTxOs from their outputs
     */
    evaluateTx(cbor: string, additionalUtxos?: UTxO[], additionalTxs?: string[]): Promise<Omit<Action, "data">[]>;
}

type MaestroSupportedNetworks = "Mainnet" | "Preprod" | "Preview";
interface MaestroConfig$1 {
    network: MaestroSupportedNetworks;
    apiKey: string;
    turboSubmit?: boolean;
}
declare class MaestroProvider implements IFetcher, ISubmitter, IEvaluator, IListener {
    private readonly _axiosInstance;
    private readonly _amountsAsStrings;
    private readonly _network;
    private submitTxToBytes;
    submitUrl: string;
    constructor({ network, apiKey, turboSubmit }: MaestroConfig$1);
    /**
     * Evaluates the resources required to execute the transaction
     * @param cbor - The transaction CBOR hex string to evaluate
     * @param additionalUtxos - Optional array of additional UTxOs to include in the evaluation context for resolving transaction inputs
     * @param additionalTxs - Optional array of transaction CBOR hex strings to provide additional UTxOs from their outputs
     */
    evaluateTx(cbor: string, additionalUtxos?: UTxO[], additionalTxs?: string[]): Promise<Omit<Action, "data">[]>;
    /**
     * Obtain information about a specific stake account.
     * @param address - Wallet address to fetch account information
     */
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    /**
     * Fetches the assets for a given address.
     * @param address - The address to fetch assets for
     * @returns A map of asset unit to quantity
     */
    fetchAddressAssets(address: string): Promise<{
        [key: string]: string;
    }>;
    /**
     * UTXOs of the address.
     * @param address - The address to fetch UTXO
     * @param asset - UTXOs of a given asset​
     * @returns - Array of UTxOs
     */
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    /**
     * Unimplemented - open for contribution
     *
     * Transactions for an address. The `TransactionInfo` would only return the `hash`, `inputs`, and `outputs`.
     * @param address
     * @returns - partial TransactionInfo
     */
    fetchAddressTxs(address: string, option?: IFetcherOptions): Promise<TransactionInfo[]>;
    /**
     * Fetches the asset addresses for a given asset.
     * @param asset - The asset to fetch addresses for
     */
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    /**
     * Fetches the metadata for a given asset.
     * @param asset - The asset to fetch metadata for
     * @returns The metadata for the asset
     */
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    /**
     * Fetches the block information for a given block hash.
     * @param hash The block hash to fetch from
     * @returns The block information
     */
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    /**
     * Fetches the list of assets for a given policy ID.
     * @param policyId The policy ID to fetch assets for
     * @param cursor The cursor for pagination
     * @returns The list of assets and the next cursor
     */
    fetchCollectionAssets(policyId: string, cursor?: string): Promise<{
        assets: Asset[];
        next: string | number | null;
    }>;
    fetchHandle(handle: string): Promise<object>;
    fetchHandleAddress(handle: string): Promise<string>;
    /**
     * Fetch the latest protocol parameters.
     * @param epoch
     * @returns - Protocol parameters
     */
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    /**
     * Fetches the transaction information for a given transaction hash.
     * @param hash The transaction hash to fetch
     * @returns The transaction information
     */
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    /**
     * Get UTxOs for a given hash.
     * @param hash The transaction hash
     * @param index Optional - The output index for filtering post fetching
     * @returns - Array of UTxOs
     */
    fetchUTxOs(hash: string, index?: number): Promise<UTxO[]>;
    /**
     * Unimplemented - open for contribution
     *
     * Fetches the governance proposal information.
     * @param txHash The transaction hash of the proposal
     * @param certIndex The certificate index of the proposal
     * @returns The governance proposal information
     */
    fetchGovernanceProposal(txHash: string, certIndex: number): Promise<GovernanceProposalInfo>;
    get(url: string): Promise<any>;
    post(url: string, body: any): Promise<any>;
    /**
     * Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.
     * @param txHash - The transaction hash to listen for confirmation
     * @param callback - The callback function to call when the transaction is confirmed
     * @param limit - The number of blocks to wait for confirmation
     */
    onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;
    setSubmitTxToBytes(value: boolean): void;
    /**
     * Submit a serialized transaction to the network.
     * @param tx - The serialized transaction in hex to submit
     * @returns The transaction hash of the submitted transaction
     */
    submitTx(tx: string): Promise<string>;
    private toUTxO;
    private resolveScript;
}

declare class OgmiosProvider implements IEvaluator, ISubmitter {
    private readonly _baseUrl;
    constructor(baseUrl: string);
    constructor(network: Network);
    /**
     * Evaluates the resources required to execute the transaction
     * @param cbor - The transaction CBOR hex string to evaluate
     * @param additionalUtxos - Optional array of additional UTxOs to include in the evaluation context for resolving transaction inputs
     * @param additionalTxs - Optional array of transaction CBOR hex strings to provide additional UTxOs from their outputs
     */
    evaluateTx(cbor: string, additionalUtxos?: UTxO[], additionalTxs?: string[]): Promise<Omit<Action, "data">[]>;
    onNextTx(callback: (tx: unknown) => void): Promise<() => void>;
    /**
     * Submit a serialized transaction to the network.
     * @param tx - The serialized transaction in hex to submit
     * @returns The transaction hash of the submitted transaction
     */
    submitTx(tx: string): Promise<string>;
    fetchProtocolParameters(): Promise<any>;
    private open;
    private send;
}

/**
 * A UTxO RPC Provider for [MeshJS](https://meshjs.dev/) Transaction Builder Library.
 *
 * Example usage of how to use the UTxO RPC provider with Mesh to build and submit a transaction.
 * ```
 * // Step #1
 * // Import Mesh SDK and UTxO RPC provider
 * import { Transaction, MeshWallet, U5CProvider } from "@meshsdk/core";
 *
 * async function main() {
 *   // Step #2
 *   // Create a new U5C provider
 *   const provider = new U5CProvider({
 *     url: "http://localhost:50051",
 *     headers: {
 *       "dmtr-api-key": "<api-key>",
 *     },
 *   });
 *
 *   // Step #3
 *   // Create a new wallet from a mnemonic
 *   const wallet = new MeshWallet({
 *     networkId: 0, // 0: testnet, 1: mainnet
 *     fetcher: provider,
 *     submitter: provider,
 *     key: {
 *       type: "mnemonic",
 *       words: [
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *       ],
 *     },
 *   });
 *
 *   // Optional: Print the wallet address
 *   console.log(wallet.getChangeAddress());
 *
 *   // Optional: Print the wallet utxos
 *   console.log(await provider.fetchAddressUTxOs(wallet.getChangeAddress()));
 *
 *   // Step #4
 *   // Create an example transaction that sends 5 ADA to an address
 *   const tx = new Transaction({
 *     initiator: wallet,
 *     verbose: false,
 *   }).sendLovelace(
 *     "addr_test1vpvx0sacufuypa2k4sngk7q40zc5c4npl337uusdh64kv0c7e4cxr",
 *     "5000000"
 *   );
 *   const unsignedTx = await tx.build();
 *
 *   // Step #5
 *   // Sign the transaction
 *   const signedTx = await wallet.signTx(unsignedTx);
 *
 *   // Step #6
 *   // Submit the transaction to the blockchain network
 *   const txId = await provider.submitTx(signedTx);
 *
 *   // Optional: Print the transaction ID
 *   console.log("Transaction ID", txId);
 * }
 *
 * main().catch(console.error);
 * ```
 */
declare class U5CProvider implements IFetcher, ISubmitter, IEvaluator, IListener {
    private queryClient;
    private submitClient;
    /**
     * Constructor initializes the query and submit clients with provided URL and optional headers.
     * @param url - The base URL for interacting with Cardano nodes.
     * @param headers - Optional HTTP headers for API requests.
     */
    constructor({ url, headers, }: {
        url: string;
        headers?: Record<string, string>;
    });
    /**
     * Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.
     * @param txHash - The transaction hash to listen for confirmation
     * @param callback - The callback function to call when the transaction is confirmed
     * @param limit - The number of blocks to wait for confirmation
     */
    onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;
    /**
     * Evaluates the resources required to execute the transaction
     * @param tx - The transaction to evaluate
     */
    evaluateTx(tx: string, additionalUtxos?: UTxO[], additionalTxs?: string[]): Promise<Omit<Action, "data">[]>;
    /**
     * Submit a serialized transaction to the network.
     * @param tx - The serialized transaction in hex to submit
     * @returns The transaction hash of the submitted transaction
     */
    submitTx(tx: string): Promise<string>;
    /**
     * Obtain information about a specific stake account.
     * @param address - Wallet address to fetch account information
     */
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    fetchAddressAssets(address: string): Promise<{
        [key: string]: string;
    }>;
    /**
     * Fetches the UTxOs for a given address.
     * @param address - The address to fetch UTxOs for
     * @param asset - The asset to filter UTxOs by (optional)
     * @returns UTxOs for the given address
     */
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    /**
     * Unimplemented - open for contribution
     *
     * Transactions for an address. The `TransactionInfo` would only return the `hash`, `inputs`, and `outputs`.
     * @param address - The address to fetch transactions for
     * @returns - partial TransactionInfo
     */
    fetchAddressTxs(address: string, option?: IFetcherOptions): Promise<TransactionInfo[]>;
    /**
     * Unimplemented - open for contribution
     *
     * Fetches the asset addresses for a given asset.
     * @param asset - The asset to fetch addresses for
     */
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    /**
     * Unimplemented - open for contribution
     *
     * Fetches the metadata for a given asset.
     * @param asset - The asset to fetch metadata for
     */
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    /**
     * Unimplemented - open for contribution
     *
     * Fetches the block information for a given block hash.
     * @param hash - The block hash to fetch block information for
     */
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    /**
     * Unimplemented - open for contribution
     *
     * Fetches the collection assets for a given policy ID.
     * @param policyId - The policy ID to fetch collection assets for
     * @param cursor - The cursor to fetch the next set of assets (optional)
     */
    fetchCollectionAssets(policyId: string, cursor?: number | string): Promise<{
        assets: Asset[];
        next?: string | number | null;
    }>;
    /**
     * Unimplemented - open for contribution
     *
     * Fetches the information (AssetMetadata) for a given handle.
     * @param handle - The handle to fetch information for
     */
    fetchHandle(handle: string): Promise<object>;
    /**
     * Unimplemented - open for contribution
     *
     * Resolve the handle's address from the handle.
     * @param handle - The handle to resolve
     */
    fetchHandleAddress(handle: string): Promise<string>;
    /**
     * Unimplemented - open for contribution
     *
     * Fetches protocol parameters
     */
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    /**
     * Unimplemented - open for contribution
     *
     * Fetches transaction info for a given hash.
     * @param hash - The transaction hash
     */
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    /**
     * Not complete - open for contribution
     *
     * Fetches output UTxOs of a given transaction hash.
     * @param hash - The transaction hash
     */
    fetchUTxOs(hash: string, index?: number): Promise<UTxO[]>;
    /**
     * Unimplemented - open for contribution
     *
     * Fetches the governance proposal information.
     * @param txHash The transaction hash of the proposal
     * @param certIndex The certificate index of the proposal
     * @returns The governance proposal information
     */
    fetchGovernanceProposal(txHash: string, certIndex: number): Promise<GovernanceProposalInfo>;
    /**
     * Unimplemented - open for contribution
     *
     * @param url
     */
    get(url: string): Promise<any>;
    /**
     * Waits for transaction confirmation within a given timeout.
     * @param txId - The transaction hash.
     * @param timeout - Optional timeout in milliseconds.
     * @returns True if the transaction is confirmed within the timeout, otherwise false.
     */
    awaitTransactionConfirmation(txId: string, timeout?: number): Promise<boolean>;
    /**
     * Helper function to convert an RPC UTxO object to a Mesh UTxO object.
     * @param rpcTxoRef - The transaction output reference from RPC.
     * @param rpcTxOutput - The transaction output details from RPC.
     * @returns A formatted UTxO object.
     */
    private _rpcUtxoToMeshUtxo;
    /**
     * Converts RPC protocol parameters to a Mesh Protocol object.
     * @param rpcPParams - The protocol parameters from the RPC.
     * @returns A Protocol object.
     */
    private _rpcPParamsToProtocol;
}

/**
 * Yaci DevKit is a development tool designed for rapid and efficient Cardano blockchain development. It allows developers to create and destroy custom Cardano devnets in seconds, providing fast feedback loops and simplifying the iteration process.
 *
 * Get started:
 * ```typescript
 * import { YaciProvider } from "@meshsdk/core";
 * const provider = new YaciProvider('<YACI_URL>', '<OPTIONAL_ADMIN_URL>');
 * ```
 */
declare class YaciProvider implements IFetcher, IListener, ISubmitter, IEvaluator {
    private readonly _axiosInstance;
    private readonly _adminAxiosInstance;
    /**
     * Set the URL of the instance.
     * @param baseUrl The base URL of the instance.
     */
    constructor(baseUrl?: string, adminUrl?: string);
    /**
     * Obtain information about a specific stake account.
     * @param address - Wallet address to fetch account information
     */
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    private resolveScriptRef;
    private toUTxO;
    /**
     * Fetches the assets for a given address.
     * @param address - The address to fetch assets for
     * @returns A map of asset unit to quantity
     */
    fetchAddressAssets(address: string): Promise<{
        [key: string]: string;
    }>;
    /**
     * UTXOs of the address.
     * @param address - The address to fetch UTXO
     * @param asset - UTXOs of a given asset​
     * @returns - Array of UTxOs
     */
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    /**
     * Unimplemented - open for contribution
     *
     * Transactions for an address. The `TransactionInfo` would only return the `hash`, `inputs`, and `outputs`.
     * @param address - The address to fetch transactions for
     * @returns - partial TransactionInfo
     */
    fetchAddressTxs(address: string, option?: IFetcherOptions): Promise<TransactionInfo[]>;
    /**
     * Fetches the asset addresses for a given asset.
     * @param asset - The asset to fetch addresses for
     */
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    /**
     * Fetches the metadata for a given asset.
     * @param asset - The asset to fetch metadata for
     * @returns The metadata for the asset
     */
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    /**
     * Fetches the block information for a given block hash.
     * @param hash The block hash to fetch from
     * @returns The block information
     */
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    /**
     * Fetches the list of assets for a given policy ID.
     * @param policyId The policy ID to fetch assets for
     * @param cursor The cursor for pagination
     * @returns The list of assets and the next cursor
     */
    fetchCollectionAssets(policyId: string, cursor?: number): Promise<{
        assets: Asset[];
        next: string | number | null;
    }>;
    fetchHandle(handle: string): Promise<object>;
    fetchHandleAddress(handle: string): Promise<string>;
    /**
     * Fetch the latest protocol parameters.
     * @param epoch Optional - The epoch to fetch protocol parameters for
     * @returns - Protocol parameters
     */
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    /**
     * Fetches the transaction information for a given transaction hash.
     * @param hash The transaction hash to fetch
     * @returns The transaction information
     */
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    /**
     * Get UTxOs for a given hash.
     * @param hash The transaction hash
     * @param index Optional - The output index for filtering post fetching
     * @returns - Array of UTxOs
     */
    fetchUTxOs(hash: string, index?: number): Promise<UTxO[]>;
    /**
     * Unimplemented - open for contribution
     *
     * Fetches the governance proposal information.
     * @param txHash The transaction hash of the proposal
     * @param certIndex The certificate index of the proposal
     * @returns The governance proposal information
     */
    fetchGovernanceProposal(txHash: string, certIndex: number): Promise<GovernanceProposalInfo>;
    get(url: string): Promise<any>;
    /**
     * Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.
     * @param txHash - The transaction hash to listen for confirmation
     * @param callback - The callback function to call when the transaction is confirmed
     * @param limit - The number of blocks to wait for confirmation
     */
    onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;
    /**
     * Submit a serialized transaction to the network.
     * @param tx - The serialized transaction in hex to submit
     * @returns The transaction hash of the submitted transaction
     */
    submitTx(txHex: string): Promise<string>;
    /**
     * Evaluates the resources required to execute the transaction
     * @param tx - The transaction to evaluate
     */
    evaluateTx(txHex: string, additionalUtxos?: UTxO[], additionalTxs?: string[]): Promise<Omit<Action, "data">[]>;
    getDevnetInfo(): Promise<void>;
    getGenesisByEra(era: string): Promise<void>;
    /**
     * Topup address with ADA
     * @param address - Address to topup
     * @param amount - Amount to topup
     */
    addressTopup(address: string, amount: string): Promise<void>;
    private fetchPlutusScriptCBOR;
    private fetchNativeScriptJSON;
}

declare class KupoProvider implements IFetcher {
    baseUrl: string;
    private readonly _axiosInstance;
    constructor(baseUrl: string);
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    fetchAddressTxs(address: string, options?: IFetcherOptions): Promise<TransactionInfo[]>;
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    fetchCollectionAssets(policyId: string, cursor?: number | string): Promise<{
        assets: Asset[];
        next?: string | number | null;
    }>;
    fetchProtocolParameters(epoch: number): Promise<Protocol>;
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    fetchUTxOs(hash: string, index?: number): Promise<UTxO[]>;
    fetchGovernanceProposal(txHash: string, certIndex: number): Promise<GovernanceProposalInfo>;
    get(pattern: string): Promise<any>;
    private kupoValueToMeshValue;
}

type MaestroConfig = {
    chain: "cardano";
    apiKey: string;
    network: MaestroSupportedNetworks;
    turboSubmit?: boolean;
} | {
    chain: "bitcoin";
    apiKey: string;
    network: MaestroSupportedNetworks$1;
};
/**
 * Unified Maestro provider that supports both Cardano and Bitcoin operations.
 * Chain is specified in the constructor
 *
 * @example
 * ```typescript
 * // Cardano provider
 * const cardanoMaestro = new MaestroProvider({
 *   chain: "cardano",
 *   apiKey: "your-maestro-api-key",
 *   network: "Mainnet",
 *   turboSubmit: true
 * });
 *
 * // Bitcoin provider
 * const bitcoinMaestro = new MaestroProvider({
 *   chain: "bitcoin",
 *   apiKey: "your-maestro-api-key",
 *   network: "mainnet"
 * });
 *
 * // Clean unified API
 * const cardanoTxs = await cardanoMaestro.getAddressTxs(address);
 * const bitcoinUTxOs = await bitcoinMaestro.getAddressUTxOs(address);
 * ```
 */
declare class MaestroMultiChainProvider {
    private _cardanoProvider?;
    private _bitcoinProvider?;
    private _chain;
    /**
     * Create a Maestro provider for the specified chain.
     * @param config - Chain-specific configuration object.
     */
    constructor(config: MaestroConfig);
    /**
     * Get address transactions.
     * @param address - The address to query.
     * @param options - For Cardano: IFetcherOptions, for Bitcoin: lastSeenTxId string.
     * @returns Promise of transaction array (type depends on chain).
     */
    getAddressTxs(address: string, options?: IFetcherOptions | string): Promise<TransactionInfo[] | TransactionsInfo[]>;
    /**
     * Get address UTXOs.
     * @param address - The address to query.
     * @returns Promise of UTXO array (type depends on chain).
     */
    getAddressUTxOs(address: string): Promise<UTxO[] | UTxO$1[]>;
    /**
     * Get address information including balance, transaction count, and UTXO statistics.
     * Available for Bitcoin only - Cardano doesn't have this endpoint.
     * @param address - The Bitcoin address to query.
     * @returns Promise of address info with chain_stats and mempool_stats.
     */
    getAddressInfo(address: string): Promise<AddressInfo>;
    /**
     * Submit a transaction.
     * @param txData - The transaction data (format depends on chain).
     * @returns Promise of transaction ID.
     */
    submitTx(txData: string): Promise<string>;
    /**
     * Get the configured chain.
     * @returns The chain this provider is configured for.
     */
    getChain(): "cardano" | "bitcoin";
    /**
     * Get transaction details by hash.
     * @param txHash - The transaction hash.
     * @returns Promise of transaction details (type depends on chain).
     */
    getTxInfo(txHash: string): Promise<TransactionInfo | TransactionsInfo>;
    /**
     * Get transaction status/confirmation details.
     * @param txHash - The transaction hash.
     * @returns Promise of transaction status (type depends on chain).
     */
    getTxStatus(txHash: string): Promise<{
        confirmed: boolean;
        details: TransactionInfo;
    } | TransactionsStatus>;
    /**
     * Get the configured network.
     * @returns The network configuration.
     */
    getNetwork(): Promise<string>;
    /**
     * Generic GET request to chain-specific API endpoints.
     * @param url - The API endpoint URL (relative to the chain's base URL).
     * @returns The response data.
     */
    get(url: string): Promise<any>;
    /**
     * Generic POST request to chain-specific API endpoints.
     * @param url - The API endpoint URL (relative to the chain's base URL).
     * @param body - The request body data.
     * @returns The response data.
     */
    post(url: string, body: any): Promise<any>;
}

export { BeginProvider, type BlockfrostCachingOptions, BlockfrostProvider, type BlockfrostSupportedNetworks, KoiosProvider, type KoiosSupportedNetworks, KupoProvider, type MaestroConfig, MaestroMultiChainProvider, MaestroProvider, type MaestroSupportedNetworks, OfflineFetcher, OgmiosProvider, U5CProvider, YaciProvider };
