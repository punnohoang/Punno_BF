// ../../node_modules/bignumber.js/bignumber.mjs
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "\xA0",
    // non-breaking space
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v, b) {
    var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
    if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);
    if (b == null) {
      if (v && v._isBigNumber === true) {
        x.s = v.s;
        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }
        return;
      }
      if ((isNum = typeof v == "number") && v * 0 == 0) {
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;
        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++) ;
          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }
          return;
        }
        str = String(v);
      } else {
        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e < 0) e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        e = str.length;
      }
    } else {
      intCheck(b, 2, ALPHABET.length, "Base");
      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber2(v);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }
      str = String(v);
      if (isNum = typeof v == "number") {
        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET.slice(0, b);
      e = i = 0;
      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == ".") {
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }
          return parseNumeric(x, String(v), isNum, b);
        }
      }
      isNum = false;
      str = convertBase(str, b, 10, x.s);
      if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
      else e = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++) ;
    for (len = str.length; str.charCodeAt(--len) === 48; ) ;
    if (str = str.slice(i, ++len)) {
      len -= i;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x.s * v);
      }
      if ((e = e - i - 1) > MAX_EXP) {
        x.c = x.e = null;
      } else if (e < MIN_EXP) {
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE;
        if (i < len) {
          if (i) x.c.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; ) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }
          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }
        for (; i--; str += "0") ;
        x.c.push(+str);
      }
    } else {
      x.c = [x.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p, v;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }
        if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }
        if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }
        if (obj.hasOwnProperty(p = "RANGE")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p + " cannot be zero: " + v);
            }
          }
        }
        if (obj.hasOwnProperty(p = "CRYPTO")) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p + " not true or false: " + v);
          }
        }
        if (obj.hasOwnProperty(p = "MODULO_MODE")) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }
        if (obj.hasOwnProperty(p = "POW_PRECISION")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }
        if (obj.hasOwnProperty(p = "FORMAT")) {
          v = obj[p];
          if (typeof v == "object") FORMAT = v;
          else throw Error(bignumberError + p + " not an object: " + v);
        }
        if (obj.hasOwnProperty(p = "ALPHABET")) {
          v = obj[p];
          if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
            ALPHABET = v;
          } else {
            throw Error(bignumberError + p + " invalid: " + v);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v) {
    if (!v || v._isBigNumber !== true) return false;
    if (!BigNumber2.DEBUG) return true;
    var i, n, c = v.c, e = v.e, s = v.s;
    out: if ({}.toString.call(c) == "[object Array]") {
      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
        if (c[0] === 0) {
          if (e === 0 && c.length === 1) return true;
          break out;
        }
        i = (e + 1) % LOG_BASE;
        if (i < 1) i += LOG_BASE;
        if (String(c[0]).length == i) {
          for (i = 0; i < c.length; i++) {
            n = c[i];
            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
          }
          if (n !== 0) return true;
        }
      }
    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
      return true;
    }
    throw Error(bignumberError + "Invalid BigNumber: " + v);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber2.random = (function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
      if (dp == null) dp = DECIMAL_PLACES;
      else intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));
          for (; i < k; ) {
            v = a[i] * 131072 + (a[i + 1] >>> 11);
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {
              c.push(v % 1e14);
              i += 2;
            }
          }
          i = k / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k *= 7);
          for (; i < k; ) {
            v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              c.push(v % 1e14);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i < k; ) {
          v = random53bitInt();
          if (v < 9e15) c[i++] = v % 1e14;
        }
      }
      k = c[--i];
      dp %= LOG_BASE;
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      }
      for (; c[i] === 0; c.pop(), i--) ;
      if (i < 0) {
        c = [e = 0];
      } else {
        for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
        for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
        if (i < LOG_BASE) e -= LOG_BASE - i;
      }
      rand.e = e;
      rand.c = c;
      return rand;
    };
  })();
  BigNumber2.sum = function() {
    var i = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i < args.length; ) sum = sum.plus(args[i++]);
    return sum;
  };
  convertBase = /* @__PURE__ */ (function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j, arr = [0], arrL, i = 0, len = str.length;
      for (; i < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
        arr[0] += alphabet.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i >= 0) {
        k = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y = new BigNumber2(baseIn);
        x = y.pow(str.length - i);
        POW_PRECISION = k;
        y.c = toBaseOut(
          toFixedPoint(coeffToString(x.c), x.e, "0"),
          10,
          baseOut,
          decimal
        );
        y.e = y.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
      e = k = xc.length;
      for (; xc[--k] == 0; xc.pop()) ;
      if (!xc[0]) return alphabet.charAt(0);
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;
        x.s = sign;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }
      d = e + dp + 1;
      i = xc[d];
      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;
      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
      if (d < 1 || !xc[0]) {
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d;
        if (r) {
          for (--baseOut; ++xc[--d] > baseOut; ) {
            xc[d] = 0;
            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }
        for (k = xc.length; !xc[--k]; ) ;
        for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) ;
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }
      return str;
    };
  })();
  div = /* @__PURE__ */ (function() {
    function multiply(x, k, base) {
      var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
      for (x = x.slice(); i--; ) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }
      if (carry) x = [carry].concat(x);
      return x;
    }
    function compare2(a, b, aL, bL) {
      var i, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a, b, aL, base) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
    }
    return function(x, y, dp, rm, base) {
      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
          )
        );
      }
      q = new BigNumber2(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;
      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i = 0; yc[i] == (xc[i] || 0); i++) ;
      if (yc[i] > (xc[i] || 0)) e--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;
        n = mathfloor(base / (yc[0] + 1));
        if (n > 1) {
          yc = multiply(yc, n, base);
          xc = multiply(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0) ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2) yc0++;
        do {
          n = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
            n = mathfloor(rem0 / yc0);
            if (n > 1) {
              if (n >= base) n = base - 1;
              prod = multiply(yc, n, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n == 0) {
                cmp = n = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL) prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          }
          qc[i++] = n;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0]) qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e;
        q.r = +more;
      }
      return q;
    };
  })();
  function format(n, i, rm, id) {
    var c0, e, ne, len, str;
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    if (!n.c) return n.toString();
    c0 = n.c[0];
    ne = n.e;
    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n = round(new BigNumber2(n), i, rm);
      e = n.e;
      str = coeffToString(n.c);
      len = str.length;
      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
        for (; len < i; str += "0", len++) ;
        str = toExponential(str, e);
      } else {
        i -= ne + (id === 2 && e > ne);
        str = toFixedPoint(str, e, "0");
        if (e + 1 > len) {
          if (--i > 0) for (str += "."; i--; str += "0") ;
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len) str += ".";
            for (; i--; str += "0") ;
          }
        }
      }
    }
    return n.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, n) {
    var k, y, i = 1, x = new BigNumber2(args[0]);
    for (; i < args.length; i++) {
      y = new BigNumber2(args[i]);
      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
        x = y;
      }
    }
    return x;
  }
  function normalise(n, c, e) {
    var i = 1, j = c.length;
    for (; !c[--j]; c.pop()) ;
    for (j = c[0]; j >= 10; j /= 10, i++) ;
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
      n.c = n.e = null;
    } else if (e < MIN_EXP) {
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }
    return n;
  }
  parseNumeric = /* @__PURE__ */ (function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x, str, isNum, b) {
      var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function(m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b || b == base ? p1 : m;
          });
          if (b) {
            base = b;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s) return new BigNumber2(s, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
        }
        x.s = null;
      }
      x.c = x.e = null;
    };
  })();
  function round(x, sd, rm, r) {
    var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
        i = sd - d;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0];
          rd = mathfloor(n / pows10[d - j - 1] % 10);
        } else {
          ni = mathceil((i + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (; xc.length <= ni; xc.push(0)) ;
              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni];
            for (d = 1; k >= 10; k /= 10, d++) ;
            i %= LOG_BASE;
            j = i - LOG_BASE + d;
            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
          }
        }
        r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            xc[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];
          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        }
        if (r) {
          for (; ; ) {
            if (ni == 0) {
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++) ;
              if (i != k) {
                x.e++;
                if (xc[0] == BASE) xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE) break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }
        for (i = xc.length; xc[--i] === 0; xc.pop()) ;
      }
      if (x.e > MAX_EXP) {
        x.c = x.e = null;
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }
    return x;
  }
  function valueOf(n) {
    var str, e = n.e;
    if (e === null) return n.toString();
    str = coeffToString(n.c);
    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
    return n.s < 0 ? "-" + str : str;
  }
  P.absoluteValue = P.abs = function() {
    var x = new BigNumber2(this);
    if (x.s < 0) x.s = 1;
    return x;
  };
  P.comparedTo = function(y, b) {
    return compare(this, new BigNumber2(y, b));
  };
  P.decimalPlaces = P.dp = function(dp, rm) {
    var c, n, v, x = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(new BigNumber2(x), dp + x.e + 1, rm);
    }
    if (!(c = x.c)) return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
    if (n < 0) n = 0;
    return n;
  };
  P.dividedBy = P.div = function(y, b) {
    return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P.dividedToIntegerBy = P.idiv = function(y, b) {
    return div(this, new BigNumber2(y, b), 0, 1);
  };
  P.exponentiatedBy = P.pow = function(n, m) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
    n = new BigNumber2(n);
    if (n.c && !n.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
    }
    if (m != null) m = new BigNumber2(m);
    nIsBig = n.e > 14;
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
      y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }
    nIsNeg = n.s < 0;
    if (m) {
      if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
      isModExp = !nIsNeg && x.isInteger() && m.isInteger();
      if (isModExp) x = x.mod(m);
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
      k = x.s < 0 && isOdd(n) ? -0 : 0;
      if (x.e > -1) k = 1 / k;
      return new BigNumber2(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg) n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }
    y = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y = y.times(x);
        if (!y.c) break;
        if (k) {
          if (y.c.length > k) y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);
        }
      }
      if (i) {
        i = mathfloor(i / 2);
        if (i === 0) break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);
        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0) break;
          nIsOdd = i % 2;
        }
      }
      x = x.times(x);
      if (k) {
        if (x.c && x.c.length > k) x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);
      }
    }
    if (isModExp) return y;
    if (nIsNeg) y = ONE.div(y);
    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  P.integerValue = function(rm) {
    var n = new BigNumber2(this);
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };
  P.isEqualTo = P.eq = function(y, b) {
    return compare(this, new BigNumber2(y, b)) === 0;
  };
  P.isFinite = function() {
    return !!this.c;
  };
  P.isGreaterThan = P.gt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) > 0;
  };
  P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
  };
  P.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P.isLessThan = P.lt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) < 0;
  };
  P.isLessThanOrEqualTo = P.lte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = function() {
    return this.s < 0;
  };
  P.isPositive = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P.minus = function(y, b) {
    var i, j, t, xLTy, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b) return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b = a; b--; t.push(0)) ;
      t.reverse();
    } else {
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }
    if (xLTy) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }
    b = (j = yc.length) - (i = xc.length);
    if (b > 0) for (; b--; xc[i++] = 0) ;
    b = BASE - 1;
    for (; j > a; ) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b) ;
        --xc[i];
        xc[j] += BASE;
      }
      xc[j] -= yc[j];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
    if (!xc[0]) {
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }
    return normalise(y, xc, ye);
  };
  P.modulo = P.mod = function(y, b) {
    var q, s, x = this;
    y = new BigNumber2(y, b);
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber2(x);
    }
    if (MODULO_MODE == 9) {
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }
    y = x.minus(q.times(y));
    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
    return y;
  };
  P.multipliedBy = P.times = function(y, b) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;
        if (!xc || !yc) {
          y.c = y.e = null;
        } else {
          y.c = [0];
          y.e = 0;
        }
      }
      return y;
    }
    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i = xcL;
      xcL = ycL;
      ycL = i;
    }
    for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i = ycL; --i >= 0; ) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;
      for (k = xcL, j = i + k; j > i; ) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }
      zc[j] = c;
    }
    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y, zc, e);
  };
  P.negated = function() {
    var x = new BigNumber2(this);
    x.s = -x.s || null;
    return x;
  };
  P.plus = function(y, b) {
    var t, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b) return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.minus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc) return new BigNumber2(a / 0);
      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }
      t.reverse();
      for (; a--; t.push(0)) ;
      t.reverse();
    }
    a = xc.length;
    b = yc.length;
    if (a - b < 0) {
      t = yc;
      yc = xc;
      xc = t;
      b = a;
    }
    for (a = 0; b; ) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }
    return normalise(y, xc, ye);
  };
  P.precision = P.sd = function(sd, rm) {
    var c, n, v, x = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(new BigNumber2(x), sd, rm);
    }
    if (!(c = x.c)) return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;
    if (v = c[v]) {
      for (; v % 10 == 0; v /= 10, n--) ;
      for (v = c[0]; v >= 10; v /= 10, n++) ;
    }
    if (sd && x.e + 1 > n) n = x.e + 1;
    return n;
  };
  P.shiftedBy = function(k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k);
  };
  P.squareRoot = P.sqrt = function() {
    var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x));
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0) n += "0";
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new BigNumber2(n);
    } else {
      r = new BigNumber2(s + "");
    }
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3) s = 0;
      for (; ; ) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
          if (r.e < e) --s;
          n = n.slice(s - 3, s + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
    }
    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  P.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P.toFormat = function(dp, rm, format2) {
    var str, x = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x.toFixed(dp, rm);
    if (x.c) {
      var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2) {
        i = g1;
        g1 = g2;
        g2 = i;
        len -= i;
      }
      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
        if (isNeg) intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P.toFraction = function(md) {
    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
    if (md != null) {
      n = new BigNumber2(md);
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
      }
    }
    if (!xc) return new BigNumber2(x);
    d = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s = coeffToString(xc);
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber2(s);
    n0.c[0] = 0;
    for (; ; ) {
      q = div(n, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1) break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }
    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;
    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
      div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r;
  };
  P.toNumber = function() {
    return +valueOf(this);
  };
  P.toPrecision = function(sd, rm) {
    if (sd != null) intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P.toString = function(b) {
    var str, n = this, s = n.s, e = n.e;
    if (e === null) {
      if (s) {
        str = "Infinity";
        if (s < 0) str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, "0");
      } else {
        intCheck(b, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
      }
      if (s < 0 && n.c[0]) str = "-" + str;
    }
    return str;
  };
  P.valueOf = P.toJSON = function() {
    return valueOf(this);
  };
  P._isBigNumber = true;
  P[Symbol.toStringTag] = "BigNumber";
  P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
  if (configObject != null) BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}
function coeffToString(a) {
  var s, z, i = 1, j = a.length, r = a[0] + "";
  for (; i < j; ) {
    s = a[i++] + "";
    z = LOG_BASE - s.length;
    for (; z--; s = "0" + s) ;
    r += s;
  }
  for (j = r.length; r.charCodeAt(--j) === 48; ) ;
  return r.slice(0, j + 1 || 1);
}
function compare(x, y) {
  var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
  if (!i || !j) return null;
  a = xc && !xc[0];
  b = yc && !yc[0];
  if (a || b) return a ? b ? 0 : -j : i;
  if (i != j) return i;
  a = i < 0;
  b = k == l;
  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
  if (!b) return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}
function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
  }
}
function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}
function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
}
function toFixedPoint(str, e, z) {
  var len, zs;
  if (e < 0) {
    for (zs = z + "."; ++e; zs += z) ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e > len) {
      for (zs = z, e -= len; --e; zs += z) ;
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + "." + str.slice(e);
    }
  }
  return str;
}
var BigNumber = clone();
var bignumber_default = BigNumber;

// src/mesh-tx-builder/index.ts
import JSONBig3 from "json-bigint";
import {
  DEFAULT_PROTOCOL_PARAMETERS as DEFAULT_PROTOCOL_PARAMETERS3
} from "@meshsdk/common";
import {
  CardanoSDKSerializer,
  toDRep as coreToCstDRep,
  Address as CstAddress,
  AddressType as CstAddressType,
  CredentialType as CstCredentialType,
  NativeScript as CstNativeScript,
  Script as CstScript
} from "@meshsdk/core-cst";

// src/mesh-tx-builder/coin-selection/cardano-sdk-adapter.ts
import { Cardano as CSDK, Serialization } from "@cardano-sdk/core";
import * as CardanoSelection from "@cardano-sdk/input-selection";
import { HexBlob } from "@cardano-sdk/util";
import {
  fromBuilderToPlutusData,
  PlutusV1Script,
  PlutusV2Script,
  PlutusV3Script,
  Script
} from "@meshsdk/core-cst";
var FAKE_ADDRESS = "01beffbeffbeffbeffbeffbeffbeffbeffbeffbeffbeffbeffbeffbeefbeffbeffbeffbeffbeffbeffbeffbeffbeffbeffbeffbeffbeffbeef";
var BuilderCallbacksSdkBridge = class {
  builderCallback;
  utxoMap;
  usedUtxos;
  constructor(builderCallbacks, utxoMap, usedUtxos) {
    this.builderCallback = builderCallbacks;
    this.utxoMap = utxoMap;
    this.usedUtxos = usedUtxos;
  }
  computeMinimumCoinQuantity = (output) => {
    return this.builderCallback.computeMinimumCoinQuantity(
      CSDKOutputToMeshOutput(output)
    );
  };
  computeMinimumCost = async (selectionSkeleton) => {
    const costs = await this.builderCallback.computeMinimumCost({
      newInputs: this.getNewInputs(selectionSkeleton),
      newOutputs: /* @__PURE__ */ new Set(),
      change: selectionSkeleton.change.map(
        (output) => CSDKOutputToMeshOutput(output)
      ),
      fee: selectionSkeleton.fee
    });
    return {
      fee: costs.fee,
      redeemers: costs.redeemers?.map(meshActionToCSDKRedeemer)
    };
  };
  computeSelectionLimit = async (selectionSkeleton) => {
    const maxSizeExceed = await this.builderCallback.maxSizeExceed({
      newInputs: this.getNewInputs(selectionSkeleton),
      newOutputs: /* @__PURE__ */ new Set(),
      change: selectionSkeleton.change.map(
        (output) => CSDKOutputToMeshOutput(output)
      ),
      fee: selectionSkeleton.fee
    });
    return maxSizeExceed ? selectionSkeleton.inputs.size - 1 : selectionSkeleton.inputs.size + 1;
  };
  tokenBundleSizeExceedsLimit = (tokenBundle) => {
    return this.builderCallback.tokenBundleSizeExceedsLimit(
      CSDKTokenMapToMeshAssets(tokenBundle)
    );
  };
  getNewInputs = (selectionSkeleton) => {
    const newInputs = /* @__PURE__ */ new Set();
    for (const input of selectionSkeleton.inputs) {
      const utxoId = `${input[0].txId}#${input[0].index}`;
      if (this.usedUtxos.has(utxoId)) {
        continue;
      }
      const originalUtxo = this.utxoMap.get(utxoId);
      if (!originalUtxo) {
        throw new Error(`Missing required UTxO: ${utxoId}`);
      }
      newInputs.add(originalUtxo);
    }
    return newInputs;
  };
};
var CardanoSdkInputSelector = class {
  async select(preselectedUtxos, outputs, implicitValue, utxos, changeAddress, constraints) {
    const utxoMap = /* @__PURE__ */ new Map();
    for (const utxo of utxos) {
      utxoMap.set(`${utxo.input.txHash}#${utxo.input.outputIndex}`, utxo);
    }
    const aggregatedTxOut = makeAggregatedCSDKOOutput(outputs);
    const aggregatedOuts = /* @__PURE__ */ new Set();
    if (aggregatedTxOut) {
      aggregatedOuts.add(aggregatedTxOut);
    }
    const preselectedUtoxsCSDK = new Set(
      preselectedUtxos.map(meshTxInToCSDKUtxo)
    );
    const utxoxCSDK = utxos.map(meshUtxoToCSDKUtxo);
    const selector = CardanoSelection.roundRobinRandomImprove({
      changeAddressResolver: new StaticChangeAddressResolver(changeAddress)
    });
    const usedUtxos = /* @__PURE__ */ new Set();
    for (const utxo of preselectedUtxos) {
      usedUtxos.add(`${utxo.txIn.txHash}#${utxo.txIn.txIndex}`);
    }
    const builderCallbacksBridge = new BuilderCallbacksSdkBridge(
      constraints,
      utxoMap,
      usedUtxos
    );
    const selectResult = await selector.select({
      preSelectedUtxo: preselectedUtoxsCSDK,
      utxo: new Set(utxoxCSDK),
      outputs: aggregatedOuts,
      constraints: builderCallbacksBridge,
      implicitValue: meshImplicitCoinToCSDKImplicitCoins(implicitValue)
    });
    const newInputs = /* @__PURE__ */ new Set();
    for (const input of selectResult.selection.inputs) {
      const utxoId = `${input[0].txId}#${input[0].index}`;
      if (!usedUtxos.has(utxoId)) {
        const originalUtxo = utxoMap.get(utxoId);
        if (!originalUtxo) {
          throw new Error(`Missing required UTxO: ${utxoId}`);
        }
        newInputs.add(originalUtxo);
      }
    }
    return {
      newInputs,
      newOutputs: /* @__PURE__ */ new Set(),
      change: selectResult.selection.change.map(CSDKOutputToMeshOutput),
      fee: selectResult.selection.fee,
      redeemers: selectResult.redeemers?.map(CSDKRedeemerToMeshAction)
    };
  }
};
var StaticChangeAddressResolver = class {
  changeAddress;
  constructor(changeAddress) {
    this.changeAddress = changeAddress;
  }
  resolve = async (selection) => {
    return selection.change.map((txOut) => ({
      ...txOut,
      address: this.changeAddress
    }));
  };
};
var meshTxInToCSDKUtxo = (txIn) => {
  return [
    {
      txId: txIn.txIn.txHash,
      index: txIn.txIn.txIndex,
      address: txIn.txIn.address
    },
    {
      address: txIn.txIn.address,
      value: meshAssetsToCSDKValue(txIn.txIn.amount)
    }
  ];
};
var meshUtxoToCSDKUtxo = (utxo) => {
  return [
    {
      txId: utxo.input.txHash,
      index: utxo.input.outputIndex,
      address: utxo.output.address
    },
    {
      address: utxo.output.address,
      value: meshAssetsToCSDKValue(utxo.output.amount),
      datumHash: meshDataHashToCSDKDataHash(utxo.output.dataHash),
      datum: meshDatumToCSDKDatum(utxo.output.plutusData),
      scriptReference: meshScriptReferenceToCSDKScriptReference(
        utxo.output.scriptRef
      )
    }
  ];
};
var meshScriptReferenceToCSDKScriptReference = (scriptReference) => {
  if (!scriptReference) {
    return void 0;
  }
  return Serialization.Script.fromCbor(scriptReference).toCore();
};
var meshDatumToCSDKDatum = (datum) => {
  if (!datum) {
    return void 0;
  }
  return Serialization.PlutusData.fromCbor(datum).toCore();
};
var meshDataHashToCSDKDataHash = (hash) => {
  if (!hash) {
    return void 0;
  }
  return hash;
};
var meshAssetsToCSDKValue = (assets) => {
  if (!assets) {
    throw new Error(
      "Missing required assets. Be sure that you resolve all required UTxOs"
    );
  }
  let lovelace = 0n;
  const sdkAssets = /* @__PURE__ */ new Map();
  for (const asset of assets) {
    if (asset.unit === "lovelace" || asset.unit === "") {
      lovelace = BigInt(asset.quantity);
    } else {
      const assetId = asset.unit;
      sdkAssets.set(assetId, BigInt(asset.quantity));
    }
  }
  if (sdkAssets.size === 0) {
    return { coins: lovelace };
  }
  return {
    coins: lovelace,
    assets: sdkAssets
  };
};
var meshAssetsToCSDKAssets = (assets) => {
  if (!assets) {
    return void 0;
  }
  const sdkAssets = /* @__PURE__ */ new Map();
  for (const asset of assets) {
    if (asset.unit === "lovelace" || asset.unit === "") {
      throw new Error("Unexpected lovelace asset in assets");
    } else {
      const assetId = asset.unit;
      sdkAssets.set(assetId, BigInt(asset.quantity));
    }
  }
  return sdkAssets;
};
var CSDKOutputToMeshOutput = (output) => {
  const amount = CSDKValueToMeshAssets(output.value);
  return {
    address: output.address,
    amount
  };
};
var CSDKValueToMeshAssets = (value) => {
  const assets = [];
  if (value.coins !== 0n) {
    assets.push({
      unit: "lovelace",
      quantity: value.coins.toString()
    });
  }
  if (value.assets) {
    for (const [assetId, quantity] of value.assets) {
      assets.push({
        unit: assetId,
        quantity: quantity.toString()
      });
    }
  }
  return assets;
};
var CSDKTokenMapToMeshAssets = (tokenMap) => {
  if (!tokenMap) {
    return void 0;
  }
  const assets = [];
  for (const [assetId, quantity] of tokenMap) {
    assets.push({
      unit: assetId,
      quantity: quantity.toString()
    });
  }
  return assets;
};
var makeAggregatedCSDKOOutput = (outputs) => {
  let totalAssets = /* @__PURE__ */ new Map();
  for (const output of outputs) {
    totalAssets = sumAssets(totalAssets, output.amount);
  }
  if (totalAssets.size === 0) {
    return void 0;
  }
  return {
    address: FAKE_ADDRESS,
    value: assetsMapToCSDKValue(totalAssets)
  };
};
var assetsMapToCSDKValue = (assets) => {
  let lovelace = 0n;
  const sdkAssets = /* @__PURE__ */ new Map();
  for (const [unit, quantity] of assets) {
    if (unit === "lovelace" || unit === "") {
      lovelace = BigInt(quantity);
    } else {
      const assetId = unit;
      sdkAssets.set(assetId, BigInt(quantity));
    }
  }
  if (sdkAssets.size === 0) {
    return { coins: lovelace };
  }
  return {
    coins: lovelace,
    assets: sdkAssets
  };
};
var sumAssets = (a, b) => {
  for (const asset of b) {
    const currentAmount = a.get(asset.unit) ?? 0n;
    a.set(asset.unit, currentAmount + BigInt(asset.quantity));
  }
  return a;
};
var meshImplicitCoinToCSDKImplicitCoins = (implicitCoins) => {
  if (!implicitCoins) {
    return void 0;
  }
  const mint = meshAssetsToCSDKAssets(implicitCoins.mint);
  const totalInput = implicitCoins.reclaimDeposit + implicitCoins.withdrawals;
  const CSKDImplicitCoin = {
    withdrawals: implicitCoins.withdrawals,
    input: totalInput,
    deposit: implicitCoins.deposit,
    reclaimDeposit: implicitCoins.reclaimDeposit
  };
  return {
    coin: CSKDImplicitCoin,
    mint
  };
};
var meshActionToCSDKRedeemer = (action) => {
  return {
    purpose: meshRedeemerTagToCSDKRedeemerTag(action.tag),
    index: action.index,
    executionUnits: {
      steps: action.budget.steps,
      memory: action.budget.mem
    },
    data: 0n
  };
};
var CSDKRedeemerToMeshAction = (redeemer) => {
  return {
    tag: CSDKRedeemerTagToMeshRedeemerTag(redeemer.purpose),
    index: redeemer.index,
    budget: {
      steps: redeemer.executionUnits.steps,
      mem: redeemer.executionUnits.memory
    }
  };
};
var meshRedeemerTagToCSDKRedeemerTag = (tag) => {
  switch (tag) {
    case "SPEND":
      return CSDK.RedeemerPurpose.spend;
    case "MINT":
      return CSDK.RedeemerPurpose.mint;
    case "CERT":
      return CSDK.RedeemerPurpose.certificate;
    case "REWARD":
      return CSDK.RedeemerPurpose.withdrawal;
    case "PROPOSE":
      return CSDK.RedeemerPurpose.propose;
    case "VOTE":
      return CSDK.RedeemerPurpose.vote;
  }
};
var CSDKRedeemerTagToMeshRedeemerTag = (tag) => {
  switch (tag) {
    case CSDK.RedeemerPurpose.spend:
      return "SPEND";
    case CSDK.RedeemerPurpose.mint:
      return "MINT";
    case CSDK.RedeemerPurpose.certificate:
      return "CERT";
    case CSDK.RedeemerPurpose.withdrawal:
      return "REWARD";
    case CSDK.RedeemerPurpose.propose:
      return "PROPOSE";
    case CSDK.RedeemerPurpose.vote:
      return "VOTE";
  }
};

// src/mesh-tx-builder/coin-selection/largest-first-selector.ts
import { MAX_U64 } from "@cardano-sdk/input-selection";
var mergeValue = (a, b) => {
  const merged = new Map(a);
  b.forEach((quantity, unit) => {
    if (merged.has(unit)) {
      const mergedQuantity = merged.get(unit) + quantity;
      if (mergedQuantity === 0n) {
        merged.delete(unit);
      } else {
        merged.set(unit, mergedQuantity);
      }
    } else {
      merged.set(unit, quantity);
    }
  });
  return merged;
};
var subValue = (a, b) => {
  const subtracted = new Map(a);
  b.forEach((quantity, unit) => {
    if (subtracted.has(unit)) {
      const subtractedQuantity = subtracted.get(unit) - quantity;
      if (subtractedQuantity === 0n) {
        subtracted.delete(unit);
      } else {
        subtracted.set(unit, subtractedQuantity);
      }
    } else {
      subtracted.set(unit, -quantity);
    }
  });
  return subtracted;
};
var valueAllPositive = (value) => {
  return Array.from(value.values()).every((v) => v >= 0n);
};
var assetsToValue = (assets) => {
  const value = /* @__PURE__ */ new Map();
  assets.forEach((asset) => {
    const { unit, quantity } = asset;
    if (value.has(unit)) {
      value.set(unit, value.get(unit) + BigInt(quantity));
    } else {
      value.set(unit, BigInt(quantity));
    }
  });
  return value;
};
var outputToValue = (output) => {
  const value = /* @__PURE__ */ new Map();
  const amount = output.amount;
  amount.forEach((asset) => {
    const { unit, quantity } = asset;
    if (value.has(unit)) {
      value.set(unit, value.get(unit) + BigInt(quantity));
    } else {
      value.set(unit, BigInt(quantity));
    }
  });
  return value;
};
var txInToValue = (input) => {
  const amount = input.txIn.amount;
  if (!amount) {
    throw new Error(
      `UTxO amount info is missing for ${input.txIn.txHash}#${input.txIn.txIndex}`
    );
  }
  return assetsToValue(amount);
};
var implicitValueToValue = (implicitValue) => {
  let value = /* @__PURE__ */ new Map();
  value.set("lovelace", 0n);
  value.set(
    "lovelace",
    value.get("lovelace") + BigInt(implicitValue.withdrawals)
  );
  value.set("lovelace", value.get("lovelace") - BigInt(implicitValue.deposit));
  value = mergeValue(value, assetsToValue(implicitValue.mint));
  value.set(
    "lovelace",
    value.get("lovelace") + BigInt(implicitValue.reclaimDeposit)
  );
  return value;
};
var computeNetImplicitSelectionValues = (preselectedUtxos, outputs, implicitValue) => {
  let outputValueMap = /* @__PURE__ */ new Map();
  outputs.forEach((output) => {
    outputValueMap = mergeValue(outputValueMap, outputToValue(output));
  });
  const implicitValueMap = implicitValueToValue(implicitValue);
  let inputValueMap = /* @__PURE__ */ new Map();
  preselectedUtxos.forEach((input) => {
    inputValueMap = mergeValue(inputValueMap, txInToValue(input));
  });
  let requiredValue = /* @__PURE__ */ new Map();
  requiredValue = mergeValue(requiredValue, outputValueMap);
  requiredValue = subValue(requiredValue, inputValueMap);
  requiredValue = subValue(requiredValue, implicitValueMap);
  return requiredValue;
};
var LargestFirstInputSelector = class {
  // Change outputs will be computed, and an indicator will be
  // returned to indicate whether the value is fully fulfilled or not.
  // If the value is not fully fulfilled, it means that inputs were not enough
  // to cover the required value
  computeChangeOutputs = (remainingValue, changeAddress, constraints) => {
    let lovelaceAvailable = remainingValue.get("lovelace") || 0n;
    let valueFulfilled = true;
    const valueAssets = remainingValue.entries().filter(([_, quantity]) => quantity > 0n).map(([unit, quantity]) => ({
      unit,
      quantity: String(quantity)
    })).toArray();
    const changeOutputs = [];
    let currentBundle = [
      {
        unit: "lovelace",
        quantity: String(0)
      }
    ];
    if (constraints.tokenBundleSizeExceedsLimit(valueAssets)) {
      const tokenAssets = valueAssets.filter(
        (asset) => asset.unit !== "lovelace"
      );
      for (const tokenAsset of tokenAssets) {
        currentBundle.push(tokenAsset);
        if (constraints.tokenBundleSizeExceedsLimit(currentBundle)) {
          const currentToken = currentBundle.pop();
          const minUtxo = constraints.computeMinimumCoinQuantity({
            address: changeAddress,
            amount: currentBundle
          });
          currentBundle[0].quantity = minUtxo.toString();
          changeOutputs.push({
            address: changeAddress,
            amount: currentBundle
          });
          currentBundle = [
            {
              unit: "lovelace",
              quantity: String(0)
            },
            currentToken
          ];
          lovelaceAvailable -= minUtxo;
        }
      }
      if (currentBundle.length > 0) {
        const minUtxo = constraints.computeMinimumCoinQuantity({
          address: changeAddress,
          amount: currentBundle
        });
        currentBundle[0].quantity = minUtxo.toString();
        changeOutputs.push({
          address: changeAddress,
          amount: currentBundle
        });
        lovelaceAvailable -= minUtxo;
      }
      if (lovelaceAvailable > 0n) {
        const finalOutput = changeOutputs[changeOutputs.length - 1];
        const finalOutputLovelaces = finalOutput.amount.find(
          (asset) => asset.unit === "lovelace"
        );
        if (finalOutputLovelaces) {
          finalOutputLovelaces.quantity = String(
            BigInt(lovelaceAvailable) + BigInt(finalOutputLovelaces.quantity)
          );
        }
      } else {
        valueFulfilled = false;
      }
    } else {
      changeOutputs.push({
        address: changeAddress,
        amount: valueAssets
      });
      if (lovelaceAvailable < 0n) {
        valueFulfilled = false;
      }
    }
    return { changeOutputs, valueFulfilled };
  };
  expandUtxosUntilFeeCovered = async (availableUtxos, requiredValue, changeAddress, constraints) => {
    let remainingValue = subValue(/* @__PURE__ */ new Map(), requiredValue);
    let remainingUtxos = [...availableUtxos];
    const selectedUtxos = /* @__PURE__ */ new Set();
    while (remainingUtxos.length > 0) {
      const assetToSelect = remainingValue.entries().find(([_2, quantity]) => {
        return quantity < 0n;
      });
      if (!assetToSelect) {
        break;
      }
      const [unit, _] = assetToSelect;
      remainingUtxos.sort((a, b) => {
        const aValue = a.output.amount.find((asset) => asset.unit === unit)?.quantity || 0n;
        const bValue = b.output.amount.find((asset) => asset.unit === unit)?.quantity || 0n;
        return Number(aValue) - Number(bValue);
      });
      const selectedUtxo = remainingUtxos.pop();
      if (selectedUtxo) {
        selectedUtxos.add(selectedUtxo);
        const utxoValue = assetsToValue(selectedUtxo.output.amount);
        remainingValue = mergeValue(remainingValue, utxoValue);
      }
      if (valueAllPositive(remainingValue)) {
        break;
      }
    }
    if (remainingUtxos.length === 0 && !valueAllPositive(remainingValue)) {
      throw new Error("Not enough UTxOs to cover the required value.");
    }
    let computedCost = 0n;
    let computedChangeOutputs = [];
    let numberOfIterations = 3;
    for (let i = 0; i < numberOfIterations; i++) {
      const remainingValueWithCost = subValue(
        remainingValue,
        /* @__PURE__ */ new Map([["lovelace", computedCost]])
      );
      const { changeOutputs, valueFulfilled } = this.computeChangeOutputs(
        remainingValueWithCost,
        changeAddress,
        constraints
      );
      computedChangeOutputs = changeOutputs;
      if (!valueFulfilled) {
        if (remainingUtxos.length === 0) {
          throw new Error("Not enough UTxOs to cover the required value.");
        } else {
          const selectedUtxo = remainingUtxos.pop();
          if (selectedUtxo) {
            selectedUtxos.add(selectedUtxo);
            const utxoValue = assetsToValue(selectedUtxo.output.amount);
            remainingValue = mergeValue(remainingValue, utxoValue);
            numberOfIterations++;
          }
        }
      }
      if (i < numberOfIterations - 1) {
        computedCost = (await constraints.computeMinimumCost({
          newInputs: selectedUtxos,
          newOutputs: /* @__PURE__ */ new Set(),
          change: changeOutputs,
          fee: MAX_U64
        })).fee;
      }
    }
    return {
      finalSelectedUtxos: selectedUtxos,
      fee: computedCost,
      changeOutputs: computedChangeOutputs
    };
  };
  async select(preselectedUtxos, outputs, implicitValue, utxos, changeAddress, constraints) {
    const requiredValue = computeNetImplicitSelectionValues(
      preselectedUtxos,
      outputs,
      implicitValue
    );
    let utxosValue = /* @__PURE__ */ new Map();
    utxos.forEach((utxo) => {
      utxosValue = mergeValue(utxosValue, assetsToValue(utxo.output.amount));
    });
    const remainingValue = subValue(utxosValue, requiredValue);
    if (!Array.from(remainingValue.values()).every((v) => v >= 0n)) {
      throw new Error("Not enough UTxOs to cover the required value.");
    }
    const { finalSelectedUtxos, fee, changeOutputs } = await this.expandUtxosUntilFeeCovered(
      utxos,
      requiredValue,
      changeAddress,
      constraints
    );
    if (await constraints.maxSizeExceed({
      newInputs: finalSelectedUtxos,
      newOutputs: /* @__PURE__ */ new Set(),
      change: changeOutputs,
      fee
    })) {
      throw new Error("Transaction size exceeds the maximum allowed size.");
    }
    return {
      newInputs: finalSelectedUtxos,
      newOutputs: /* @__PURE__ */ new Set(),
      change: changeOutputs,
      fee
    };
  }
};

// src/mesh-tx-builder/tx-builder-core.ts
import JSONBig2 from "json-bigint";
import {
  cloneTxBuilderBody,
  DEFAULT_PROTOCOL_PARAMETERS,
  DEFAULT_REDEEMER_BUDGET,
  DREP_DEPOSIT,
  VOTING_PROPOSAL_DEPOSIT,
  emptyTxBuilderBody
} from "@meshsdk/common";
import { Address, CredentialType } from "@meshsdk/core-cst";

// src/utils/metadata.ts
import JSONBig from "json-bigint";
var metadataObjToMap = (metadata) => {
  if (typeof metadata === "bigint") {
    return metadata;
  } else if (typeof metadata === "string") {
    return metadata;
  } else if (typeof metadata === "number") {
    return metadata;
  } else if (metadata instanceof Uint8Array) {
    return metadata;
  } else if (Array.isArray(metadata)) {
    return metadata.map(metadataObjToMap);
  } else if (metadata && typeof metadata === "object") {
    const map = /* @__PURE__ */ new Map();
    if (metadata instanceof Map) {
      metadata.forEach((value, key) => {
        map.set(metadataObjToMap(key), metadataObjToMap(value));
      });
    } else {
      Object.entries(metadata).forEach(([key, value]) => {
        map.set(metadataObjToMap(key), metadataObjToMap(value));
      });
    }
    return map;
  } else {
    throw new Error("Metadata map conversion: Unsupported metadata type");
  }
};
var mergeContents = (a, b, currentDepth) => {
  if (currentDepth <= 0) {
    return b;
  }
  if (a instanceof Map && b instanceof Map) {
    b.forEach((value, key) => {
      if (a.has(key)) {
        a.set(
          key,
          mergeContents(a.get(key), value, currentDepth - 1)
        );
      } else {
        a.set(key, value);
      }
    });
    return a;
  } else if (Array.isArray(a) && Array.isArray(b)) {
    return [...a, ...b];
  }
  if ((typeof a === "number" || typeof a === "bigint" || typeof a === "string" || a instanceof Uint8Array) && (typeof b === "number" || typeof b === "bigint" || typeof b === "string" || b instanceof Uint8Array)) {
    if (typeof a === typeof b) {
      if (a === b) {
        return b;
      }
      if (a instanceof Uint8Array && b instanceof Uint8Array && areUint8ArraysEqual(a, b)) {
        return b;
      }
    }
    throw new Error(
      `Tx metadata merge error: cannot merge ${JSONBig.stringify(a)} with ${JSONBig.stringify(b)}`
    );
  }
  throw new Error(
    `Tx metadata merge error: cannot merge ${getMetadatumType(a)} type with ${getMetadatumType(b)} type`
  );
};
var getMetadatumType = (a) => {
  if (a instanceof Map) return "map";
  if (Array.isArray(a)) return "array";
  return "primitive";
};
var areUint8ArraysEqual = (a, b) => {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
};

// src/mesh-tx-builder/tx-builder-core.ts
var MeshTxBuilderCore = class {
  txEvaluationMultiplier = 1;
  txOutput;
  addingPlutusScriptInput = false;
  plutusSpendingScriptVersion;
  addingPlutusMint = false;
  plutusMintingScriptVersion;
  addingPlutusWithdrawal = false;
  plutusWithdrawalScriptVersion;
  addingPlutusVote = false;
  plutusVoteScriptVersion;
  manualFee;
  _protocolParams = DEFAULT_PROTOCOL_PARAMETERS;
  mintItem;
  txInQueueItem;
  withdrawalItem;
  voteItem;
  proposalItem;
  collateralQueueItem;
  refScriptTxInQueueItem;
  meshTxBuilderBody;
  constructor() {
    this.meshTxBuilderBody = emptyTxBuilderBody();
  }
  /**
   * Set the input for transaction
   * @param txHash The transaction hash of the input UTxO
   * @param txIndex The transaction index of the input UTxO
   * @param amount The asset amount of index of the input UTxO
   * @param address The address of the input UTxO
   * @param scriptSize The size of the ref script at this input (if there isn't one, explicitly put 0 as scriptSize for offline tx building)
   * @returns The MeshTxBuilder instance
   */
  txIn = (txHash, txIndex, amount, address, scriptSize) => {
    if (this.txInQueueItem) {
      this.queueInput();
    }
    if (!this.addingPlutusScriptInput) {
      this.txInQueueItem = {
        type: "PubKey",
        txIn: {
          txHash,
          txIndex,
          amount,
          address,
          scriptSize
        }
      };
    } else {
      this.txInQueueItem = {
        type: "Script",
        txIn: {
          txHash,
          txIndex,
          amount,
          address,
          scriptSize
        },
        scriptTxIn: {}
      };
    }
    this.addingPlutusScriptInput = false;
    return this;
  };
  /**
   * Set the script for transaction input
   * @param {string} scriptCbor The CborHex of the script
   * @param version Optional - The Plutus script version
   * @returns The MeshTxBuilder instance
   */
  txInScript = (scriptCbor) => {
    if (!this.txInQueueItem) throw Error("Undefined input");
    if (this.txInQueueItem.type === "PubKey") {
      this.txInQueueItem = {
        type: "SimpleScript",
        txIn: this.txInQueueItem.txIn,
        simpleScriptTxIn: {
          scriptSource: {
            type: "Provided",
            scriptCode: scriptCbor
          }
        }
      };
    }
    if (this.txInQueueItem.type === "Script") {
      this.txInQueueItem.scriptTxIn.scriptSource = {
        type: "Provided",
        script: {
          code: scriptCbor,
          version: this.plutusSpendingScriptVersion || "V2"
        }
      };
    }
    return this;
  };
  /**
   * Set the input datum for transaction input
   * @param datum The datum in Mesh Data type, JSON in raw constructor like format, or CBOR hex string
   * @param type The datum type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type
   * @returns The MeshTxBuilder instance
   */
  txInDatumValue = (datum, type = "Mesh") => {
    if (!this.txInQueueItem) throw Error("Undefined input");
    if (this.txInQueueItem.type === "PubKey")
      throw Error("Datum value attempted to be called a non script input");
    if (this.txInQueueItem.type === "SimpleScript")
      throw Error(
        "Datum value attempted to be called on a simple script input"
      );
    let content = datum;
    if (type === "JSON") {
      content = this.castRawDataToJsonString(datum);
    }
    if (type === "Mesh") {
      this.txInQueueItem.scriptTxIn.datumSource = {
        type: "Provided",
        data: {
          type,
          content: datum
        }
      };
      return this;
    }
    this.txInQueueItem.scriptTxIn.datumSource = {
      type: "Provided",
      data: {
        type,
        content
      }
    };
    return this;
  };
  /**
   * Tell the transaction builder that the input UTxO has inlined datum
   * @returns The MeshTxBuilder instance
   */
  txInInlineDatumPresent = () => {
    if (!this.txInQueueItem) throw Error("Undefined input");
    if (this.txInQueueItem.type === "PubKey")
      throw Error(
        "Inline datum present attempted to be called a non script input"
      );
    if (this.txInQueueItem.type === "SimpleScript")
      throw Error(
        "Inline datum present attempted to be called on a simple script input"
      );
    const { txHash, txIndex } = this.txInQueueItem.txIn;
    if (txHash && txIndex.toString()) {
      this.txInQueueItem.scriptTxIn.datumSource = {
        type: "Inline",
        txHash,
        txIndex
      };
    }
    return this;
  };
  /**
   * Native script - Set the reference input where it would also be spent in the transaction
   * @param txHash The transaction hash of the reference UTxO
   * @param txIndex The transaction index of the reference UTxO
   * @param spendingScriptHash The script hash of the spending script
   * @returns The MeshTxBuilder instance
   */
  simpleScriptTxInReference = (txHash, txIndex, spendingScriptHash, scriptSize) => {
    if (!this.txInQueueItem) throw Error("Undefined input");
    if (this.txInQueueItem.type === "Script") {
      throw Error(
        "simpleScriptTxInReference called on a plutus script, use spendingTxInReference instead"
      );
    }
    if (this.txInQueueItem.type === "SimpleScript") {
      throw Error(
        "simpleScriptTxInReference called on a native script input that already has a script defined"
      );
    }
    if (this.txInQueueItem.type === "PubKey") {
      this.txInQueueItem = {
        type: "SimpleScript",
        txIn: this.txInQueueItem.txIn,
        simpleScriptTxIn: {
          scriptSource: {
            type: "Inline",
            txHash,
            txIndex,
            simpleScriptHash: spendingScriptHash,
            scriptSize
          }
        }
      };
    }
    return this;
  };
  /**
   * Set the redeemer for the reference input to be spent in same transaction
   * @param redeemer The redeemer in Mesh Data type, JSON in raw constructor like format, or CBOR hex string
   * @param type The redeemer data type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type
   * @param exUnits The execution units budget for the redeemer
   * @returns The MeshTxBuilder instance
   */
  txInRedeemerValue = (redeemer, type = "Mesh", exUnits = { ...DEFAULT_REDEEMER_BUDGET }) => {
    if (!this.txInQueueItem) throw Error("Undefined input");
    if (this.txInQueueItem.type === "PubKey")
      throw Error(
        "Spending tx in reference redeemer attempted to be called a non script input"
      );
    if (this.txInQueueItem.type === "SimpleScript")
      throw Error(
        "Spending tx in reference redeemer attempted to be called on a simple script input"
      );
    this.txInQueueItem.scriptTxIn.redeemer = this.castBuilderDataToRedeemer(
      redeemer,
      type,
      exUnits
    );
    return this;
  };
  /**
   * Set the output for transaction
   * @param {string} address The recipient of the output
   * @param {Asset[]} amount The amount of other native assets attached with UTxO
   * @returns The MeshTxBuilder instance
   */
  txOut = (address, amount) => {
    if (this.txOutput) {
      this.meshTxBuilderBody.outputs.push(this.txOutput);
      this.txOutput = void 0;
    }
    this.txOutput = {
      address,
      amount
    };
    return this;
  };
  /**
   * Set the output datum hash for transaction
   * @param datum The datum in Mesh Data type, JSON in raw constructor like format, or CBOR hex string
   * @param type The datum type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type
   * @returns The MeshTxBuilder instance
   */
  txOutDatumHashValue = (datum, type = "Mesh") => {
    let content = datum;
    if (this.txOutput) {
      if (type === "Mesh") {
        this.txOutput.datum = {
          type: "Hash",
          data: {
            type,
            content
          }
        };
        return this;
      }
      if (type === "JSON") {
        content = this.castRawDataToJsonString(datum);
      }
      this.txOutput.datum = {
        type: "Hash",
        data: {
          type,
          content
        }
      };
    }
    return this;
  };
  /**
   * Set the output inline datum for transaction
   * @param datum The datum in Mesh Data type, JSON in raw constructor like format, or CBOR hex string
   * @param type The datum type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type
   * @returns The MeshTxBuilder instance
   */
  txOutInlineDatumValue = (datum, type = "Mesh") => {
    let content = datum;
    if (this.txOutput) {
      if (type === "Mesh") {
        this.txOutput.datum = {
          type: "Inline",
          data: {
            type,
            content
          }
        };
        return this;
      }
      if (type === "JSON") {
        content = this.castRawDataToJsonString(datum);
      }
      this.txOutput.datum = {
        type: "Inline",
        data: {
          type,
          content
        }
      };
    }
    return this;
  };
  /**
   * Set the output embed datum for transaction
   * @param datum The datum in Mesh Data type, JSON in raw constructor like format, or CBOR hex string
   * @param type The datum type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type
   * @returns The MeshTxBuilder instance
   */
  txOutDatumEmbedValue = (datum, type = "Mesh") => {
    let content = datum;
    if (this.txOutput) {
      if (type === "Mesh") {
        this.txOutput.datum = {
          type: "Embedded",
          data: {
            type,
            content
          }
        };
        return this;
      }
      if (type === "JSON") {
        content = this.castRawDataToJsonString(datum);
      }
      this.txOutput.datum = {
        type: "Embedded",
        data: {
          type,
          content
        }
      };
    }
    return this;
  };
  /**
   * Set the reference script to be attached with the output
   * @param scriptCbor The CBOR hex of the script to be attached to UTxO as reference script
   * @param version Optional - The Plutus script version. Default to be V3 (Plutus V3)
   * @returns The MeshTxBuilder instance
   */
  txOutReferenceScript = (scriptCbor, version = "V3") => {
    if (this.txOutput) {
      this.txOutput.referenceScript = { code: scriptCbor, version };
    }
    return this;
  };
  /**
   * Set the reference script to be attached with the output
   * @param languageVersion The Plutus script version
   * @returns The MeshTxBuilder instance
   */
  spendingPlutusScript = (languageVersion) => {
    this.addingPlutusScriptInput = true;
    this.plutusSpendingScriptVersion = languageVersion;
    return this;
  };
  /**
   * Set the instruction that it is currently using V1 Plutus spending scripts
   * @returns The MeshTxBuilder instance
   */
  spendingPlutusScriptV1 = () => {
    this.addingPlutusScriptInput = true;
    this.plutusSpendingScriptVersion = "V1";
    return this;
  };
  /**
   * Set the instruction that it is currently using V2 Plutus spending scripts
   * @returns The MeshTxBuilder instance
   */
  spendingPlutusScriptV2 = () => {
    this.addingPlutusScriptInput = true;
    this.plutusSpendingScriptVersion = "V2";
    return this;
  };
  /**
   * Set the instruction that it is currently using V3 Plutus spending scripts
   * @returns The MeshTxBuilder instance
   */
  spendingPlutusScriptV3 = () => {
    this.addingPlutusScriptInput = true;
    this.plutusSpendingScriptVersion = "V3";
    return this;
  };
  /**
   * Set the reference input where it would also be spent in the transaction
   * @param txHash The transaction hash of the reference UTxO
   * @param txIndex The transaction index of the reference UTxO
   * @param scriptSize The script size in bytes of the spending script (can be obtained by script hex length / 2)
   * @param scriptHash The script hash of the spending script
   * @returns The MeshTxBuilder instance
   */
  spendingTxInReference = (txHash, txIndex, scriptSize, scriptHash) => {
    if (!this.txInQueueItem) throw Error("Undefined input");
    if (this.txInQueueItem.type === "PubKey")
      throw Error(
        "Spending tx in reference attempted to be called a non script input"
      );
    if (this.txInQueueItem.type === "SimpleScript")
      throw Error(
        "Spending tx in reference attempted to be called on a simple script input"
      );
    this.txInQueueItem.scriptTxIn.scriptSource = {
      type: "Inline",
      txHash,
      txIndex,
      scriptHash,
      version: this.plutusSpendingScriptVersion || "V2",
      scriptSize
    };
    return this;
  };
  /**
   * [Alias of txInInlineDatumPresent] Set the instruction that the reference input has inline datum
   * @returns The MeshTxBuilder instance
   */
  // Unsure how this is different from the --tx-in-inline-datum-present flag
  // It seems to just be different based on if the script is a reference input
  spendingReferenceTxInInlineDatumPresent = () => {
    this.txInInlineDatumPresent();
    return this;
  };
  /**
   * [Alias of txInRedeemerValue] Set the redeemer for the reference input to be spent in same transaction
   * @param redeemer The redeemer in Mesh Data type, JSON in raw constructor like format, or CBOR hex string
   * @param type The redeemer data type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type
   * @param exUnits The execution units budget for the redeemer
   * @returns The MeshTxBuilder instance
   */
  spendingReferenceTxInRedeemerValue = (redeemer, type = "Mesh", exUnits = { ...DEFAULT_REDEEMER_BUDGET }) => {
    this.txInRedeemerValue(redeemer, type, exUnits);
    return this;
  };
  /**
   * Specify a read only reference input. This reference input is not witnessing anything it is simply provided in the plutus script context.
   * @param txHash The transaction hash of the reference UTxO
   * @param txIndex The transaction index of the reference UTxO
   * @returns The MeshTxBuilder instance
   */
  readOnlyTxInReference = (txHash, txIndex, scriptSize) => {
    this.meshTxBuilderBody.referenceInputs.push({
      txHash,
      txIndex,
      scriptSize
    });
    return this;
  };
  /**
   * Set the minting script for the current mint
   * @param languageVersion The Plutus script version
   * @returns The MeshTxBuilder instance
   */
  mintPlutusScript = (languageVersion) => {
    this.addingPlutusMint = true;
    this.plutusMintingScriptVersion = languageVersion;
    return this;
  };
  /**
   * Set the instruction that it is currently using V1 Plutus minting scripts
   * @returns The MeshTxBuilder instance
   */
  mintPlutusScriptV1 = () => {
    this.addingPlutusMint = true;
    this.plutusMintingScriptVersion = "V1";
    return this;
  };
  /**
   * Set the instruction that it is currently using V2 Plutus minting scripts
   * @returns The MeshTxBuilder instance
   */
  mintPlutusScriptV2 = () => {
    this.addingPlutusMint = true;
    this.plutusMintingScriptVersion = "V2";
    return this;
  };
  /**
   * Set the instruction that it is currently using V3 Plutus minting scripts
   * @returns The MeshTxBuilder instance
   */
  mintPlutusScriptV3 = () => {
    this.addingPlutusMint = true;
    this.plutusMintingScriptVersion = "V3";
    return this;
  };
  /**
   * Set the minting value of transaction
   * @param quantity The quantity of asset to be minted
   * @param policy The policy id of the asset to be minted
   * @param name The hex of token name of the asset to be minted
   * @returns The MeshTxBuilder instance
   */
  mint = (quantity, policy, name) => {
    if (this.mintItem) {
      this.queueMint();
    }
    this.mintItem = {
      type: this.addingPlutusMint ? "Plutus" : "Native",
      policyId: policy,
      assetName: name,
      amount: quantity
    };
    this.addingPlutusMint = false;
    return this;
  };
  /**
   * Set the minting script of current mint
   * @param scriptCBOR The CBOR hex of the minting policy script
   * @param version Optional - The Plutus script version
   * @returns The MeshTxBuilder instance
   */
  mintingScript = (scriptCBOR) => {
    if (!this.mintItem) throw Error("Undefined mint");
    if (!this.mintItem.type) throw Error("Mint information missing");
    if (this.mintItem.type === "Native") {
      this.mintItem.scriptSource = {
        type: "Provided",
        scriptCode: scriptCBOR
      };
    }
    if (this.mintItem.type === "Plutus") {
      this.mintItem.scriptSource = {
        type: "Provided",
        script: {
          code: scriptCBOR,
          version: this.plutusMintingScriptVersion || "V2"
        }
      };
    }
    return this;
  };
  /**
   * Use reference script for minting
   * @param txHash The transaction hash of the UTxO
   * @param txIndex The transaction index of the UTxO
   * @param scriptSize The script size in bytes of the script (can be obtained by script hex length / 2)
   * @param scriptHash The script hash of the script
   * @returns The MeshTxBuilder instance
   */
  mintTxInReference = (txHash, txIndex, scriptSize, scriptHash) => {
    if (!this.mintItem) throw Error("Undefined mint");
    if (!this.mintItem.type) throw Error("Mint information missing");
    if (this.mintItem.type == "Native") {
      throw Error(
        "Mint tx in reference can only be used on plutus script tokens"
      );
    }
    if (!this.mintItem.policyId)
      throw Error("PolicyId information missing from mint asset");
    this.mintItem.scriptSource = {
      type: "Inline",
      txHash,
      txIndex,
      version: this.plutusMintingScriptVersion,
      scriptSize,
      scriptHash
    };
    return this;
  };
  /**
   * Set the redeemer for minting
   * @param redeemer The redeemer in Mesh Data type, JSON in raw constructor like format, or CBOR hex string
   * @param type The redeemer data type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type
   * @param exUnits The execution units budget for the redeemer
   * @returns The MeshTxBuilder instance
   */
  mintReferenceTxInRedeemerValue = (redeemer, type = "Mesh", exUnits = { ...DEFAULT_REDEEMER_BUDGET }) => {
    if (!this.mintItem) throw Error("Undefined mint");
    if (this.mintItem.type == "Native") {
      throw Error(
        "Mint tx in reference can only be used on plutus script tokens"
      );
    } else if (this.mintItem.type == "Plutus") {
      if (!this.mintItem.policyId)
        throw Error("PolicyId information missing from mint asset");
    }
    this.mintItem.redeemer = this.castBuilderDataToRedeemer(
      redeemer,
      type,
      exUnits
    );
    return this;
  };
  /**
   * Set the redeemer for the reference input to be spent in same transaction
   * @param redeemer The redeemer in Mesh Data type, JSON in raw constructor like format, or CBOR hex string
   * @param type The redeemer data type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type
   * @param exUnits The execution units budget for the redeemer
   * @returns The MeshTxBuilder instance
   */
  mintRedeemerValue = (redeemer, type = "Mesh", exUnits = { ...DEFAULT_REDEEMER_BUDGET }) => {
    this.mintReferenceTxInRedeemerValue(redeemer, type, exUnits);
    return this;
  };
  /**
   * Set the required signer of the transaction
   * @param pubKeyHash The PubKeyHash of the required signer
   * @returns The MeshTxBuilder instance
   */
  requiredSignerHash = (pubKeyHash) => {
    this.meshTxBuilderBody.requiredSignatures.push(pubKeyHash);
    return this;
  };
  /**
   * Set the collateral UTxO for the transaction
   * @param txHash The transaction hash of the collateral UTxO
   * @param txIndex The transaction index of the collateral UTxO
   * @param amount The asset amount of index of the collateral UTxO
   * @param address The address of the collateral UTxO
   * @returns The MeshTxBuilder instance
   */
  txInCollateral = (txHash, txIndex, amount, address) => {
    if (this.collateralQueueItem) {
      this.meshTxBuilderBody.collaterals.push(this.collateralQueueItem);
    }
    this.collateralQueueItem = {
      type: "PubKey",
      txIn: {
        txHash,
        txIndex,
        amount,
        address
      }
    };
    return this;
  };
  /**
   * Set the instruction that it is currently using V1 Plutus withdrawal scripts
   * @param languageVersion The Plutus script version
   * @returns The MeshTxBuilder instance
   */
  withdrawalPlutusScript = (languageVersion) => {
    this.addingPlutusWithdrawal = true;
    this.plutusWithdrawalScriptVersion = languageVersion;
    return this;
  };
  /**
   * Set the instruction that it is currently using a Plutus withdrawal scripts
   * @returns The MeshTxBuilder instance
   */
  withdrawalPlutusScriptV1 = () => {
    this.addingPlutusWithdrawal = true;
    this.plutusWithdrawalScriptVersion = "V1";
    return this;
  };
  /**
   * Set the instruction that it is currently using V2 Plutus withdrawal scripts
   * @returns The MeshTxBuilder instance
   */
  withdrawalPlutusScriptV2 = () => {
    this.addingPlutusWithdrawal = true;
    this.plutusWithdrawalScriptVersion = "V2";
    return this;
  };
  /**
   * Set the instruction that it is currently using V3 Plutus withdrawal scripts
   * @returns The MeshTxBuilder instance
   */
  withdrawalPlutusScriptV3 = () => {
    this.addingPlutusWithdrawal = true;
    this.plutusWithdrawalScriptVersion = "V3";
    return this;
  };
  /**
   * Withdraw stake rewards in the MeshTxBuilder instance
   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)
   * @param coin The amount of lovelaces in the withdrawal
   * @returns The MeshTxBuilder instance
   */
  withdrawal = (rewardAddress, coin) => {
    if (this.withdrawalItem) {
      this.queueWithdrawal();
    }
    if (this.addingPlutusWithdrawal) {
      const withdrawal2 = {
        type: "ScriptWithdrawal",
        address: rewardAddress,
        coin
      };
      this.withdrawalItem = withdrawal2;
      this.addingPlutusWithdrawal = false;
      return this;
    }
    const withdrawal = {
      type: "PubKeyWithdrawal",
      address: rewardAddress,
      coin
    };
    this.withdrawalItem = withdrawal;
    return this;
  };
  /**
   * Add a withdrawal script to the MeshTxBuilder instance
   * @param scriptCbor The script in CBOR format
   * @returns The MeshTxBuilder instance
   */
  withdrawalScript = (scriptCbor) => {
    if (!this.withdrawalItem)
      throw Error("withdrawalScript: Undefined withdrawal");
    if (this.withdrawalItem.type === "PubKeyWithdrawal") {
      this.withdrawalItem = {
        type: "SimpleScriptWithdrawal",
        address: this.withdrawalItem.address,
        coin: this.withdrawalItem.coin,
        scriptSource: {
          type: "Provided",
          scriptCode: scriptCbor
        }
      };
    } else {
      this.withdrawalItem.scriptSource = {
        type: "Provided",
        script: {
          code: scriptCbor,
          version: this.plutusWithdrawalScriptVersion || "V2"
        }
      };
    }
    return this;
  };
  /**
   * Add a withdrawal reference to the MeshTxBuilder instance
   * @param txHash The transaction hash of reference UTxO
   * @param txIndex The transaction index of reference UTxO
   * @param scriptSize The script size in bytes of the withdrawal script (can be obtained by script hex length / 2)
   * @param scriptHash The script hash of the withdrawal script
   * @returns The MeshTxBuilder instance
   */
  withdrawalTxInReference = (txHash, txIndex, scriptSize, scriptHash) => {
    if (!this.withdrawalItem)
      throw Error("withdrawalTxInReference: Undefined withdrawal");
    if (this.withdrawalItem.type === "PubKeyWithdrawal")
      throw Error(
        "withdrawalTxInReference: Adding script reference to pub key withdrawal"
      );
    this.withdrawalItem.scriptSource = {
      type: "Inline",
      txHash,
      txIndex,
      scriptHash,
      version: this.plutusWithdrawalScriptVersion || "V2",
      scriptSize
    };
    return this;
  };
  /**
   * Set the transaction withdrawal redeemer value in the MeshTxBuilder instance
   * @param redeemer The redeemer in Mesh Data type, JSON in raw constructor like format, or CBOR hex string
   * @param type The redeemer data type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type
   * @param exUnits The execution units budget for the redeemer
   * @returns The MeshTxBuilder instance
   */
  withdrawalRedeemerValue = (redeemer, type = "Mesh", exUnits = { ...DEFAULT_REDEEMER_BUDGET }) => {
    if (!this.withdrawalItem)
      throw Error("withdrawalRedeemerValue: Undefined withdrawal");
    if (!(this.withdrawalItem.type === "ScriptWithdrawal"))
      throw Error(
        "withdrawalRedeemerValue: Adding redeemer to non plutus withdrawal"
      );
    this.withdrawalItem.redeemer = this.castBuilderDataToRedeemer(
      redeemer,
      type,
      exUnits
    );
    return this;
  };
  /**
   * Set the instruction that it is currently using a Plutus voting scripts
   * @param languageVersion The Plutus script version
   * @returns The MeshTxBuilder instance
   */
  votePlutusScript = (languageVersion) => {
    this.addingPlutusVote = true;
    this.plutusVoteScriptVersion = languageVersion;
    return this;
  };
  /**
   * Set the instruction that it is currently using V1 Plutus voting scripts
   * @returns The MeshTxBuilder instance
   */
  votePlutusScriptV1 = () => {
    this.addingPlutusVote = true;
    this.plutusVoteScriptVersion = "V1";
    return this;
  };
  /**
   * Set the instruction that it is currently using V2 Plutus voting scripts
   * @returns The MeshTxBuilder instance
   */
  votePlutusScriptV2 = () => {
    this.addingPlutusVote = true;
    this.plutusVoteScriptVersion = "V2";
    return this;
  };
  /**
   * Set the instruction that it is currently using V3 Plutus voting scripts
   * @returns The MeshTxBuilder instance
   */
  votePlutusScriptV3 = () => {
    this.addingPlutusVote = true;
    this.plutusVoteScriptVersion = "V3";
    return this;
  };
  /**
   * Add a vote in the MeshTxBuilder instance
   * @param voter The voter, can be a ConstitutionalCommitee, a DRep or a StakePool
   * @param govActionId - The transaction hash and transaction id of the governance action
   * @param votingProcedure - The voting kind (Yes, No, Abstain) with an optional anchor
   * @returns The MeshTxBuilder instance
   */
  vote = (voter, govActionId, votingProcedure) => {
    if (this.voteItem) {
      this.queueVote();
    }
    if (this.addingPlutusVote) {
      const vote = {
        type: "ScriptVote",
        vote: {
          voter,
          govActionId,
          votingProcedure
        }
      };
      this.voteItem = vote;
      this.addingPlutusVote = false;
    } else {
      const vote = {
        type: "BasicVote",
        vote: {
          voter,
          govActionId,
          votingProcedure
        }
      };
      this.voteItem = vote;
    }
    return this;
  };
  /**
   * Add a voting script to the MeshTxBuilder instance
   * @param scriptCbor The script in CBOR format
   * @returns The MeshTxBuilder instance
   */
  voteScript = (scriptCbor) => {
    if (!this.voteItem) throw Error("voteScript: Undefined vote");
    if (this.voteItem.type === "BasicVote") {
      this.voteItem = {
        type: "SimpleScriptVote",
        vote: this.voteItem.vote,
        simpleScriptSource: {
          type: "Provided",
          scriptCode: scriptCbor
        }
      };
    } else if (this.voteItem.type === "ScriptVote") {
      this.voteItem.scriptSource = {
        type: "Provided",
        script: {
          code: scriptCbor,
          version: this.plutusVoteScriptVersion || "V2"
        }
      };
    } else if (this.voteItem.type === "SimpleScriptVote") {
      throw Error("voteScript: Script is already defined for current vote");
    }
    return this;
  };
  /**
   * Add a vote reference to the MeshTxBuilder instance
   * @param txHash The transaction hash of reference UTxO
   * @param txIndex The transaction index of reference UTxO
   * @param scriptSize The script size in bytes of the vote script (can be obtained by script hex length / 2)
   * @param scriptHash The script hash of the vote script
   * @returns The MeshTxBuilder instance
   */
  voteTxInReference = (txHash, txIndex, scriptSize, scriptHash) => {
    if (!this.voteItem) throw Error("voteTxInReference: Undefined vote");
    if (this.voteItem.type === "BasicVote")
      throw Error("voteTxInReference: Adding script reference to a basic vote");
    if (this.voteItem.type === "ScriptVote") {
      this.voteItem.scriptSource = {
        type: "Inline",
        txHash,
        txIndex,
        scriptHash,
        version: this.plutusWithdrawalScriptVersion || "V2",
        scriptSize
      };
    } else if (this.voteItem.type === "SimpleScriptVote") {
      this.voteItem.simpleScriptSource = {
        type: "Inline",
        txHash,
        txIndex,
        scriptSize,
        simpleScriptHash: scriptHash
      };
    }
    return this;
  };
  /**
   * Set the transaction vote redeemer value in the MeshTxBuilder instance
   * @param redeemer The redeemer in Mesh Data type, JSON in raw constructor like format, or CBOR hex string
   * @param type The redeemer data type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string
   * @param exUnits The execution units budget for the redeemer
   * @returns The MeshTxBuilder instance
   */
  voteRedeemerValue = (redeemer, type = "Mesh", exUnits = { ...DEFAULT_REDEEMER_BUDGET }) => {
    if (!this.voteItem) throw Error("voteRedeemerValue: Undefined vote");
    if (!(this.voteItem.type === "ScriptVote"))
      throw Error("voteRedeemerValue: Adding redeemer to non plutus vote");
    this.voteItem.redeemer = this.castBuilderDataToRedeemer(
      redeemer,
      type,
      exUnits
    );
    return this;
  };
  /**
   * Creates a governance proposal and adds it to the transaction
   * @param governanceAction The governance action to propose
   * @param anchor The anchor containing proposal information
   * @param rewardAccount The reward address for the proposal return
   * @param deposit The deposit amount for the proposal
   * @returns The MeshTxBuilder instance
   */
  proposal = (governanceAction, anchor, rewardAccount, deposit = VOTING_PROPOSAL_DEPOSIT) => {
    if (this.proposalItem) {
      this.queueProposal();
    }
    this.proposalItem = {
      type: "BasicProposal",
      proposalType: {
        governanceAction,
        anchor,
        rewardAccount,
        deposit
      }
    };
    return this;
  };
  /**
   * Adds a plutus script witness to the proposal
   * @param scriptCbor The CborHex of the script
   * @param version The plutus version of the script
   */
  proposalScript = (scriptCbor, version) => {
    const currentProposal = this.proposalItem;
    if (!currentProposal) {
      throw Error(
        "Proposal script attempted to be defined, but no proposal was found"
      );
    }
    this.proposalItem = {
      type: "ScriptProposal",
      proposalType: currentProposal.proposalType,
      scriptSource: {
        type: "Provided",
        script: {
          code: scriptCbor,
          version
        }
      }
    };
    return this;
  };
  /**
   * Adds a reference to a plutus script for the proposal
   * @param txHash The transaction hash of the reference UTxO
   * @param txIndex The transaction index of the reference UTxO
   * @param scriptSize The size of the plutus script in bytes referenced
   * @param scriptHash The script hash of the script
   * @param version The plutus version of the script
   */
  proposalTxInReference = (txHash, txIndex, scriptSize, scriptHash, version) => {
    const currentProposal = this.proposalItem;
    if (!currentProposal) {
      throw Error(
        "Proposal script reference attempted to be defined, but no proposal was found"
      );
    }
    this.proposalItem = {
      type: "ScriptProposal",
      proposalType: currentProposal.proposalType,
      scriptSource: {
        type: "Inline",
        txHash,
        txIndex,
        scriptHash,
        scriptSize,
        version
      },
      redeemer: currentProposal.type === "ScriptProposal" ? currentProposal.redeemer : void 0
    };
    return this;
  };
  /**
   * Adds redeemer data to a plutus script proposal
   * @param redeemer The redeemer data
   * @param type The data type (Mesh or CBOR)
   * @param exUnits The execution units budget
   * @returns The MeshTxBuilder instance
   */
  proposalRedeemerValue = (redeemer, type = "Mesh", exUnits = { ...DEFAULT_REDEEMER_BUDGET }) => {
    if (!this.proposalItem) throw Error("proposalRedeemerValue: Undefined proposal");
    if (!(this.proposalItem.type === "ScriptProposal"))
      throw Error("proposalRedeemerValue: Adding redeemer to non plutus proposal");
    this.proposalItem.redeemer = this.castBuilderDataToRedeemer(
      redeemer,
      type,
      exUnits
    );
    return this;
  };
  /**
   * Creates a pool registration certificate, and adds it to the transaction
   * @param poolParams Parameters for pool registration
   * @returns The MeshTxBuilder instance
   */
  registerPoolCertificate = (poolParams) => {
    this.meshTxBuilderBody.certificates.push({
      type: "BasicCertificate",
      certType: {
        type: "RegisterPool",
        poolParams
      }
    });
    return this;
  };
  /**
   * Creates a stake registration certificate, and adds it to the transaction
   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)
   * @returns The MeshTxBuilder instance
   */
  registerStakeCertificate = (rewardAddress) => {
    this.meshTxBuilderBody.certificates.push({
      type: "BasicCertificate",
      certType: {
        type: "RegisterStake",
        stakeKeyAddress: rewardAddress
      }
    });
    return this;
  };
  /**
   * Creates a stake delegation certificate, and adds it to the transaction
   * This will delegate stake from the corresponding stake address to the pool
   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)
   * @param poolId poolId can be in either bech32 or hex form
   * @returns The MeshTxBuilder instance
   */
  delegateStakeCertificate = (rewardAddress, poolId) => {
    this.meshTxBuilderBody.certificates.push({
      type: "BasicCertificate",
      certType: {
        type: "DelegateStake",
        stakeKeyAddress: rewardAddress,
        poolId
      }
    });
    return this;
  };
  /**
   * Creates a stake deregister certificate, and adds it to the transaction
   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)
   * @returns The MeshTxBuilder instance
   */
  deregisterStakeCertificate = (rewardAddress) => {
    this.meshTxBuilderBody.certificates.push({
      type: "BasicCertificate",
      certType: {
        type: "DeregisterStake",
        stakeKeyAddress: rewardAddress
      }
    });
    return this;
  };
  /**
   * Creates a pool retire certificate, and adds it to the transaction
   * @param poolId poolId can be in either bech32 or hex form
   * @param epoch The intended epoch to retire the pool
   * @returns The MeshTxBuilder instance
   */
  retirePoolCertificate = (poolId, epoch) => {
    this.meshTxBuilderBody.certificates.push({
      type: "BasicCertificate",
      certType: {
        type: "RetirePool",
        poolId,
        epoch
      }
    });
    return this;
  };
  /**
   * Registers DRep certificate, and adds it to the transaction
   * @param drepId The bech32 drep id (i.e. starts with `drep1xxxxx`)
   * @param anchor The DRep anchor, consists of a URL and a hash of the doc
   * @param coin DRep registration deposit
   * @returns The MeshTxBuilder instance
   */
  drepRegistrationCertificate = (drepId, anchor, coin = DREP_DEPOSIT) => {
    this.meshTxBuilderBody.certificates.push({
      type: "BasicCertificate",
      certType: {
        type: "DRepRegistration",
        drepId,
        coin: Number(coin),
        anchor
      }
    });
    return this;
  };
  /**
   * Dregister DRep certificate, and adds it to the transaction
   * @param drepId The bech32 drep id (i.e. starts with `drep1xxxxx`)
   * @param coin DRep registration deposit
   * @returns The MeshTxBuilder instance
   */
  drepDeregistrationCertificate = (drepId, coin = DREP_DEPOSIT) => {
    this.meshTxBuilderBody.certificates.push({
      type: "BasicCertificate",
      certType: {
        type: "DRepDeregistration",
        drepId,
        coin: Number(coin)
      }
    });
    return this;
  };
  /**
   * Update DRep certificate, and adds it to the transaction
   * @param drepId The bech32 drep id (i.e. starts with `drep1xxxxx`)
   * @param anchor The DRep anchor, consists of a URL and a hash of the doc
   */
  drepUpdateCertificate = (drepId, anchor) => {
    this.meshTxBuilderBody.certificates.push({
      type: "BasicCertificate",
      certType: {
        type: "DRepUpdate",
        drepId,
        anchor
      }
    });
    return this;
  };
  /**
   * Dregister DRep certificate, and adds it to the transaction
   * @param drepId The bech32 drep id (i.e. starts with `drep1xxxxx`)
   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)
   * @returns The MeshTxBuilder instance
   */
  voteDelegationCertificate = (drep, rewardAddress) => {
    this.meshTxBuilderBody.certificates.push({
      type: "BasicCertificate",
      certType: {
        type: "VoteDelegation",
        drep,
        stakeKeyAddress: rewardAddress
      }
    });
    return this;
  };
  /**
   * Adds a script witness to the certificate
   * @param scriptCbor The CborHex of the script
   * @param version Optional - The plutus version of the script, null version implies Native Script
   */
  certificateScript = (scriptCbor, version) => {
    const currentCert = this.meshTxBuilderBody.certificates.pop();
    if (!currentCert) {
      throw Error(
        "Certificate script attempted to be defined, but no certificate was found"
      );
    }
    if (!version) {
      this.meshTxBuilderBody.certificates.push({
        type: "SimpleScriptCertificate",
        certType: currentCert.certType,
        simpleScriptSource: {
          type: "Provided",
          scriptCode: scriptCbor
        }
      });
    } else {
      this.meshTxBuilderBody.certificates.push({
        type: "ScriptCertificate",
        certType: currentCert.certType,
        scriptSource: {
          type: "Provided",
          script: {
            code: scriptCbor,
            version
          }
        },
        redeemer: currentCert.type === "ScriptCertificate" ? currentCert.redeemer : void 0
      });
    }
    return this;
  };
  /**
   * Adds a script witness to the certificate
   * @param txHash The transaction hash of the reference UTxO
   * @param txIndex The transaction index of the reference UTxO
   * @param scriptSize The size of the plutus script in bytes referenced (can be obtained by script hex length / 2)
   * @param scriptHash The script hash of the spending script
   * @param version The plutus version of the script, null version implies Native Script
   */
  certificateTxInReference = (txHash, txIndex, scriptSize, scriptHash, version) => {
    const currentCert = this.meshTxBuilderBody.certificates.pop();
    if (!currentCert) {
      throw Error(
        "Certificate script reference attempted to be defined, but no certificate was found"
      );
    }
    if (!version) {
      this.meshTxBuilderBody.certificates.push({
        type: "SimpleScriptCertificate",
        certType: currentCert.certType,
        simpleScriptSource: {
          type: "Inline",
          txHash,
          txIndex,
          simpleScriptHash: scriptHash
        }
      });
    } else {
      this.meshTxBuilderBody.certificates.push({
        type: "ScriptCertificate",
        certType: currentCert.certType,
        scriptSource: {
          type: "Inline",
          txHash,
          txIndex,
          scriptHash,
          scriptSize,
          version
        },
        redeemer: currentCert.type === "ScriptCertificate" ? currentCert.redeemer : void 0
      });
    }
    return this;
  };
  certificateRedeemerValue = (redeemer, type = "Mesh", exUnits = { ...DEFAULT_REDEEMER_BUDGET }) => {
    const currentCert = this.meshTxBuilderBody.certificates.pop();
    if (!currentCert) {
      throw Error(
        "Certificate redeemer value attempted to be defined, but no certificate was found"
      );
    }
    if (currentCert.type === "ScriptCertificate") {
      currentCert.redeemer = this.castBuilderDataToRedeemer(
        redeemer,
        type,
        exUnits
      );
    } else {
      throw Error(
        "Redeemer value attempted to be defined, but certificate has no script defined, or no script version was defined"
      );
    }
    this.meshTxBuilderBody.certificates.push(currentCert);
    return this;
  };
  /**
   * Configure the address to accept change UTxO
   * @param addr The address to accept change UTxO
   * @returns The MeshTxBuilder instance
   */
  changeAddress = (addr) => {
    this.meshTxBuilderBody.changeAddress = addr;
    return this;
  };
  /**
   * Set the transaction valid interval to be valid only after the slot
   * @param slot The transaction is valid only after this slot
   * @returns The MeshTxBuilder instance
   */
  invalidBefore = (slot) => {
    this.meshTxBuilderBody.validityRange.invalidBefore = slot;
    return this;
  };
  /**
   * Set the transaction valid interval to be valid only before the slot
   * @param slot The transaction is valid only before this slot
   * @returns The MeshTxBuilder instance
   */
  invalidHereafter = (slot) => {
    this.meshTxBuilderBody.validityRange.invalidHereafter = slot;
    return this;
  };
  /**
   * Add metadata to the transaction
   * @param label The label of the metadata, preferably number
   * @param metadata The metadata in any format
   * @returns The MeshTxBuilder instance
   */
  metadataValue = (label, metadata) => {
    label = BigInt(label);
    if (typeof metadata === "object" && !(metadata instanceof Map)) {
      this.meshTxBuilderBody.metadata.set(label, metadataObjToMap(metadata));
    } else {
      this.meshTxBuilderBody.metadata.set(label, metadata);
    }
    return this;
  };
  /**
   * Add metadata script to the transaction
   * @param scriptCbor The script in CBOR format
   * @param scriptType The type of the script, either "Native", "PlutusV1", "PlutusV2" or "PlutusV3"
   * @returns The MeshTxBuilder instance
   */
  metadataScript = (scriptCbor, scriptType) => {
    this.meshTxBuilderBody.scriptMetadata.push({
      scriptCbor,
      scriptType
    });
    return this;
  };
  /**
   * Sign the transaction with the private key
   * @param skeyHex The private key in cborHex (with or without 5820 prefix, i.e. the format when generated from cardano-cli)
   * @returns
   */
  signingKey = (skeyHex) => {
    this.meshTxBuilderBody.signingKey.push(skeyHex);
    return this;
  };
  /**
   * Selects utxos to fill output value and puts them into inputs
   * @param extraInputs The inputs already placed into the object will remain, these extra inputs will be used to fill the remaining  value needed
   */
  selectUtxosFrom = (extraInputs) => {
    for (const input of extraInputs) {
      const address = input.output.address;
      if (!address) {
        throw Error("Address is missing from the extra input");
      }
      const decodedAddress = Address.fromString(address);
      if (decodedAddress?.getProps().paymentPart?.type !== CredentialType.KeyHash) {
        throw Error("Only KeyHash address is supported for utxo selection");
      }
    }
    this.meshTxBuilderBody.extraInputs = extraInputs;
    return this;
  };
  /**
   * Set the protocol parameters to be used for the transaction other than the default one
   * @param params (Part of) the protocol parameters to be used for the transaction
   * @returns The MeshTxBuilder instance
   */
  protocolParams = (params) => {
    const updatedParams = { ...DEFAULT_PROTOCOL_PARAMETERS, ...params };
    this._protocolParams = updatedParams;
    return this;
  };
  /**
   * Sets a specific fee for the transaction to use
   * @param fee The specified fee
   * @returns The MeshTxBuilder instance
   */
  setFee = (fee) => {
    this.manualFee = fee;
    this.meshTxBuilderBody.fee = fee;
    return this;
  };
  /**
   * Sets a total collateral for the transaction to use, a collateral return
   * will be generated to either the change address or the specified collateral return address
   * @param collateral The specified collateral
   * @returns The MeshTxBuilder instance
   */
  setTotalCollateral = (collateral) => {
    this.meshTxBuilderBody.totalCollateral = collateral;
    return this;
  };
  /**
   * Sets the collateral return address, if none is set, the change address will be used
   * @param address The address to use for collateral return
   * @returns The MeshTxBuilder instance
   */
  setCollateralReturnAddress = (address) => {
    this.meshTxBuilderBody.collateralReturnAddress = address;
    return this;
  };
  /**
   * Sets the network to use, this is mainly to know the cost models to be used to calculate script integrity hash
   * @param network The specific network this transaction is being built for ("testnet" | "preview" | "preprod" | "mainnet")
   * @returns The MeshTxBuilder instance
   */
  setNetwork = (network) => {
    this.meshTxBuilderBody.network = network;
    return this;
  };
  /**
   * Add a transaction that is used as input, but not yet reflected on the global blockchain
   * @param txHex The transaction hex of chained transaction
   * @returns The MeshTxBuilderCore instance
   */
  chainTx(txHex) {
    this.meshTxBuilderBody.chainedTxs.push(txHex);
    return this;
  }
  /**
   * Add a transaction input to provide information for offline evaluation
   * @param input The input to be added
   * @returns The MeshTxBuilderCore instance
   */
  inputForEvaluation(input) {
    const utxoId = `${input.input.txHash}${input.input.outputIndex}`;
    const currentUtxo = this.meshTxBuilderBody.inputsForEvaluation[utxoId];
    if (currentUtxo) {
      const {
        dataHash: currentDataHash,
        plutusData: currentPlutusData,
        scriptRef: currentScriptRef,
        scriptHash: currentScriptHash
      } = currentUtxo.output;
      const updatedUtxo = { ...currentUtxo };
      if (currentDataHash) updatedUtxo.output.dataHash = currentDataHash;
      if (currentPlutusData) updatedUtxo.output.plutusData = currentPlutusData;
      if (currentScriptRef) updatedUtxo.output.scriptRef = currentScriptRef;
      if (currentScriptHash) updatedUtxo.output.scriptHash = currentScriptHash;
      this.meshTxBuilderBody.inputsForEvaluation[utxoId] = updatedUtxo;
    } else {
      this.meshTxBuilderBody.inputsForEvaluation[utxoId] = input;
    }
    return this;
  }
  queueAllLastItem = () => {
    if (this.txOutput) {
      this.meshTxBuilderBody.outputs.push(this.txOutput);
      this.txOutput = void 0;
    }
    if (this.txInQueueItem) {
      this.queueInput();
    }
    if (this.collateralQueueItem) {
      this.meshTxBuilderBody.collaterals.push(this.collateralQueueItem);
      this.collateralQueueItem = void 0;
    }
    if (this.mintItem) {
      this.queueMint();
    }
    if (this.withdrawalItem) {
      this.queueWithdrawal();
    }
    if (this.voteItem) {
      this.queueVote();
    }
    if (this.proposalItem) {
      this.queueProposal();
    }
  };
  queueInput = () => {
    if (!this.txInQueueItem) throw Error("queueInput: Undefined input");
    if (this.txInQueueItem.type === "Script") {
      if (!this.txInQueueItem.scriptTxIn) {
        throw Error(
          "queueInput: Script input does not contain script, datum, or redeemer information"
        );
      } else {
        if (!this.txInQueueItem.scriptTxIn.datumSource)
          throw Error(
            "queueInput: Script input does not contain datum information"
          );
        if (!this.txInQueueItem.scriptTxIn.redeemer)
          throw Error(
            "queueInput: Script input does not contain redeemer information"
          );
        if (!this.txInQueueItem.scriptTxIn.scriptSource)
          throw Error(
            "queueInput: Script input does not contain script information"
          );
      }
    }
    this.meshTxBuilderBody.inputs.push(this.txInQueueItem);
    this.txInQueueItem = void 0;
  };
  queueMint = () => {
    if (!this.mintItem) throw Error("queueMint: Undefined mint");
    if (!this.mintItem.scriptSource)
      throw Error("queueMint: Missing mint script information");
    const currentMint = this.mintItem;
    const samePolicyIdMints = this.meshTxBuilderBody.mints.find((mint) => {
      return mint.policyId === currentMint.policyId;
    });
    if (samePolicyIdMints !== void 0) {
      if (JSONBig2.stringify(currentMint.redeemer) !== JSONBig2.stringify(samePolicyIdMints.redeemer)) {
        throw Error(
          "queueMint: Redeemer for the same policy id must be the same"
        );
      }
      if (JSONBig2.stringify(currentMint.scriptSource) !== JSONBig2.stringify(samePolicyIdMints.scriptSource)) {
        throw Error(
          "queueMint: Script source for the same policy id must be the same"
        );
      }
      samePolicyIdMints.mintValue.push({
        assetName: currentMint.assetName,
        amount: currentMint.amount
      });
    } else {
      this.meshTxBuilderBody.mints.push({
        type: currentMint.type,
        policyId: currentMint.policyId,
        scriptSource: currentMint.scriptSource,
        redeemer: currentMint.redeemer,
        mintValue: [
          {
            assetName: currentMint.assetName,
            amount: currentMint.amount
          }
        ]
      });
    }
    this.mintItem = void 0;
  };
  queueWithdrawal = () => {
    if (!this.withdrawalItem)
      throw Error("queueWithdrawal: Undefined withdrawal");
    if (this.withdrawalItem.type === "ScriptWithdrawal") {
      if (!this.withdrawalItem.scriptSource) {
        throw Error("queueWithdrawal: Missing withdrawal script information");
      }
      if (!this.withdrawalItem.redeemer) {
        throw Error("queueWithdrawal: Missing withdrawal redeemer information");
      }
    } else if (this.withdrawalItem.type === "SimpleScriptWithdrawal") {
      if (!this.withdrawalItem.scriptSource) {
        throw Error("queueWithdrawal: Missing withdrawal script information");
      }
    }
    this.meshTxBuilderBody.withdrawals.push(this.withdrawalItem);
    this.withdrawalItem = void 0;
  };
  queueVote = () => {
    if (!this.voteItem) {
      throw Error("queueVote: Undefined vote");
    }
    if (this.voteItem.type === "ScriptVote") {
      if (!this.voteItem.scriptSource) {
        throw Error("queueVote: Missing vote script information");
      }
      if (!this.voteItem.redeemer) {
        throw Error("queueVote: Missing vote redeemer information");
      }
    } else if (this.voteItem.type === "SimpleScriptVote") {
      if (!this.voteItem.simpleScriptSource) {
        throw Error("queueVote: Missing vote script information");
      }
    }
    this.meshTxBuilderBody.votes.push(this.voteItem);
    this.voteItem = void 0;
  };
  queueProposal = () => {
    if (!this.proposalItem) {
      throw Error("queueProposal: Undefined proposal");
    }
    if (this.proposalItem.type === "ScriptProposal") {
      if (!this.proposalItem.scriptSource) {
        throw Error("queueProposal: Missing proposal script information");
      }
      if (!this.proposalItem.redeemer) {
        throw Error("queueProposal: Missing proposal redeemer information");
      }
    } else if (this.proposalItem.type === "SimpleScriptProposal") {
      if (!this.proposalItem.simpleScriptSource) {
        throw Error("queueProposal: Missing proposal script information");
      }
    }
    this.meshTxBuilderBody.proposals.push(this.proposalItem);
    this.proposalItem = void 0;
  };
  castRawDataToJsonString = (rawData) => {
    if (typeof rawData === "object") {
      return JSONBig2.stringify(rawData);
    } else {
      return rawData;
    }
  };
  castBuilderDataToRedeemer = (redeemer, type = "Mesh", exUnits = { ...DEFAULT_REDEEMER_BUDGET }) => {
    let red;
    let content = redeemer;
    if (type === "Mesh") {
      red = {
        data: {
          type,
          content
        },
        exUnits
      };
      return red;
    }
    if (type === "JSON") {
      content = this.castRawDataToJsonString(redeemer);
    }
    red = {
      data: {
        type,
        content
      },
      exUnits
    };
    return red;
  };
  updateRedeemer = (meshTxBuilderBody, txEvaluation, doNotUseMultiplier = false) => {
    const txEvaluationMultiplier = doNotUseMultiplier ? 1 : this.txEvaluationMultiplier;
    txEvaluation.forEach((redeemerEvaluation) => {
      switch (redeemerEvaluation.tag) {
        case "SPEND": {
          const input = meshTxBuilderBody.inputs[redeemerEvaluation.index];
          if (!input) {
            throw Error(
              `updateRedeemer: Input not found for index ${redeemerEvaluation.index}`
            );
          }
          if (input.type == "Script" && input.scriptTxIn.redeemer) {
            input.scriptTxIn.redeemer.exUnits.mem = Math.floor(
              redeemerEvaluation.budget.mem * txEvaluationMultiplier
            );
            input.scriptTxIn.redeemer.exUnits.steps = Math.floor(
              redeemerEvaluation.budget.steps * txEvaluationMultiplier
            );
          }
          break;
        }
        case "MINT": {
          const mint = meshTxBuilderBody.mints[redeemerEvaluation.index];
          if (!mint) {
            throw Error(
              `updateRedeemer: Mint not found for index ${redeemerEvaluation.index}`
            );
          }
          if (mint.type == "Plutus" && mint.redeemer) {
            let newExUnits = {
              mem: Math.floor(
                redeemerEvaluation.budget.mem * txEvaluationMultiplier
              ),
              steps: Math.floor(
                redeemerEvaluation.budget.steps * txEvaluationMultiplier
              )
            };
            for (let i = redeemerEvaluation.index; i < meshTxBuilderBody.mints.length; i++) {
              if (meshTxBuilderBody.mints[i].policyId === mint.policyId) {
                meshTxBuilderBody.mints[i].redeemer.exUnits = newExUnits;
              }
            }
          }
          break;
        }
        case "CERT":
          const cert = meshTxBuilderBody.certificates[redeemerEvaluation.index];
          if (!cert) {
            throw Error(
              `updateRedeemer: Cert not found for index ${redeemerEvaluation.index}`
            );
          }
          if (cert.type === "ScriptCertificate" && cert.redeemer) {
            cert.redeemer.exUnits.mem = Math.floor(
              redeemerEvaluation.budget.mem * txEvaluationMultiplier
            );
            cert.redeemer.exUnits.steps = Math.floor(
              redeemerEvaluation.budget.steps * txEvaluationMultiplier
            );
          }
          break;
        case "REWARD":
          const withdrawal = meshTxBuilderBody.withdrawals[redeemerEvaluation.index];
          if (!withdrawal) {
            throw Error(
              `updateRedeemer: Withdrawal not found for index ${redeemerEvaluation.index}`
            );
          }
          if (withdrawal.type === "ScriptWithdrawal" && withdrawal.redeemer) {
            withdrawal.redeemer.exUnits.mem = Math.floor(
              redeemerEvaluation.budget.mem * txEvaluationMultiplier
            );
            withdrawal.redeemer.exUnits.steps = Math.floor(
              redeemerEvaluation.budget.steps * txEvaluationMultiplier
            );
          }
          break;
        case "VOTE":
          const vote = meshTxBuilderBody.votes[redeemerEvaluation.index];
          if (!vote) {
            throw Error(
              `updateRedeemer: Vote not found for index ${redeemerEvaluation.index}`
            );
          }
          if (vote.type === "ScriptVote" && vote.redeemer) {
            vote.redeemer.exUnits.mem = Math.floor(
              redeemerEvaluation.budget.mem * txEvaluationMultiplier
            );
            vote.redeemer.exUnits.steps = Math.floor(
              redeemerEvaluation.budget.steps * txEvaluationMultiplier
            );
          }
          break;
      }
    });
  };
  removeDuplicateInputs = () => {
    const { inputs } = this.meshTxBuilderBody;
    const getTxInId = (txIn) => `${txIn.txHash}#${txIn.txIndex}`;
    const currentTxInIds = [];
    const addedInputs = [];
    for (let i = 0; i < inputs.length; i += 1) {
      const currentInput = inputs[i];
      const currentTxInId = getTxInId(currentInput.txIn);
      if (currentTxInIds.includes(currentTxInId)) {
        continue;
      } else {
        currentTxInIds.push(currentTxInId);
        addedInputs.push(currentInput);
      }
    }
    this.meshTxBuilderBody.inputs = addedInputs;
  };
  removeDuplicateRefInputs = () => {
    const { referenceInputs } = this.meshTxBuilderBody;
    const getTxInId = (txIn) => `${txIn.txHash}#${txIn.txIndex}`;
    const currentTxInIds = [];
    const addedInputs = [];
    for (let i = 0; i < referenceInputs.length; i += 1) {
      const currentInput = referenceInputs[i];
      const currentTxInId = getTxInId(currentInput);
      if (currentTxInIds.includes(currentTxInId)) {
        continue;
      } else {
        currentTxInIds.push(currentTxInId);
        addedInputs.push(currentInput);
      }
    }
    this.meshTxBuilderBody.referenceInputs = addedInputs;
  };
  emptyTxBuilderBody = () => {
    this.meshTxBuilderBody = emptyTxBuilderBody();
    return emptyTxBuilderBody;
  };
  reset = () => {
    this.meshTxBuilderBody = emptyTxBuilderBody();
    this.txEvaluationMultiplier = 1;
    this.txOutput = void 0;
    this.addingPlutusScriptInput = false;
    this.plutusSpendingScriptVersion = void 0;
    this.addingPlutusMint = false;
    this.plutusMintingScriptVersion = void 0;
    this.addingPlutusWithdrawal = false;
    this.addingPlutusVote = false;
    this.plutusWithdrawalScriptVersion = void 0;
    this._protocolParams = DEFAULT_PROTOCOL_PARAMETERS;
    this.mintItem = void 0;
    this.txInQueueItem = void 0;
    this.withdrawalItem = void 0;
    this.voteItem = void 0;
    this.proposalItem = void 0;
    this.collateralQueueItem = void 0;
    this.refScriptTxInQueueItem = void 0;
  };
  _cloneCore(createInstance) {
    this.queueAllLastItem();
    const newBuilder = createInstance();
    newBuilder.meshTxBuilderBody = cloneTxBuilderBody(this.meshTxBuilderBody);
    newBuilder.txEvaluationMultiplier = this.txEvaluationMultiplier;
    newBuilder.txOutput = this.txOutput ? structuredClone(this.txOutput) : void 0;
    newBuilder.addingPlutusScriptInput = this.addingPlutusScriptInput;
    newBuilder.plutusSpendingScriptVersion = this.plutusSpendingScriptVersion;
    newBuilder.addingPlutusMint = this.addingPlutusMint;
    newBuilder.plutusMintingScriptVersion = this.plutusMintingScriptVersion;
    newBuilder.addingPlutusWithdrawal = this.addingPlutusWithdrawal;
    newBuilder.plutusWithdrawalScriptVersion = this.plutusWithdrawalScriptVersion;
    newBuilder.addingPlutusVote = this.addingPlutusVote;
    newBuilder.plutusVoteScriptVersion = this.plutusVoteScriptVersion;
    newBuilder._protocolParams = structuredClone(this._protocolParams);
    newBuilder.mintItem = this.mintItem ? structuredClone(this.mintItem) : void 0;
    newBuilder.txInQueueItem = this.txInQueueItem ? structuredClone(this.txInQueueItem) : void 0;
    newBuilder.withdrawalItem = this.withdrawalItem ? structuredClone(this.withdrawalItem) : void 0;
    newBuilder.voteItem = this.voteItem ? structuredClone(this.voteItem) : void 0;
    newBuilder.proposalItem = this.proposalItem ? structuredClone(this.proposalItem) : void 0;
    newBuilder.collateralQueueItem = this.collateralQueueItem ? structuredClone(this.collateralQueueItem) : void 0;
    newBuilder.refScriptTxInQueueItem = this.refScriptTxInQueueItem ? structuredClone(this.refScriptTxInQueueItem) : void 0;
    newBuilder.manualFee = this.manualFee;
    return newBuilder;
  }
};

// src/mesh-tx-builder/utils.ts
import {
  DEFAULT_PROTOCOL_PARAMETERS as DEFAULT_PROTOCOL_PARAMETERS2
} from "@meshsdk/common";
var utxoToTxIn = (utxo) => {
  return [
    utxo.input.txHash,
    utxo.input.outputIndex,
    utxo.output.amount,
    utxo.output.address
  ];
};
var getUtxoMinLovelace = (utxo, coinsPerUtxoSize = DEFAULT_PROTOCOL_PARAMETERS2.coinsPerUtxoSize) => {
  const referenceScript = utxo.scriptRef ? { code: utxo.scriptRef, version: "V3" } : void 0;
  let datum;
  if (utxo.plutusData) {
    datum = {
      type: "Inline",
      data: {
        content: utxo.plutusData,
        type: "CBOR"
      }
    };
  } else if (utxo.dataHash) {
    datum = {
      type: "Hash",
      data: {
        content: utxo.dataHash,
        // usually this should be entire datum cbor, but irrelevant in min utxo calculation
        type: "CBOR"
      }
    };
  }
  const output = {
    address: utxo.address,
    amount: utxo.amount,
    referenceScript,
    datum
  };
  const minLovelace = getOutputMinLovelace(output, coinsPerUtxoSize);
  return minLovelace;
};

// src/mesh-tx-builder/index.ts
var MeshTxBuilder = class _MeshTxBuilder extends MeshTxBuilderCore {
  serializer;
  selector;
  fetcher;
  submitter;
  evaluator;
  txHex = "";
  verbose;
  queriedTxHashes = /* @__PURE__ */ new Set();
  queriedUTxOs = {};
  utxosWithRefScripts = [];
  constructor({
    serializer,
    selector,
    fetcher,
    submitter,
    evaluator,
    params,
    isHydra = false,
    verbose = false
  } = {}) {
    super();
    if (fetcher) this.fetcher = fetcher;
    if (submitter) this.submitter = submitter;
    if (evaluator) this.evaluator = evaluator;
    if (params) this.protocolParams(params);
    if (serializer) {
      this.serializer = serializer;
    } else {
      this.serializer = new CardanoSDKSerializer(this._protocolParams);
    }
    if (selector) {
      this.selector = selector;
    } else {
      this.selector = new CardanoSdkInputSelector();
    }
    this.verbose = verbose;
    if (isHydra)
      this.protocolParams({
        minFeeA: 0,
        minFeeB: 0,
        priceMem: 0,
        priceStep: 0,
        collateralPercent: 0,
        coinsPerUtxoSize: 0
      });
  }
  serializeMockTx = () => {
    const builderBody = this.meshTxBuilderBody;
    const { keyHashes, byronAddresses } = this.collectAllRequiredSignatures();
    builderBody.expectedNumberKeyWitnesses = keyHashes.size;
    builderBody.expectedByronAddressWitnesses = Array.from(byronAddresses);
    return this.serializer.serializeTxBodyWithMockSignatures(
      this.meshTxBuilderBody,
      this._protocolParams
    );
  };
  /**
   * It builds the transaction query the blockchain for missing information
   * @param customizedTx The optional customized transaction body
   * @returns The transaction in hex, unbalanced
   */
  completeUnbalanced = (customizedTx) => {
    if (customizedTx) {
      this.meshTxBuilderBody = customizedTx;
    } else {
      this.queueAllLastItem();
    }
    this.removeDuplicateInputs();
    this.removeDuplicateRefInputs();
    return this.serializer.serializeTxBody(
      this.meshTxBuilderBody,
      this._protocolParams
    );
  };
  completeSync = (customizedTx) => {
    if (customizedTx) {
      this.meshTxBuilderBody = customizedTx;
    } else {
      this.queueAllLastItem();
    }
    this.removeDuplicateInputs();
    this.removeDuplicateRefInputs();
    return this.serializer.serializeTxBody(
      this.meshTxBuilderBody,
      this._protocolParams
    );
  };
  /**
   * It builds the transaction and query the blockchain for missing information
   * @param customizedTx The optional customized transaction body
   * @returns The signed transaction in hex ready to submit / signed by client
   */
  complete = async (customizedTx) => {
    if (customizedTx) {
      this.meshTxBuilderBody = { ...this.meshTxBuilderBody, ...customizedTx };
      if (customizedTx.fee) {
        this.setFee(customizedTx.fee);
      }
    }
    this.queueAllLastItem();
    if (this.verbose) {
      console.log(
        "txBodyJson - before coin selection",
        JSONBig3.stringify(this.meshTxBuilderBody, (key, val) => {
          if (key === "extraInputs") return void 0;
          if (key === "selectionConfig") return void 0;
          return val;
        })
      );
    }
    this.removeDuplicateInputs();
    this.removeDuplicateRefInputs();
    for (let collateral of this.meshTxBuilderBody.collaterals) {
      collateral.txIn.scriptSize = 0;
    }
    await this.completeTxParts();
    await this.sanitizeOutputs();
    this.sortTxParts();
    if (!this.meshTxBuilderBody.changeAddress || this.meshTxBuilderBody.changeAddress === "") {
      throw new Error(
        "Change address is not set, utxo selection cannot be done without this"
      );
    }
    const txPrototype = await this.selectUtxos();
    await this.updateByTxPrototype(txPrototype, true);
    if (this.verbose) {
      console.log(
        "txBodyJson - after coin selection",
        JSONBig3.stringify(this.meshTxBuilderBody, (key, val) => {
          if (key === "extraInputs") return void 0;
          if (key === "selectionConfig") return void 0;
          return val;
        })
      );
    }
    const txHex = this.serializer.serializeTxBody(
      this.meshTxBuilderBody,
      this._protocolParams
    );
    this.txHex = txHex;
    return txHex;
  };
  selectUtxos = async () => {
    const currentInputs = this.meshTxBuilderBody.inputs;
    const currentOutputs = this.meshTxBuilderBody.outputs;
    const changeAddress = this.meshTxBuilderBody.changeAddress;
    const utxosForSelection = await this.getUtxosForSelection();
    const implicitValue = {
      withdrawals: this.getTotalWithdrawal(),
      deposit: this.getTotalDeposit(),
      reclaimDeposit: this.getTotalRefund(),
      mint: this.getTotalMint()
    };
    const selectionCallbacks = {
      computeMinimumCost: async (selectionSkeleton) => {
        const clonedBuilder = this.clone();
        await clonedBuilder.updateByTxPrototype(selectionSkeleton);
        try {
          await clonedBuilder.evaluateRedeemers();
        } catch (error) {
          if (error instanceof Error) {
            throw new Error(`Evaluate redeemers failed: ${error.message}`);
          } else if (typeof error === "string") {
            throw new Error(`Evaluate redeemers failed: ${error}`);
          } else if (typeof error === "object") {
            throw new Error(
              `Evaluate redeemers failed: ${JSON.stringify(error)}`
            );
          } else {
            throw new Error(`Evaluate redeemers failed: ${String(error)}`);
          }
        }
        const fee = clonedBuilder.getActualFee();
        const redeemers = clonedBuilder.getRedeemerCosts();
        return {
          fee,
          redeemers
        };
      },
      tokenBundleSizeExceedsLimit: (tokenBundle) => {
        const maxValueSize = this._protocolParams.maxValSize;
        if (tokenBundle) {
          const valueSize = this.serializer.serializeValue(tokenBundle).length / 2;
          return valueSize > maxValueSize;
        }
        return false;
      },
      computeMinimumCoinQuantity: (output) => {
        return this.calculateMinLovelaceForOutput(output);
      },
      maxSizeExceed: async (selectionSkeleton) => {
        const clonedBuilder = this.clone();
        await clonedBuilder.updateByTxPrototype(selectionSkeleton);
        const maxTxSize = this._protocolParams.maxTxSize;
        const txSize = clonedBuilder.getSerializedSize();
        return txSize > maxTxSize;
      }
    };
    return await this.selector.select(
      currentInputs,
      currentOutputs,
      implicitValue,
      utxosForSelection,
      changeAddress,
      selectionCallbacks
    );
  };
  updateByTxPrototype = async (selectionSkeleton, final = false) => {
    for (let utxo of selectionSkeleton.newInputs) {
      this.txIn(
        utxo.input.txHash,
        utxo.input.outputIndex,
        utxo.output.amount,
        utxo.output.address,
        utxo.output.scriptRef ? utxo.output.scriptRef.length / 2 : 0
      );
    }
    for (let output of selectionSkeleton.newOutputs) {
      this.txOut(output.address, output.amount);
    }
    for (let change of selectionSkeleton.change) {
      this.txOut(change.address, change.amount);
    }
    this.meshTxBuilderBody.fee = selectionSkeleton.fee.toString();
    this.queueAllLastItem();
    this.removeDuplicateInputs();
    this.sortTxParts();
    this.updateRedeemer(
      this.meshTxBuilderBody,
      selectionSkeleton.redeemers ?? [],
      final
    );
  };
  getUtxosForSelection = async () => {
    const utxos = this.meshTxBuilderBody.extraInputs;
    const usedUtxos = new Set(
      this.meshTxBuilderBody.inputs.map(
        (input) => `${input.txIn.txHash}${input.txIn.txIndex}`
      )
    );
    return utxos.filter(
      (utxo) => !usedUtxos.has(`${utxo.input.txHash}${utxo.input.outputIndex}`)
    );
  };
  sortTxParts = () => {
    this.sortInputs();
    this.sortMints();
    this.sortWithdrawals();
    this.sortVotes();
    this.sortProposals();
  };
  sortInputs = () => {
    this.meshTxBuilderBody.inputs.sort((a, b) => {
      if (a.txIn.txHash < b.txIn.txHash) return -1;
      if (a.txIn.txHash > b.txIn.txHash) return 1;
      if (a.txIn.txIndex < b.txIn.txIndex) return -1;
      if (a.txIn.txIndex > b.txIn.txIndex) return 1;
      return 0;
    });
  };
  sortMints = () => {
    this.meshTxBuilderBody.mints.sort((a, b) => {
      if (a.policyId < b.policyId) return -1;
      if (a.policyId > b.policyId) return 1;
      return 0;
    });
  };
  compareCredentials = (credentialA, credentialB) => {
    if (credentialA.type === CstCredentialType.ScriptHash && credentialB.type === CstCredentialType.KeyHash) {
      return -1;
    }
    if (credentialA.type === CstCredentialType.KeyHash && credentialB.type === CstCredentialType.ScriptHash) {
      return 1;
    }
    if (credentialA.type === credentialB.type) {
      if (credentialA.hash < credentialB.hash) return -1;
      if (credentialA.hash > credentialB.hash) return 1;
      return 0;
    }
    return 0;
  };
  sortWithdrawals = () => {
    this.meshTxBuilderBody.withdrawals.sort((a, b) => {
      const credentialA = CstAddress.fromString(a.address)?.asReward()?.getPaymentCredential();
      const credentialB = CstAddress.fromString(b.address)?.asReward()?.getPaymentCredential();
      if (credentialA && credentialB) {
        return this.compareCredentials(credentialA, credentialB);
      }
      return 0;
    });
  };
  sortVotes = () => {
    const variantOrder = {
      ConstitutionalCommittee: 0,
      DRep: 1,
      StakingPool: 2
    };
    this.meshTxBuilderBody.votes.sort((a, b) => {
      const voterA = a.vote.voter;
      const voterB = b.vote.voter;
      const orderA = variantOrder[voterA.type];
      const orderB = variantOrder[voterB.type];
      if (orderA !== orderB) return orderA - orderB;
      if (voterA.type === "ConstitutionalCommittee" && voterB.type === "ConstitutionalCommittee") {
        const credA = voterA.hotCred;
        const credB = voterB.hotCred;
        if (credA.type === "ScriptHash" && credB.type === "KeyHash") {
          return -1;
        }
        if (credA.type === "KeyHash" && credB.type === "ScriptHash") {
          return 1;
        }
        if (credA.type === credB.type) {
          const hashA = credA.type === "KeyHash" ? credA.keyHash : credA.scriptHash;
          const hashB = credB.type === "KeyHash" ? credB.keyHash : credB.scriptHash;
          if (hashA < hashB) return -1;
          if (hashA > hashB) return 1;
          return 0;
        }
        return 0;
      }
      if (voterA.type === "DRep" && voterB.type === "DRep") {
        const drepA = coreToCstDRep(voterA.drepId);
        const drepB = coreToCstDRep(voterB.drepId);
        const scriptHashA = drepA.toScriptHash();
        const scriptHashB = drepB.toScriptHash();
        const keyHashA = drepA.toKeyHash();
        const keyHashB = drepB.toKeyHash();
        if (scriptHashA != null && scriptHashB != null) {
          if (scriptHashA < scriptHashB) return -1;
          if (scriptHashA > scriptHashB) return 1;
          return 0;
        }
        if (scriptHashA != null) return -1;
        if (scriptHashB != null) return 1;
        if (keyHashA != null && keyHashB != null) {
          if (keyHashA < keyHashB) return -1;
          if (keyHashA > keyHashB) return 1;
          return 0;
        }
        return 0;
      }
      if (voterA.type === "StakingPool" && voterB.type === "StakingPool") {
        if (voterA.keyHash < voterB.keyHash) return -1;
        if (voterA.keyHash > voterB.keyHash) return 1;
        return 0;
      }
      return 0;
    });
  };
  sortProposals = () => {
  };
  evaluateRedeemers = async () => {
    let txHex = this.serializer.serializeTxBody(
      this.meshTxBuilderBody,
      this._protocolParams
    );
    if (this.evaluator) {
      const txEvaluation = await this.evaluator.evaluateTx(
        txHex,
        Object.values(this.meshTxBuilderBody.inputsForEvaluation),
        this.meshTxBuilderBody.chainedTxs
      ).catch((error) => {
        if (error instanceof Error) {
          throw new Error(
            `Tx evaluation failed: ${error.message} 
 For txHex: ${txHex}`
          );
        } else if (typeof error === "string") {
          throw new Error(
            `Tx evaluation failed: ${error} 
 For txHex: ${txHex}`
          );
        } else if (typeof error === "object") {
          throw new Error(
            `Tx evaluation failed: ${JSON.stringify(error)} 
 For txHex: ${txHex}`
          );
        } else {
          throw new Error(
            `Tx evaluation failed: ${String(error)} 
 For txHex: ${txHex}`
          );
        }
      });
      this.updateRedeemer(this.meshTxBuilderBody, txEvaluation);
    }
  };
  getRedeemerCosts = () => {
    const meshTxBuilderBody = this.meshTxBuilderBody;
    const redeemers = [];
    for (let i = 0; i < meshTxBuilderBody.inputs.length; i++) {
      const input = meshTxBuilderBody.inputs[i];
      if (input.type == "Script" && input.scriptTxIn.redeemer) {
        redeemers.push({
          tag: "SPEND",
          index: i,
          budget: structuredClone(input.scriptTxIn.redeemer.exUnits)
        });
      }
    }
    for (let i = 0; i < meshTxBuilderBody.mints.length; i++) {
      const mint = meshTxBuilderBody.mints[i];
      if (mint.type == "Plutus" && mint.redeemer) {
        redeemers.push({
          tag: "MINT",
          index: i,
          budget: structuredClone(mint.redeemer.exUnits)
        });
      }
    }
    for (let i = 0; i < meshTxBuilderBody.certificates.length; i++) {
      const cert = meshTxBuilderBody.certificates[i];
      if (cert.type === "ScriptCertificate" && cert.redeemer) {
        redeemers.push({
          tag: "CERT",
          index: i,
          budget: structuredClone(cert.redeemer.exUnits)
        });
      }
    }
    for (let i = 0; i < meshTxBuilderBody.withdrawals.length; i++) {
      const withdrawal = meshTxBuilderBody.withdrawals[i];
      if (withdrawal.type === "ScriptWithdrawal" && withdrawal.redeemer) {
        redeemers.push({
          tag: "REWARD",
          index: i,
          budget: structuredClone(withdrawal.redeemer.exUnits)
        });
      }
    }
    for (let i = 0; i < meshTxBuilderBody.votes.length; i++) {
      const vote = meshTxBuilderBody.votes[i];
      if (vote.type === "ScriptVote" && vote.redeemer) {
        redeemers.push({
          tag: "VOTE",
          index: i,
          budget: structuredClone(vote.redeemer.exUnits)
        });
      }
    }
    return redeemers;
  };
  /**
   * It builds the transaction without dependencies
   * @param customizedTx The optional customized transaction body
   * @returns The transaction in hex, unbalanced
   */
  completeUnbalancedSync = (customizedTx) => {
    if (customizedTx) {
      this.meshTxBuilderBody = customizedTx;
      if (customizedTx.fee) {
        this.setFee(customizedTx.fee);
      }
    } else {
      this.queueAllLastItem();
    }
    this.removeDuplicateInputs();
    this.removeDuplicateRefInputs();
    return this.serializer.serializeTxBody(
      this.meshTxBuilderBody,
      this._protocolParams
    );
  };
  /**
   * Complete the signing process
   * @returns The signed transaction in hex
   */
  completeSigning = () => {
    const signedTxHex = this.serializer.addSigningKeys(
      this.txHex,
      this.meshTxBuilderBody.signingKey
    );
    this.txHex = signedTxHex;
    return signedTxHex;
  };
  /**
   * Submit transactions to the blockchain using the fetcher instance
   * @param txHex The signed transaction in hex
   * @returns
   */
  submitTx = async (txHex) => {
    const txHash = await this.submitter?.submitTx(txHex);
    return txHash;
  };
  /**
   * Get the UTxO information from the blockchain
   * @param txHash The TxIn object that contains the txHash and txIndex, while missing amount and address information
   */
  getUTxOInfo = async (txHash) => {
    let utxos = [];
    if (!this.queriedTxHashes.has(txHash)) {
      this.queriedTxHashes.add(txHash);
      utxos = await this.fetcher?.fetchUTxOs(txHash) || [];
      this.queriedUTxOs[txHash] = utxos;
    }
  };
  queryAllTxInfo = (incompleteTxIns, incompleteScriptSources, incompleteSimpleScriptSources) => {
    const queryUTxOPromises = [];
    if ((incompleteTxIns.length > 0 || incompleteScriptSources.length > 0 || incompleteSimpleScriptSources.length) && !this.fetcher)
      throw Error(
        "Transaction information is incomplete while no fetcher instance is provided. Provide a `fetcher`."
      );
    for (let i = 0; i < incompleteTxIns.length; i++) {
      const currentTxIn = incompleteTxIns[i];
      if (!this.isInputInfoComplete(currentTxIn)) {
        queryUTxOPromises.push(this.getUTxOInfo(currentTxIn.txIn.txHash));
      }
    }
    for (let i = 0; i < incompleteScriptSources.length; i++) {
      const scriptSource = incompleteScriptSources[i];
      if (scriptSource.type === "Inline") {
        queryUTxOPromises.push(this.getUTxOInfo(scriptSource.txHash));
      }
    }
    return Promise.all(queryUTxOPromises);
  };
  completeTxInformation = (input) => {
    if (!this.isInputInfoComplete(input)) {
      this.completeInputInfo(input);
    }
    if (input.type === "Script" && !this.isRefScriptInfoComplete(input.scriptTxIn.scriptSource)) {
      const scriptSource = input.scriptTxIn.scriptSource;
      this.completeScriptInfo(scriptSource);
    }
  };
  completeInputInfo = (input) => {
    const utxos = this.queriedUTxOs[input.txIn.txHash];
    const utxo = utxos?.find(
      (utxo2) => utxo2.input.outputIndex === input.txIn.txIndex
    );
    const amount = utxo?.output.amount;
    const address = utxo?.output.address;
    if (!amount || amount.length === 0)
      throw Error(
        `Couldn't find value information for ${input.txIn.txHash}#${input.txIn.txIndex}`
      );
    input.txIn.amount = amount;
    if (!address || address === "")
      throw Error(
        `Couldn't find address information for ${input.txIn.txHash}#${input.txIn.txIndex}`
      );
    input.txIn.address = address;
    if (utxo?.output.scriptRef) {
      input.txIn.scriptSize = utxo.output.scriptRef.length / 2;
    } else {
      input.txIn.scriptSize = 0;
    }
  };
  completeScriptInfo = (scriptSource) => {
    if (scriptSource?.type != "Inline") return;
    const refUtxos = this.queriedUTxOs[scriptSource.txHash];
    const scriptRefUtxo = refUtxos.find(
      (utxo) => utxo.input.outputIndex === scriptSource.txIndex
    );
    if (!scriptRefUtxo)
      throw Error(
        `Couldn't find script reference utxo for ${scriptSource.txHash}#${scriptSource.txIndex}`
      );
    scriptSource.scriptHash = scriptRefUtxo?.output.scriptHash;
    scriptSource.scriptSize = (scriptRefUtxo?.output.scriptRef.length / 2).toString();
  };
  completeSimpleScriptInfo = (simpleScript) => {
    if (simpleScript.type !== "Inline") return;
    const refUtxos = this.queriedUTxOs[simpleScript.txHash];
    const scriptRefUtxo = refUtxos.find(
      (utxo) => utxo.input.outputIndex === simpleScript.txIndex
    );
    if (!scriptRefUtxo)
      throw Error(
        `Couldn't find script reference utxo for ${simpleScript.txHash}#${simpleScript.txIndex}`
      );
    simpleScript.simpleScriptHash = scriptRefUtxo?.output.scriptHash;
  };
  isInputComplete = (txIn) => {
    if (txIn.type === "PubKey") return this.isInputInfoComplete(txIn);
    if (txIn.type === "Script") {
      const { scriptSource } = txIn.scriptTxIn;
      return this.isInputInfoComplete(txIn) && this.isRefScriptInfoComplete(scriptSource);
    }
    return true;
  };
  isInputInfoComplete = (txIn) => {
    const { amount, address, scriptSize } = txIn.txIn;
    if (!amount || !address || scriptSize === void 0) return false;
    return true;
  };
  isMintComplete = (mint) => {
    if (mint.type === "Plutus") {
      const scriptSource = mint.scriptSource;
      return this.isRefScriptInfoComplete(scriptSource);
    }
    if (mint.type === "Native") {
      const scriptSource = mint.scriptSource;
      if (scriptSource.type === "Inline") {
        if (!scriptSource?.simpleScriptHash) return false;
      }
    }
    return true;
  };
  isRefScriptInfoComplete = (scriptSource) => {
    if (scriptSource?.type === "Inline") {
      if (!scriptSource?.scriptHash || !scriptSource?.scriptSize) return false;
    }
    return true;
  };
  isSimpleRefScriptInfoComplete = (simpleScriptSource) => {
    if (simpleScriptSource.type === "Inline") {
      if (!simpleScriptSource.simpleScriptHash || !simpleScriptSource.scriptSize)
        return false;
    }
    return true;
  };
  completeSerialization = async (customizedTx) => {
    if (customizedTx) {
      this.meshTxBuilderBody = { ...this.meshTxBuilderBody, ...customizedTx };
    } else {
      this.queueAllLastItem();
    }
    this.removeDuplicateInputs();
    this.removeDuplicateRefInputs();
    for (let collateral of this.meshTxBuilderBody.collaterals) {
      collateral.txIn.scriptSize = 0;
    }
    await this.completeTxParts();
    let txHex = this.serializer.serializeTxBody(
      this.meshTxBuilderBody,
      this._protocolParams
    );
    if (this.evaluator) {
      const txEvaluation = await this.evaluator.evaluateTx(
        txHex,
        Object.values(this.meshTxBuilderBody.inputsForEvaluation),
        this.meshTxBuilderBody.chainedTxs
      ).catch((error) => {
        throw new Error(
          `Tx evaluation failed: ${JSON.stringify(error)} 
 For txHex: ${txHex}`
        );
      });
      this.updateRedeemer(this.meshTxBuilderBody, txEvaluation);
      txHex = this.serializer.serializeTxBody(
        this.meshTxBuilderBody,
        this._protocolParams
      );
    }
    this.txHex = txHex;
    return txHex;
  };
  completeTxParts = async () => {
    const { inputs, collaterals, mints, withdrawals, votes, certificates } = this.meshTxBuilderBody;
    const incompleteTxIns = [...inputs, ...collaterals].filter(
      (txIn) => !this.isInputComplete(txIn)
    );
    let incompleteScriptSources = [];
    let incompleteSimpleScriptSources = [];
    inputs.forEach((txIn) => {
      if (txIn.type === "Script" && txIn.scriptTxIn.scriptSource?.type === "Inline") {
        if (!this.isRefScriptInfoComplete(txIn.scriptTxIn.scriptSource)) {
          incompleteScriptSources.push(txIn.scriptTxIn.scriptSource);
        }
      } else if (txIn.type === "SimpleScript" && txIn.simpleScriptTxIn?.scriptSource?.type === "Inline") {
        if (!this.isSimpleRefScriptInfoComplete(
          txIn.simpleScriptTxIn.scriptSource
        )) {
          incompleteSimpleScriptSources.push(
            txIn.simpleScriptTxIn.scriptSource
          );
        }
      }
    });
    mints.forEach((mint) => {
      if (mint.type === "Plutus") {
        const scriptSource = mint.scriptSource;
        if (!this.isRefScriptInfoComplete(scriptSource)) {
          incompleteScriptSources.push(scriptSource);
        }
      } else if (mint.type === "Native") {
        const scriptSource = mint.scriptSource;
        if (!this.isSimpleRefScriptInfoComplete(scriptSource)) {
          incompleteSimpleScriptSources.push(scriptSource);
        }
      }
    });
    withdrawals.forEach((withdrawal) => {
      if (withdrawal.type === "ScriptWithdrawal") {
        const scriptSource = withdrawal.scriptSource;
        if (!this.isRefScriptInfoComplete(scriptSource)) {
          incompleteScriptSources.push(scriptSource);
        }
      } else if (withdrawal.type === "SimpleScriptWithdrawal") {
        const scriptSource = withdrawal.scriptSource;
        if (!this.isSimpleRefScriptInfoComplete(scriptSource)) {
          incompleteSimpleScriptSources.push(scriptSource);
        }
      }
    });
    votes.forEach((vote) => {
      if (vote.type === "ScriptVote") {
        const scriptSource = vote.scriptSource;
        if (!this.isRefScriptInfoComplete(scriptSource)) {
          incompleteScriptSources.push(scriptSource);
        }
      } else if (vote.type === "SimpleScriptVote") {
        const scriptSource = vote.simpleScriptSource;
        if (!this.isSimpleRefScriptInfoComplete(scriptSource)) {
          incompleteSimpleScriptSources.push(scriptSource);
        }
      }
    });
    certificates.forEach((certificate) => {
      if (certificate.type === "ScriptCertificate") {
        const scriptSource = certificate.scriptSource;
        if (!this.isRefScriptInfoComplete(scriptSource)) {
          incompleteScriptSources.push(scriptSource);
        }
      } else if (certificate.type === "SimpleScriptCertificate") {
        const scriptSource = certificate.simpleScriptSource;
        if (!this.isSimpleRefScriptInfoComplete(scriptSource)) {
          incompleteSimpleScriptSources.push(scriptSource);
        }
      }
    });
    await this.queryAllTxInfo(
      incompleteTxIns,
      incompleteScriptSources,
      incompleteSimpleScriptSources
    );
    incompleteTxIns.forEach((txIn) => {
      this.completeTxInformation(txIn);
    });
    incompleteScriptSources.forEach((scriptSource) => {
      this.completeScriptInfo(scriptSource);
    });
    incompleteSimpleScriptSources.forEach((simpleScriptSource) => {
      this.completeSimpleScriptInfo(simpleScriptSource);
    });
    this.meshTxBuilderBody.inputs.forEach((input) => {
      if (input.txIn.scriptSize && input.txIn.scriptSize > 0) {
        if (this.meshTxBuilderBody.referenceInputs.find((refTxIn) => {
          refTxIn.txHash === input.txIn.txHash && refTxIn.txIndex === input.txIn.txIndex;
        }) === void 0) {
          this.meshTxBuilderBody.referenceInputs.push({
            txHash: input.txIn.txHash,
            txIndex: input.txIn.txIndex,
            scriptSize: input.txIn.scriptSize
          });
        }
      }
    });
    this.sortTxParts();
  };
  sanitizeOutputs = async () => {
    this.meshTxBuilderBody.outputs.forEach((output) => {
      let lovelaceFound = false;
      output.amount.forEach((asset) => {
        if (asset.unit === "lovelace" || asset.unit === "") {
          lovelaceFound = true;
        }
      });
      if (!lovelaceFound) {
        const minAda = this.calculateMinLovelaceForOutput(output);
        output.amount.push({
          unit: "lovelace",
          quantity: minAda.toString()
        });
      }
    });
  };
  collectAllRequiredSignatures = () => {
    const { paymentCreds, byronAddresses } = this.getInputsRequiredSignatures();
    const { collateralPaymentCreds, collateralByronAddresses } = this.getCollateralRequiredSignatures();
    const withdrawalCreds = this.getWithdrawalRequiredSignatures();
    const certCreds = this.getCertificatesRequiredSignatures();
    const voteCreds = this.getVoteRequiredSignatures();
    const mintCreds = this.getMintRequiredSignatures();
    const requiredSignatures = this.meshTxBuilderBody.requiredSignatures;
    const allCreds = /* @__PURE__ */ new Set([
      ...paymentCreds,
      ...withdrawalCreds,
      ...collateralPaymentCreds,
      ...certCreds,
      ...voteCreds,
      ...requiredSignatures,
      ...mintCreds
    ]);
    const allByronAddresses = /* @__PURE__ */ new Set([
      ...byronAddresses,
      ...collateralByronAddresses
    ]);
    return { keyHashes: allCreds, byronAddresses: allByronAddresses };
  };
  getInputsRequiredSignatures() {
    const byronAddresses = /* @__PURE__ */ new Set();
    const paymentCreds = /* @__PURE__ */ new Set();
    for (let input of this.meshTxBuilderBody.inputs) {
      if (input.type === "PubKey") {
        if (input.txIn.address) {
          const address = CstAddress.fromString(input.txIn.address);
          if (!address) {
            continue;
          }
          const addressDetails = address.getProps();
          const paymentCred = addressDetails.paymentPart;
          if (paymentCred?.type === CstCredentialType.KeyHash) {
            paymentCreds.add(paymentCred.hash);
          }
          if (addressDetails.type === CstAddressType.Byron) {
            byronAddresses.add(input.txIn.address);
          }
        }
      } else if (input.type === "SimpleScript") {
        const nativeScript = this.getInputNativeScript(input);
        if (nativeScript) {
          let pubKeys = this.getNativeScriptPubKeys(nativeScript);
          for (let pubKey of pubKeys) {
            paymentCreds.add(pubKey);
          }
        }
      }
    }
    return { paymentCreds, byronAddresses };
  }
  getCollateralRequiredSignatures() {
    const collateralByronAddresses = /* @__PURE__ */ new Set();
    const collateralPaymentCreds = /* @__PURE__ */ new Set();
    for (let collateral of this.meshTxBuilderBody.collaterals) {
      if (collateral.type === "PubKey") {
        if (collateral.txIn.address) {
          const address = CstAddress.fromString(collateral.txIn.address);
          if (!address) {
            continue;
          }
          const addressDetails = address.getProps();
          const paymentCred = addressDetails.paymentPart;
          if (paymentCred?.type === CstCredentialType.KeyHash) {
            collateralPaymentCreds.add(paymentCred.hash);
          }
          if (addressDetails.type === CstAddressType.Byron) {
            collateralByronAddresses.add(collateral.txIn.address);
          }
        }
      }
    }
    return { collateralPaymentCreds, collateralByronAddresses };
  }
  getWithdrawalRequiredSignatures() {
    const withdrawalCreds = /* @__PURE__ */ new Set();
    for (let withdrawal of this.meshTxBuilderBody.withdrawals) {
      if (withdrawal.type === "PubKeyWithdrawal") {
        const address = CstAddress.fromBech32(withdrawal.address);
        const addressDetails = address.getProps();
        const paymentCred = addressDetails.paymentPart;
        if (paymentCred?.type === CstCredentialType.KeyHash) {
          withdrawalCreds.add(paymentCred.hash);
        }
      }
      if (withdrawal.type === "SimpleScriptWithdrawal") {
        const nativeScript = this.getWithdrawalNativeScript(withdrawal);
        if (nativeScript) {
          let pubKeys = this.getNativeScriptPubKeys(nativeScript);
          for (let pubKey of pubKeys) {
            withdrawalCreds.add(pubKey);
          }
        }
      }
    }
    return withdrawalCreds;
  }
  getCertificatesRequiredSignatures() {
    const certCreds = /* @__PURE__ */ new Set();
    for (let cert of this.meshTxBuilderBody.certificates) {
      if (cert.type !== "BasicCertificate" && cert.type !== "SimpleScriptCertificate") {
        continue;
      }
      const certNativeScript = this.getCertificateNativeScript(cert);
      const certType = cert.certType;
      if (certType.type === "RegisterPool") {
        certCreds.add(certType.poolParams.operator);
        for (let owner of certType.poolParams.owners) {
          certCreds.add(owner);
        }
      } else if (certType.type === "RetirePool") {
        certCreds.add(certType.poolId);
      } else if (certType.type === "DRepRegistration" || certType.type === "DRepDeregistration" || certType.type === "DRepUpdate") {
        if (cert.type === "BasicCertificate") {
          const cstDrep = coreToCstDRep(certType.drepId);
          const keyHash = cstDrep.toKeyHash();
          if (keyHash) {
            certCreds.add(keyHash);
          }
        } else if (certNativeScript) {
          let pubKeys = this.getNativeScriptPubKeys(certNativeScript);
          for (let pubKey of pubKeys) {
            certCreds.add(pubKey);
          }
        }
      } else if (certType.type === "StakeRegistrationAndDelegation" || certType.type === "VoteRegistrationAndDelegation" || certType.type === "StakeVoteRegistrationAndDelegation" || certType.type === "VoteDelegation" || certType.type === "RegisterStake" || certType.type === "StakeAndVoteDelegation" || certType.type === "DelegateStake" || certType.type === "DeregisterStake") {
        if (cert.type === "BasicCertificate") {
          const address = CstAddress.fromString(certType.stakeKeyAddress);
          if (address) {
            const addressDetails = address.getProps();
            const paymentCred = addressDetails.paymentPart;
            if (paymentCred?.type === CstCredentialType.KeyHash) {
              certCreds.add(paymentCred.hash);
            }
          }
        } else if (certNativeScript) {
          let pubKeys = this.getNativeScriptPubKeys(certNativeScript);
          for (let pubKey of pubKeys) {
            certCreds.add(pubKey);
          }
        }
      } else if (certType.type === "CommitteeHotAuth" || certType.type === "CommitteeColdResign") {
        if (cert.type === "BasicCertificate") {
          const address = CstAddress.fromString(
            certType.committeeColdKeyAddress
          );
          if (address) {
            const addressDetails = address.getProps();
            const paymentCred = addressDetails.paymentPart;
            if (paymentCred?.type === CstCredentialType.KeyHash) {
              certCreds.add(paymentCred.hash);
            }
          }
        } else if (certNativeScript) {
          let pubKeys = this.getNativeScriptPubKeys(certNativeScript);
          for (let pubKey of pubKeys) {
            certCreds.add(pubKey);
          }
        }
      }
    }
    return certCreds;
  }
  getVoteRequiredSignatures() {
    const voteCreds = /* @__PURE__ */ new Set();
    for (let vote of this.meshTxBuilderBody.votes) {
      if (vote.type === "SimpleScriptVote") {
        const nativeScript = this.getVoteNativeScript(vote);
        if (nativeScript) {
          let pubKeys = this.getNativeScriptPubKeys(nativeScript);
          for (let pubKey of pubKeys) {
            voteCreds.add(pubKey);
          }
        }
      } else if (vote.type === "BasicVote") {
        const voter = vote.vote.voter;
        if (voter.type === "DRep") {
          const drep = coreToCstDRep(voter.drepId);
          const keyHash = drep.toKeyHash();
          if (keyHash) {
            voteCreds.add(keyHash);
          }
        } else if (voter.type === "StakingPool") {
          voteCreds.add(voter.keyHash);
        } else if (voter.type === "ConstitutionalCommittee") {
          const hotCred = voter.hotCred;
          if (hotCred.type === "KeyHash") {
            voteCreds.add(hotCred.keyHash);
          }
        }
      }
    }
    return voteCreds;
  }
  getMintRequiredSignatures = () => {
    const mintCreds = /* @__PURE__ */ new Set();
    for (let mint of this.meshTxBuilderBody.mints) {
      if (mint.type === "Native") {
        const nativeScript = this.getMintNativeScript(mint);
        if (nativeScript) {
          let pubKeys = this.getNativeScriptPubKeys(nativeScript);
          for (let pubKey of pubKeys) {
            mintCreds.add(pubKey);
          }
        }
      }
    }
    return mintCreds;
  };
  getTotalWithdrawal = () => {
    let accum = 0n;
    for (let withdrawal of this.meshTxBuilderBody.withdrawals) {
      accum += BigInt(withdrawal.coin);
    }
    return accum;
  };
  getTotalDeposit = () => {
    let accum = 0n;
    for (let cert of this.meshTxBuilderBody.certificates) {
      const certType = cert.certType;
      if (certType.type === "RegisterStake") {
        if (cert.certType) {
          accum += BigInt(this._protocolParams.keyDeposit);
        }
      } else if (certType.type === "RegisterPool") {
        accum += BigInt(this._protocolParams.poolDeposit);
      } else if (certType.type === "DRepRegistration") {
        accum += BigInt(certType.coin);
      } else if (certType.type === "StakeRegistrationAndDelegation") {
        accum += BigInt(certType.coin);
      } else if (certType.type === "VoteRegistrationAndDelegation") {
        accum += BigInt(certType.coin);
      } else if (certType.type === "StakeVoteRegistrationAndDelegation") {
        accum += BigInt(certType.coin);
      }
    }
    for (let proposal of this.meshTxBuilderBody.proposals) {
      accum += BigInt(proposal.proposalType.deposit);
    }
    return accum;
  };
  getTotalRefund = () => {
    let accum = 0n;
    for (let cert of this.meshTxBuilderBody.certificates) {
      const certType = cert.certType;
      if (certType.type === "DeregisterStake") {
        if (cert.certType) {
          accum += BigInt(this._protocolParams.keyDeposit);
        }
      } else if (certType.type === "DRepDeregistration") {
        accum += BigInt(certType.coin);
      }
    }
    return accum;
  };
  getTotalMint = () => {
    const assets = /* @__PURE__ */ new Map();
    for (let mint of this.meshTxBuilderBody.mints) {
      for (let assetValue of mint.mintValue) {
        const assetId = `${mint.policyId}${assetValue.assetName}`;
        let amount = assets.get(assetId) ?? 0n;
        amount += BigInt(assetValue.amount);
        assets.set(assetId, amount);
      }
    }
    return Array.from(assets).map(([assetId, amount]) => ({
      unit: assetId,
      quantity: amount.toString()
    }));
  };
  getNativeScriptPubKeys = (nativeScript) => {
    const pubKeys = /* @__PURE__ */ new Set();
    const nativeScriptStack = [];
    nativeScriptStack.push(nativeScript);
    while (nativeScriptStack.length > 0) {
      const script = nativeScriptStack.pop();
      if (script === void 0) {
        continue;
      }
      const nOfK = script.asScriptNOfK();
      if (nOfK) {
        for (let script2 of nOfK.nativeScripts()) {
          nativeScriptStack.push(script2);
        }
      }
      const scriptAll = script.asScriptAll();
      if (scriptAll) {
        for (let script2 of scriptAll.nativeScripts()) {
          nativeScriptStack.push(script2);
        }
      }
      const scriptAny = script.asScriptAny();
      if (scriptAny) {
        for (let script2 of scriptAny.nativeScripts()) {
          nativeScriptStack.push(script2);
        }
      }
      const scriptPubkey = script.asScriptPubkey();
      if (scriptPubkey) {
        pubKeys.add(scriptPubkey.keyHash());
      }
    }
    return pubKeys;
  };
  getVoteNativeScript = (cert) => {
    if (cert.type !== "SimpleScriptVote") {
      return void 0;
    }
    const scriptSource = cert.simpleScriptSource;
    if (scriptSource === void 0) {
      return void 0;
    }
    if (scriptSource.type === "Inline") {
      return this.getInlinedNativeScript(
        scriptSource.txHash,
        scriptSource.txIndex
      );
    }
    if (scriptSource.type === "Provided") {
      return CstNativeScript.fromCbor(
        scriptSource.scriptCode
      );
    }
  };
  getCertificateNativeScript = (cert) => {
    if (cert.type !== "SimpleScriptCertificate") {
      return void 0;
    }
    const scriptSource = cert.simpleScriptSource;
    if (scriptSource === void 0) {
      return void 0;
    }
    if (scriptSource.type === "Inline") {
      return this.getInlinedNativeScript(
        scriptSource.txHash,
        scriptSource.txIndex
      );
    }
    if (scriptSource.type === "Provided") {
      return CstNativeScript.fromCbor(
        scriptSource.scriptCode
      );
    }
  };
  getMintNativeScript = (mint) => {
    if (mint.type !== "Native") {
      return void 0;
    }
    const scriptSource = mint.scriptSource;
    const scriptSourceAlternative = mint.scriptSource;
    if (scriptSource === void 0) {
      return void 0;
    }
    if (scriptSource.type === "Inline") {
      return this.getInlinedNativeScript(
        scriptSource.txHash,
        scriptSource.txIndex
      );
    }
    if (scriptSource.type === "Provided") {
      if (scriptSource.scriptCode != void 0) {
        return CstNativeScript.fromCbor(
          scriptSource.scriptCode
        );
      }
    }
    if (scriptSourceAlternative.type === "Provided") {
      if (scriptSourceAlternative.script != void 0) {
        return CstNativeScript.fromCbor(
          scriptSourceAlternative.script.code
        );
      }
    }
  };
  getWithdrawalNativeScript = (withdrawal) => {
    if (withdrawal.type !== "SimpleScriptWithdrawal") {
      return void 0;
    }
    const scriptSource = withdrawal.scriptSource;
    if (scriptSource === void 0) {
      return void 0;
    }
    if (scriptSource.type === "Inline") {
      return this.getInlinedNativeScript(
        scriptSource.txHash,
        scriptSource.txIndex
      );
    }
    if (scriptSource.type === "Provided") {
      return CstNativeScript.fromCbor(
        scriptSource.scriptCode
      );
    }
  };
  getInputNativeScript(txIn) {
    if (txIn.type !== "SimpleScript") {
      return void 0;
    }
    const scriptSource = txIn.simpleScriptTxIn.scriptSource;
    if (scriptSource === void 0) {
      return void 0;
    }
    if (scriptSource.type === "Inline") {
      return this.getInlinedNativeScript(
        scriptSource.txHash,
        scriptSource.txIndex
      );
    }
    if (scriptSource.type === "Provided") {
      return CstNativeScript.fromCbor(
        scriptSource.scriptCode
      );
    }
  }
  getInlinedNativeScript = (txHash, index) => {
    const utxos = this.queriedUTxOs[txHash];
    if (!utxos) {
      return void 0;
    }
    const utxo = utxos.find((utxo2) => utxo2.input.outputIndex === index);
    if (utxo?.output.scriptRef) {
      const script = CstScript.fromCbor(
        utxo.output.scriptRef
      );
      return script.asNative();
    }
    return void 0;
  };
  makeTxId = (txHash, index) => {
    return `${txHash}-${index}`;
  };
  getTotalReferenceInputsSize = () => {
    let accum = 0n;
    const allReferenceInputs = this.getAllReferenceInputsSizes();
    for (const [_, scriptSize] of allReferenceInputs) {
      accum += scriptSize;
    }
    return accum;
  };
  getAllReferenceInputsSizes = () => {
    const referenceInputs = /* @__PURE__ */ new Map();
    const bodyReferenceInputs = this.getBodyReferenceInputsSizes();
    for (const [txId, scriptSize] of bodyReferenceInputs) {
      referenceInputs.set(txId, scriptSize);
    }
    const inputsReferenceInputs = this.getInputsReferenceInputsSizes();
    for (const [txId, scriptSize] of inputsReferenceInputs) {
      referenceInputs.set(txId, scriptSize);
    }
    const mintsReferenceInputs = this.getMintsReferenceInputsSizes();
    for (const [txId, scriptSize] of mintsReferenceInputs) {
      referenceInputs.set(txId, scriptSize);
    }
    const withdrawalsReferenceInputs = this.getWithdrawalsReferenceInputsSizes();
    for (const [txId, scriptSize] of withdrawalsReferenceInputs) {
      referenceInputs.set(txId, scriptSize);
    }
    const votesReferenceInputs = this.getVotesReferenceInputsSizes();
    for (const [txId, scriptSize] of votesReferenceInputs) {
      referenceInputs.set(txId, scriptSize);
    }
    const certificatesReferenceInputs = this.getCertificatesReferenceInputsSizes();
    for (const [txId, scriptSize] of certificatesReferenceInputs) {
      referenceInputs.set(txId, scriptSize);
    }
    return referenceInputs;
  };
  getBodyReferenceInputsSizes = () => {
    const referenceInputs = [];
    for (const refTxIn of this.meshTxBuilderBody.referenceInputs) {
      referenceInputs.push([
        this.makeTxId(refTxIn.txHash, refTxIn.txIndex),
        BigInt(refTxIn.scriptSize ?? 0)
      ]);
    }
    return referenceInputs;
  };
  getInputsReferenceInputsSizes = () => {
    const referenceInputs = [];
    for (const input of this.meshTxBuilderBody.inputs) {
      if (input.type === "Script") {
        const scriptSource = input.scriptTxIn.scriptSource;
        if (scriptSource?.type === "Inline") {
          referenceInputs.push([
            this.makeTxId(scriptSource.txHash, scriptSource.txIndex),
            BigInt(scriptSource.scriptSize ?? 0)
          ]);
        }
      } else if (input.type === "SimpleScript") {
        const scriptSource = input.simpleScriptTxIn.scriptSource;
        if (scriptSource?.type === "Inline") {
          referenceInputs.push([
            this.makeTxId(scriptSource.txHash, scriptSource.txIndex),
            BigInt(scriptSource.scriptSize ?? 0)
          ]);
        }
      }
    }
    return referenceInputs;
  };
  getMintsReferenceInputsSizes = () => {
    const referenceInputs = [];
    for (const mint of this.meshTxBuilderBody.mints) {
      if (mint.type === "Plutus" || mint.type === "Native") {
        const scriptSource = mint.scriptSource;
        if (scriptSource?.type == "Inline") {
          referenceInputs.push([
            this.makeTxId(scriptSource.txHash, scriptSource.txIndex),
            BigInt(scriptSource.scriptSize ?? 0)
          ]);
        }
      }
    }
    return referenceInputs;
  };
  getWithdrawalsReferenceInputsSizes = () => {
    const referenceInputs = [];
    for (const withdrawal of this.meshTxBuilderBody.withdrawals) {
      if (withdrawal.type === "SimpleScriptWithdrawal" || withdrawal.type === "ScriptWithdrawal") {
        const scriptSource = withdrawal.scriptSource;
        if (scriptSource?.type === "Inline") {
          referenceInputs.push([
            this.makeTxId(scriptSource.txHash, scriptSource.txIndex),
            BigInt(scriptSource.scriptSize ?? 0)
          ]);
        }
      }
    }
    return referenceInputs;
  };
  getVotesReferenceInputsSizes = () => {
    const referenceInputs = [];
    for (const vote of this.meshTxBuilderBody.votes) {
      if (vote.type === "SimpleScriptVote") {
        const scriptSource = vote.simpleScriptSource;
        if (scriptSource?.type === "Inline") {
          referenceInputs.push([
            this.makeTxId(scriptSource.txHash, scriptSource.txIndex),
            BigInt(scriptSource.scriptSize ?? 0)
          ]);
        }
      } else if (vote.type === "ScriptVote") {
        const scriptSource = vote.scriptSource;
        if (scriptSource?.type === "Inline") {
          referenceInputs.push([
            this.makeTxId(scriptSource.txHash, scriptSource.txIndex),
            BigInt(scriptSource.scriptSize ?? 0)
          ]);
        }
      }
    }
    return referenceInputs;
  };
  getCertificatesReferenceInputsSizes = () => {
    const referenceInputs = [];
    for (const cert of this.meshTxBuilderBody.certificates) {
      if (cert.type === "SimpleScriptCertificate") {
        const scriptSource = cert.simpleScriptSource;
        if (scriptSource?.type === "Inline") {
          referenceInputs.push([
            this.makeTxId(scriptSource.txHash, scriptSource.txIndex),
            BigInt(scriptSource.scriptSize ?? 0)
          ]);
        }
      } else if (cert.type === "ScriptCertificate") {
        const scriptSource = cert.scriptSource;
        if (scriptSource?.type === "Inline") {
          referenceInputs.push([
            this.makeTxId(scriptSource.txHash, scriptSource.txIndex),
            BigInt(scriptSource.scriptSize ?? 0)
          ]);
        }
      }
    }
    return referenceInputs;
  };
  getTotalExecutionUnits = () => {
    let memUnits = 0n;
    let stepUnits = 0n;
    for (let input of this.meshTxBuilderBody.inputs) {
      if (input.type === "Script" && input.scriptTxIn.redeemer) {
        memUnits += BigInt(input.scriptTxIn.redeemer.exUnits.mem);
        stepUnits += BigInt(input.scriptTxIn.redeemer.exUnits.steps);
      }
    }
    for (let mint of this.meshTxBuilderBody.mints) {
      if (mint.type === "Plutus" && mint.redeemer) {
        memUnits += BigInt(mint.redeemer.exUnits.mem);
        stepUnits += BigInt(mint.redeemer.exUnits.steps);
      }
    }
    for (let cert of this.meshTxBuilderBody.certificates) {
      if (cert.type === "ScriptCertificate" && cert.redeemer) {
        memUnits += BigInt(cert.redeemer.exUnits.mem);
        stepUnits += BigInt(cert.redeemer.exUnits.steps);
      }
    }
    for (let withdrawal of this.meshTxBuilderBody.withdrawals) {
      if (withdrawal.type === "ScriptWithdrawal" && withdrawal.redeemer) {
        memUnits += BigInt(withdrawal.redeemer.exUnits.mem);
        stepUnits += BigInt(withdrawal.redeemer.exUnits.steps);
      }
    }
    for (let vote of this.meshTxBuilderBody.votes) {
      if (vote.type === "ScriptVote" && vote.redeemer) {
        memUnits += BigInt(vote.redeemer.exUnits.mem);
        stepUnits += BigInt(vote.redeemer.exUnits.steps);
      }
    }
    memUnits = BigInt(
      new bignumber_default(memUnits).integerValue(bignumber_default.ROUND_CEIL).toString()
    );
    stepUnits = BigInt(
      new bignumber_default(stepUnits).integerValue(bignumber_default.ROUND_CEIL).toString()
    );
    return {
      memUnits,
      stepUnits
    };
  };
  getSerializedSize = () => {
    return this.serializeMockTx().length / 2;
  };
  getActualFee = () => {
    if (this.manualFee) {
      return BigInt(this.manualFee);
    } else {
      return this.calculateFee();
    }
  };
  calculateFee = () => {
    const txSize = this.getSerializedSize();
    return this.calculateFeeForSerializedTx(txSize);
  };
  calculateFeeForSerializedTx = (txSize) => {
    const refScriptFee = this.calculateRefScriptFee();
    const redeemersFee = this.calculateRedeemersFee();
    const minFeeCoeff = BigInt(this._protocolParams.minFeeA);
    const minFeeConstant = BigInt(this._protocolParams.minFeeB);
    const minFee = minFeeCoeff * BigInt(txSize) + minFeeConstant;
    return minFee + refScriptFee + redeemersFee;
  };
  calculateRefScriptFee = () => {
    const refSize = this.getTotalReferenceInputsSize();
    const refScriptFee = this._protocolParams.minFeeRefScriptCostPerByte;
    return minRefScriptFee(refSize, refScriptFee);
  };
  calculateRedeemersFee = () => {
    const { memUnits, stepUnits } = this.getTotalExecutionUnits();
    const stepPrice = bignumber_default(this._protocolParams.priceStep);
    const memPrice = bignumber_default(this._protocolParams.priceMem);
    const stepFee = stepPrice.multipliedBy(bignumber_default(stepUnits.toString()));
    const memFee = memPrice.multipliedBy(bignumber_default(memUnits.toString()));
    return BigInt(
      stepFee.plus(memFee).integerValue(bignumber_default.ROUND_CEIL).toString()
    );
  };
  calculateMinLovelaceForOutput = (output) => {
    return getOutputMinLovelace(output, this._protocolParams.coinsPerUtxoSize);
  };
  clone() {
    const newBuilder = super._cloneCore(() => {
      return new _MeshTxBuilder({
        serializer: this.serializer,
        fetcher: this.fetcher,
        submitter: this.submitter,
        evaluator: this.evaluator,
        verbose: this.verbose,
        params: { ...this._protocolParams }
      });
    });
    newBuilder.txHex = this.txHex;
    newBuilder.queriedTxHashes = structuredClone(this.queriedTxHashes);
    newBuilder.queriedUTxOs = structuredClone(this.queriedUTxOs);
    newBuilder.utxosWithRefScripts = structuredClone(this.utxosWithRefScripts);
    return newBuilder;
  }
};
function minRefScriptFee(totalRefScriptsSize, refScriptCoinsPerByte) {
  const multiplier = new bignumber_default(12).dividedBy(new bignumber_default(10));
  const sizeIncrement = new bignumber_default(25600);
  const baseFee = new bignumber_default(refScriptCoinsPerByte);
  const totalSize = new bignumber_default(totalRefScriptsSize.toString());
  return tierRefScriptFee(multiplier, sizeIncrement, baseFee, totalSize);
}
function tierRefScriptFee(multiplier, sizeIncrement, baseFee, totalSize) {
  if (multiplier.lte(0) || sizeIncrement.eq(0)) {
    throw new Error("Size increment and multiplier must be positive");
  }
  const fullTiers = totalSize.dividedToIntegerBy(sizeIncrement);
  const partialTierSize = totalSize.mod(sizeIncrement);
  const tierPrice = baseFee.multipliedBy(sizeIncrement);
  let acc = new bignumber_default(0);
  const one = new bignumber_default(1);
  if (fullTiers.gt(0)) {
    const multiplierPow = multiplier.pow(fullTiers.toNumber());
    const progressionEnumerator = one.minus(multiplierPow);
    const progressionDenom = one.minus(multiplier);
    const tierProgressionSum = progressionEnumerator.dividedBy(progressionDenom);
    acc = acc.plus(tierPrice.multipliedBy(tierProgressionSum));
  }
  if (partialTierSize.gt(0)) {
    const multiplierPow = multiplier.pow(fullTiers.toNumber());
    const lastTierPrice = baseFee.multipliedBy(multiplierPow);
    const partialTierFee = lastTierPrice.multipliedBy(partialTierSize);
    acc = acc.plus(partialTierFee);
  }
  return BigInt(acc.integerValue(bignumber_default.ROUND_FLOOR).toString());
}
var cloneOutput = (output) => {
  return JSONBig3.parse(JSONBig3.stringify(output));
};
var setLoveLace = (output, lovelace) => {
  let lovelaceSet = false;
  for (let asset of output.amount) {
    if (asset.unit === "lovelace") {
      asset.quantity = lovelace.toString();
      lovelaceSet = true;
      break;
    }
  }
  if (!lovelaceSet) {
    output.amount.push({
      unit: "lovelace",
      quantity: lovelace.toString()
    });
  }
  return output;
};
var getLovelace = (output) => {
  for (let asset of output.amount) {
    if (asset.unit === "lovelace" || asset.unit === "") {
      return BigInt(asset.quantity);
    }
  }
  return 0n;
};
var getOutputMinLovelace = (output, coinsPerUtxoSize = DEFAULT_PROTOCOL_PARAMETERS3.coinsPerUtxoSize) => {
  const serializer = new CardanoSDKSerializer();
  let currentOutput = cloneOutput(output);
  let lovelace = getLovelace(currentOutput);
  let minLovelace = 0n;
  for (let i = 0; i < 3; i++) {
    const txOutSize = BigInt(
      serializer.serializeOutput(currentOutput).length / 2
    );
    const txOutByteCost = BigInt(coinsPerUtxoSize);
    const totalOutCost = (160n + BigInt(txOutSize)) * txOutByteCost;
    minLovelace = totalOutCost;
    if (lovelace < totalOutCost) {
      lovelace = totalOutCost;
    } else {
      break;
    }
    currentOutput = setLoveLace(currentOutput, lovelace);
  }
  return minLovelace;
};

// src/scripts/forge.script.ts
import {
  buildScriptPubkey,
  deserializeEd25519KeyHash,
  resolvePaymentKeyHash,
  toNativeScript
} from "@meshsdk/core-cst";
var ForgeScript = class {
  static withOneSignature(address) {
    const keyHash = deserializeEd25519KeyHash(resolvePaymentKeyHash(address));
    return buildScriptPubkey(keyHash).toCbor();
  }
  // static withAtLeastNSignatures(
  //   addresses: string[], minimumRequired: number,
  // ): string {
  //   const nativeScripts = csl.NativeScripts.new();
  //   addresses.forEach((address) => {
  //     const keyHash = deserializeEd25519KeyHash(
  //       resolvePaymentKeyHash(address),
  //     );
  //     nativeScripts.add(buildScriptPubkey(keyHash));
  //   });
  //   const scriptNOfK = csl.ScriptNOfK.new(minimumRequired, nativeScripts);
  //   return csl.NativeScript.new_script_any(scriptNOfK).to_hex();
  // }
  // static withAnySignature(addresses: string[]): string {
  //   const nativeScripts = csl.NativeScripts.new();
  //   addresses.forEach((address) => {
  //     const keyHash = deserializeEd25519KeyHash(
  //       resolvePaymentKeyHash(address),
  //     );
  //     nativeScripts.add(buildScriptPubkey(keyHash));
  //   });
  //   const scriptAny = csl.ScriptAny.new(nativeScripts);
  //   return csl.NativeScript.new_script_any(scriptAny).to_hex();
  // }
  // static withAllSignatures(addresses: string[]): string {
  //   const nativeScripts = csl.NativeScripts.new();
  //   addresses.forEach((address) => {
  //     const keyHash = deserializeEd25519KeyHash(
  //       resolvePaymentKeyHash(address),
  //     );
  //     nativeScripts.add(buildScriptPubkey(keyHash));
  //   });
  //   const scriptAll = csl.ScriptAll.new(nativeScripts);
  //   return csl.NativeScript.new_script_any(scriptAll).to_hex();
  // }
  static fromNativeScript(script) {
    return toNativeScript(script).toCbor();
  }
};

// src/transaction/index.ts
import {
  CIP68_100,
  CIP68_222,
  DEFAULT_REDEEMER_BUDGET as DEFAULT_REDEEMER_BUDGET2,
  hexToString,
  metadataToCip68,
  POLICY_ID_LENGTH,
  stringToHex,
  SUPPORTED_TOKENS
} from "@meshsdk/common";
import {
  Cardano,
  CardanoSDKUtil as CardanoSDKUtil2,
  deserializeNativeScript,
  deserializePlutusScript,
  deserializeTx,
  fromScriptRef,
  Serialization as Serialization2,
  Transaction as Tx
} from "@meshsdk/core-cst";
var Transaction = class {
  txBuilder;
  initiator;
  isCollateralNeeded = false;
  constructor(options) {
    this.txBuilder = new MeshTxBuilder(options);
    this.initiator = options.initiator;
  }
  static attachMetadata(cborTx, cborTxMetadata) {
    const tx = deserializeTx(cborTx);
    const txAuxData = tx.auxiliaryData() ?? new Serialization2.AuxiliaryData();
    txAuxData.setMetadata(
      Serialization2.GeneralTransactionMetadata.fromCbor(
        CardanoSDKUtil2.HexBlob(cborTxMetadata)
      )
    );
    if (Cardano.computeAuxiliaryDataHash(txAuxData.toCore())?.toString() !== tx.body().auxiliaryDataHash()?.toString()) {
      throw new Error(
        "[Transaction] attachMetadata: The metadata hash does not match the auxiliary data hash."
      );
    }
    return new Tx(tx.body(), tx.witnessSet(), txAuxData).toCbor().toString();
  }
  static deattachMetadata(cborTx) {
    const tx = deserializeTx(cborTx);
    return new Tx(tx.body(), tx.witnessSet()).toCbor().toString();
  }
  static maskMetadata(cborTx) {
    const tx = deserializeTx(cborTx);
    const txMetadata = tx.auxiliaryData()?.metadata();
    if (txMetadata !== void 0) {
      const mockMetadata = /* @__PURE__ */ new Map();
      txMetadata.metadata()?.forEach(
        (metadatum, label) => mockMetadata.set(label, mask(metadatum))
      );
      const txAuxData = tx.auxiliaryData();
      txMetadata.setMetadata(mockMetadata);
      txAuxData?.setMetadata(txMetadata);
      return new Tx(tx.body(), tx.witnessSet(), txAuxData).toCbor().toString();
    }
    return cborTx;
  }
  static readMetadata(cborTx) {
    const tx = deserializeTx(cborTx);
    return tx.auxiliaryData()?.metadata()?.toCbor().toString() ?? "";
  }
  static writeMetadata(cborTx, cborTxMetadata) {
    const tx = deserializeTx(cborTx);
    const txAuxData = tx.auxiliaryData() ?? new Serialization2.AuxiliaryData();
    txAuxData.setMetadata(
      Serialization2.GeneralTransactionMetadata.fromCbor(
        CardanoSDKUtil2.HexBlob(cborTxMetadata)
      )
    );
    return new Tx(tx.body(), tx.witnessSet(), txAuxData).toCbor().toString();
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   *
   * @param recipient The recipient of the output.
   * @param assets The assets to send. Provide string for lovelace and Asset[] for tokens and/or lovelace.
   * @returns The transaction builder.
   * @see {@link https://meshjs.dev/apis/transaction#sendAssets}
   */
  sendAssets(recipient, assets) {
    if (typeof assets === "string") {
      assets = [
        {
          unit: "lovelace",
          quantity: assets
        }
      ];
    }
    if (typeof recipient === "string") {
      this.txBuilder.txOut(recipient, assets);
    }
    if (typeof recipient === "object") {
      this.txBuilder.txOut(recipient.address, assets);
      if (recipient.datum) {
        if (recipient.datum.inline) {
          this.txBuilder.txOutInlineDatumValue(recipient.datum.value);
        } else {
          this.txBuilder.txOutDatumHashValue(recipient.datum.value);
        }
      }
    }
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   *
   * Use sendAssets instead:
   * ```ts
   * this.sendAssets(recipient, lovelace);
   * ```
   *
   * Deprecation reason - Unnecessary implementation which might cause confusion.
   *
   * @param {Recipient} recipient The recipient of the transaction.
   * @param {string} lovelace The amount of lovelace to send.
   * @returns {Transaction} The Transaction object.
   * @see {@link https://meshjs.dev/apis/transaction#sendAda}
   */
  sendLovelace(recipient, lovelace) {
    return this.sendAssets(recipient, lovelace);
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   *
   * Please use sendAssets with helper function to obtain token unit instead:
   * ```ts
   * const assets = [{ unit: SUPPORTED_TOKENS.GIMBAL, quantity: "100" }]
   * transaction.sendAssets(recipient, assets)
   * ```
   *
   * Deprecation reason - Required maintenance on tokens.
   *
   * @param {Recipient} recipient The recipient of the transaction.
   * @param {Token} ticker The ticker of the token to send.
   * @param {string} amount The amount of the token to send.
   * @returns {Transaction} The Transaction object.
   * @see {@link https://meshjs.dev/apis/transaction#sendToken}
   */
  sendToken(recipient, ticker, amount) {
    const assets = [{ unit: SUPPORTED_TOKENS[ticker], quantity: amount }];
    return this.sendAssets(recipient, assets);
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   *
   * ```ts
   * const assets = value.output.amount;
   * this.sendAssets(recipient, assets);
   * ```
   * Deprecation reason - Unnecessary implementation which might cause confusion.
   *
   * @param {Recipient} recipient The recipient of the output.
   * @param {UTxO} value The UTxO value of the output.
   * @returns {Transaction} The Transaction object.
   */
  sendValue(recipient, value) {
    const assets = value.output.amount;
    return this.sendAssets(recipient, assets);
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   *
   * @param {UTxO[]} inputs The inputs to set.
   * @returns {Transaction} The transaction.
   */
  setTxInputs(inputs) {
    inputs.forEach((input) => {
      this.txBuilder.txIn(
        input.input.txHash,
        input.input.outputIndex,
        input.output.amount,
        input.output.address,
        input.output.scriptRef ? input.output.scriptRef.length / 2 : 0
      );
    });
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   *
   * @param {UTxO[]} inputs The reference inputs to set.
   * @returns {Transaction} The transaction.
   */
  setTxRefInputs(inputs) {
    inputs.forEach((input) => {
      this.txBuilder.readOnlyTxInReference(
        input.input.txHash,
        input.input.outputIndex
      );
    });
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   *
   * Sets the native script for the transaction.
   * @param {NativeScript} script The native script to spend from.
   * @param {UTxO} utxo The UTxO attached to the script.
   * @returns {Transaction} The Transaction object.
   */
  setNativeScriptInput(script, utxo) {
    const { scriptCbor } = this.txBuilder.serializer.deserializer.script.deserializeNativeScript(
      script
    );
    this.txBuilder.txIn(
      utxo.input.txHash,
      utxo.input.outputIndex,
      utxo.output.amount,
      utxo.output.address
    ).txInScript(scriptCbor);
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   */
  // TODO: nuke this probably as the input type is too confusing
  redeemValue(options) {
    const { value, script, datum, redeemer } = options;
    const red = redeemer || {
      data: { alternative: 0, fields: ["mesh"] },
      budget: DEFAULT_REDEEMER_BUDGET2
    };
    if ("code" in script) {
      this.isCollateralNeeded = true;
      this.spendingPlutusScript(script).txIn(
        value.input.txHash,
        value.input.outputIndex,
        value.output.amount,
        value.output.address,
        value.output.scriptRef ? value.output.scriptRef.length / 2 : 0
      ).txInScript(script.code).txInRedeemerValue(red.data, "Mesh", red.budget);
    }
    if ("output" in script) {
      if (!script.output.scriptRef) {
        throw new Error("redeemValue: No script reference found in UTxO");
      }
      const scriptRef = fromScriptRef(script.output.scriptRef);
      if (!scriptRef || !("code" in scriptRef)) {
        throw new Error("redeemValue: Script reference not found");
      }
      this.isCollateralNeeded = true;
      this.spendingPlutusScript(scriptRef).txIn(
        value.input.txHash,
        value.input.outputIndex,
        value.output.amount,
        value.output.address
      ).spendingTxInReference(
        script.input.txHash,
        script.input.outputIndex,
        (script.output.scriptRef.length / 2).toString(),
        script.output.scriptHash
      ).txInRedeemerValue(red.data, "Mesh", red.budget);
    }
    if (datum) {
      this.txBuilder.txInDatumValue(datum);
    } else {
      this.txBuilder.txInInlineDatumPresent();
    }
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   */
  mintAsset(forgeScript, mint, redeemer) {
    const assetQuantity = mint.assetQuantity;
    let assetNameHex = stringToHex(mint.assetName);
    const referenceAssetNameHex = CIP68_100(assetNameHex);
    if (mint.cip68ScriptAddress) {
      assetNameHex = CIP68_222(assetNameHex);
    }
    let policyId = "";
    switch (typeof forgeScript) {
      case "string":
        policyId = deserializeNativeScript(forgeScript).hash().toString();
        this.txBuilder.mint(assetQuantity, policyId, assetNameHex).mintingScript(forgeScript);
        if (mint.cip68ScriptAddress) {
          this.txBuilder.mint(assetQuantity, policyId, referenceAssetNameHex).mintingScript(forgeScript);
        }
        break;
      case "object":
        if (!redeemer)
          throw new Error(
            "burnAsset: Redeemer data is required for Plutus minting"
          );
        if ("code" in forgeScript) {
          policyId = deserializePlutusScript(
            forgeScript.code,
            forgeScript.version
          ).hash().toString();
          this.isCollateralNeeded = true;
          this.mintPlutusScript(forgeScript).mint(assetQuantity, policyId, assetNameHex).mintingScript(forgeScript.code).mintRedeemerValue(redeemer.data, "Mesh", redeemer.budget);
          if (mint.cip68ScriptAddress) {
            this.mintPlutusScript(forgeScript).mint(assetQuantity, policyId, referenceAssetNameHex).mintingScript(forgeScript.code).mintRedeemerValue(redeemer.data, "Mesh", redeemer.budget);
          }
          break;
        }
        if ("output" in forgeScript) {
          if (!forgeScript.output.scriptRef) {
            throw new Error("mintAsset: No script reference found in UTxO");
          }
          const script = fromScriptRef(forgeScript.output.scriptRef);
          if (!script) {
            throw new Error("mintAsset: Script reference not found");
          }
          if ("code" in script) {
            policyId = deserializePlutusScript(script.code, script.version).hash().toString();
            this.isCollateralNeeded = true;
            this.mintPlutusScript(script).mint(assetQuantity, policyId, assetNameHex).mintTxInReference(
              forgeScript.input.txHash,
              forgeScript.input.outputIndex,
              (forgeScript.output.scriptRef.length / 2).toString(),
              forgeScript.output.scriptHash
            ).mintRedeemerValue(redeemer.data, "Mesh", redeemer.budget);
            if (mint.cip68ScriptAddress) {
              this.mintPlutusScript(script).mint(assetQuantity, policyId, referenceAssetNameHex).mintTxInReference(
                forgeScript.input.txHash,
                forgeScript.input.outputIndex,
                (forgeScript.output.scriptRef.length / 2).toString(),
                forgeScript.output.scriptHash
              ).mintRedeemerValue(redeemer.data, "Mesh", redeemer.budget);
              break;
            }
            break;
          } else {
            throw new Error(
              "mintAsset: Reference script minting not implemented"
            );
          }
        }
        break;
    }
    if (mint.recipient) {
      this.sendAssets(mint.recipient, [
        { unit: policyId + assetNameHex, quantity: mint.assetQuantity }
      ]);
    }
    if (mint.cip68ScriptAddress) {
      this.sendAssets(
        {
          address: mint.cip68ScriptAddress,
          datum: { inline: true, value: metadataToCip68(mint.metadata) }
        },
        [
          {
            unit: policyId + referenceAssetNameHex,
            quantity: mint.assetQuantity
          }
        ]
      );
    }
    if (!mint.cip68ScriptAddress && mint.metadata && mint.label) {
      if (mint.label === "721" || mint.label === "20") {
        let currentMetadata = this.txBuilder.meshTxBuilderBody.metadata;
        if (currentMetadata.get(BigInt(mint.label)) === void 0) {
          this.setMetadata(Number(mint.label), {
            [policyId]: { [mint.assetName]: mint.metadata }
          });
        } else {
          let metadataMap = metadataObjToMap({
            [policyId]: { [mint.assetName]: mint.metadata }
          });
          let newMetadata = mergeContents(
            currentMetadata.get(BigInt(mint.label)),
            metadataMap,
            mint.label === "721" ? 2 : 0
          );
          this.setMetadata(Number(mint.label), newMetadata);
        }
      } else {
        this.setMetadata(Number(mint.label), mint.metadata);
      }
    }
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   */
  burnAsset(forgeScript, asset, redeemer) {
    const assetQuantity = "-" + asset.quantity;
    const mint = {
      assetName: hexToString(asset.unit.slice(POLICY_ID_LENGTH)),
      assetQuantity
    };
    try {
      this.mintAsset(forgeScript, mint, redeemer);
    } catch (error) {
      throw new Error("burnAsset: " + error);
    }
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   *
   * Sets the change address for the transaction.
   *
   * @param {string} changeAddress The change address.
   * @returns {Transaction} The Transaction object.
   */
  setChangeAddress(changeAddress) {
    this.txBuilder.changeAddress(changeAddress);
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   *
   * Sets the collateral for the transaction.
   *
   * @param {UTxO[]} collateral - Set the UTxO for collateral.
   * @returns {Transaction} The Transaction object.
   */
  setCollateral(collateral) {
    collateral.forEach((collateralUtxo) => {
      this.txBuilder.txInCollateral(
        collateralUtxo.input.txHash,
        collateralUtxo.input.outputIndex,
        collateralUtxo.output.amount,
        collateralUtxo.output.address
      );
    });
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   *
   * Sets the network to use, this is mainly to know the cost models to be used to calculate script integrity hash
   * @param network The specific network this transaction is being built for ("testnet" | "preview" | "preprod" | "mainnet")
   * @returns The Transaction object.
   */
  setNetwork = (network) => {
    this.txBuilder.setNetwork(network);
    return this;
  };
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   *
   * Sets the required signers for the transaction.
   *
   * @param {string[]} addresses The addresses of the required signers.
   * @returns {Transaction} The Transaction object.
   */
  setRequiredSigners(addresses) {
    addresses.forEach((address) => {
      const { pubKeyHash } = this.txBuilder.serializer.deserializer.key.deserializeAddress(address);
      this.txBuilder.requiredSignerHash(pubKeyHash);
    });
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   *
   *  Set the time to live for the transaction.
   *
   * @param {string} slot The slot number to expire the transaction at.
   * @returns {Transaction} The Transaction object.
   * @see {@link https://meshjs.dev/apis/transaction#setTimeLimit}
   */
  setTimeToExpire(slot) {
    this.txBuilder.invalidHereafter(Number(slot));
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   *
   *  Sets the start slot for the transaction.
   *
   * @param {string} slot The start slot for the transaction.
   * @returns {Transaction} The Transaction object.
   * @see {@link https://meshjs.dev/apis/transaction#setTimeLimit}
   */
  setTimeToStart(slot) {
    this.txBuilder.invalidBefore(Number(slot));
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   *
   *  Add a JSON metadata entry to the transaction.
   *
   * @param {number} label The label to use for the metadata entry.
   * @param {unknown} metadata The value to use for the metadata entry.
   * @returns {Transaction} The Transaction object.
   * @see {@link https://meshjs.dev/apis/transaction#setMetadata}
   */
  setMetadata(label, metadata) {
    this.txBuilder.metadataValue(label, metadata);
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   */
  withdrawRewards(rewardAddress, lovelace) {
    this.txBuilder.withdrawal(rewardAddress, lovelace);
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   */
  delegateStake(rewardAddress, poolId) {
    this.txBuilder.delegateStakeCertificate(
      rewardAddress,
      this.txBuilder.serializer.deserializer.cert.deserializePoolId(poolId)
    );
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   */
  deregisterStake(rewardAddress) {
    this.txBuilder.deregisterStakeCertificate(rewardAddress);
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   */
  registerStake(rewardAddress) {
    this.txBuilder.registerStakeCertificate(rewardAddress);
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   */
  registerPool(params) {
    this.txBuilder.registerPoolCertificate(params);
    return this;
  }
  /**
   * [Deprecated] - `Transaction` class is on planning for V2.
   * Use `MeshTxBuilder` instead for tx-building for now.
   */
  retirePool(poolId, epochNo) {
    this.txBuilder.retirePoolCertificate(poolId, epochNo);
    return this;
  }
  async build(balanced = true) {
    try {
      await this.addCollateralIfNeeded();
      await this.addTxInputsAsNeeded();
      await this.addChangeAddress();
      if (balanced) {
        return this.txBuilder.complete();
      } else {
        return this.txBuilder.completeUnbalanced();
      }
    } catch (error) {
      throw new Error(
        `[Transaction] An error occurred during build: ${error}.`
      );
    }
  }
  mintPlutusScript(script) {
    switch (script.version) {
      case "V1":
        this.txBuilder.mintPlutusScriptV1();
        break;
      case "V2":
        this.txBuilder.mintPlutusScriptV2();
        break;
      case "V3":
        this.txBuilder.mintPlutusScriptV3();
        break;
    }
    return this.txBuilder;
  }
  spendingPlutusScript(script) {
    switch (script.version) {
      case "V1":
        this.txBuilder.spendingPlutusScriptV1();
        break;
      case "V2":
        this.txBuilder.spendingPlutusScriptV2();
        break;
      case "V3":
        this.txBuilder.spendingPlutusScriptV3();
        break;
    }
    return this.txBuilder;
  }
  async addCollateralIfNeeded() {
    if (this.isCollateralNeeded) {
      const collaterals = await this.initiator.getCollateral();
      if (collaterals.length > 0) {
        this.setCollateral(collaterals);
        return;
      }
      const utxos = await this.initiator.getUtxos();
      const pureLovelaceUtxos = utxos.filter(
        (utxo) => utxo.output.amount.length === 1
      );
      pureLovelaceUtxos.sort((a, b) => {
        return Number(a.output.amount[0]?.quantity) - Number(a.output.amount[0]?.quantity);
      });
      for (const utxo of pureLovelaceUtxos) {
        if (Number(utxo.output.amount[0]?.quantity) >= 5e6) {
          return [utxo];
        }
      }
      if (pureLovelaceUtxos.length === 0) {
        throw new Error("No pure lovelace utxos found for collateral");
      }
      this.setCollateral([pureLovelaceUtxos[0]]);
    }
  }
  async addTxInputsAsNeeded() {
    if (this.txBuilder.meshTxBuilderBody.extraInputs.length === 0) {
      const utxos = await this.initiator.getUtxos();
      this.txBuilder.selectUtxosFrom(utxos);
    }
  }
  async addChangeAddress() {
    if (this.txBuilder.meshTxBuilderBody.changeAddress === "") {
      const changeAddress = await this.initiator.getChangeAddress();
      this.setChangeAddress(changeAddress);
    }
  }
};
function mask(metadatum) {
  switch (metadatum.getKind()) {
    case Serialization2.TransactionMetadatumKind.Text:
      return Serialization2.TransactionMetadatum.newText(
        "0".repeat(metadatum.asText()?.length ?? 0)
      );
    case Serialization2.TransactionMetadatumKind.Bytes:
    case Serialization2.TransactionMetadatumKind.Integer:
      return metadatum;
    case Serialization2.TransactionMetadatumKind.List:
      const list = new Serialization2.MetadatumList();
      for (let i = 0; i < (metadatum.asList()?.getLength() ?? 0); i++) {
        list.add(mask(metadatum.asList()?.get(i)));
      }
      return Serialization2.TransactionMetadatum.newList(list);
    case Serialization2.TransactionMetadatumKind.Map:
      const map = new Serialization2.MetadatumMap();
      for (let i = 0; i < (metadatum.asMap()?.getLength() ?? 0); i++) {
        const key = metadatum.asMap()?.getKeys().get(i);
        const value = metadatum.asMap()?.get(key);
        map.insert(key, mask(value));
      }
      return Serialization2.TransactionMetadatum.newMap(map);
    default:
      throw new Error(`Unsupported metadatum kind: ${metadatum.getKind()}`);
  }
}

// src/tx-parser/index.ts
var TxParser = class {
  constructor(serializer, fetcher) {
    this.serializer = serializer;
    this.fetcher = fetcher;
  }
  parse = async (txHex, providedUtxos = []) => {
    const resolvedUtxos = [...providedUtxos];
    const resolvedUtxosSet = new Set(
      providedUtxos.map(
        (utxo) => `${utxo.input.txHash}#${utxo.input.outputIndex}`
      )
    );
    const toResolveUtxos = {};
    const fetchResult = {};
    this.serializer.parser.getRequiredInputs(txHex).forEach((input) => {
      if (!resolvedUtxosSet.has(`${input.txHash}#${input.outputIndex}`)) {
        if (!toResolveUtxos[input.txHash]) {
          toResolveUtxos[input.txHash] = [];
        }
        toResolveUtxos[input.txHash].push(input.outputIndex);
      }
    });
    for (const txHash in toResolveUtxos) {
      const outputIndices = toResolveUtxos[txHash];
      if (!this.fetcher) {
        throw new Error(
          "Fetcher is not provided. Cannot resolve UTxOs without fetcher."
        );
      }
      const utxos = await this.fetcher.fetchUTxOs(txHash);
      outputIndices?.forEach((outputIndex) => {
        const utxoData = utxos.find(
          (utxo) => utxo.input.outputIndex === outputIndex
        );
        if (!utxoData) {
          throw new Error(`UTxO not found: ${txHash}:${outputIndex}`);
        }
        resolvedUtxos.push(utxoData);
      });
    }
    this.serializer.parser.parse(txHex, resolvedUtxos);
    return this.serializer.parser.getBuilderBody();
  };
  getBuilderBody = () => this.serializer.parser.getBuilderBody();
  getBuilderBodyWithoutChange = () => this.serializer.parser.getBuilderBodyWithoutChange();
  toTester = () => this.serializer.parser.toTester();
};
export {
  ForgeScript,
  LargestFirstInputSelector,
  MeshTxBuilder,
  Transaction,
  TxParser,
  cloneOutput,
  getLovelace,
  getOutputMinLovelace,
  getUtxoMinLovelace,
  mergeContents,
  metadataObjToMap,
  setLoveLace,
  utxoToTxIn
};
