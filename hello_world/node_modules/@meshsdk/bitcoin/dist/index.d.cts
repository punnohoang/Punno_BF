import * as ecpair from 'ecpair';
import * as _bip32 from 'bip32';
import * as bitcoin from 'bitcoinjs-lib';
export { bitcoin };
import * as bip39 from 'bip39';
export { bip39 };

declare const bip32: _bip32.BIP32API;
declare const ECPair: ecpair.ECPairAPI;

interface IBitcoinWallet {
    getChangeAddress(): Promise<string>;
    getNetworkId(): Promise<0 | 1>;
    signTx(signedTx: string): Promise<string>;
    submitTx(tx: string): Promise<string>;
}

type Address = {
    address: string;
    publicKey?: string;
    purpose: "payment" | "ordinals";
    addressType: "p2tr" | "p2wpkh" | "p2sh";
};

type UTxO = {
    status: {
        block_hash: string;
        block_height: number;
        block_time: number;
        confirmed: boolean;
    };
    txid: string;
    value: number;
    vout: number;
};

type ChainStats = {
    funded_txo_count: number;
    funded_txo_sum: number;
    spent_txo_count: number;
    spent_txo_sum: number;
    tx_count: number;
};

type MempoolStats = {
    funded_txo_count: number;
    funded_txo_sum: number;
    spent_txo_count: number;
    spent_txo_sum: number;
    tx_count: number;
};

type AddressInfo = {
    address: string;
    chain_stats: ChainStats;
    mempool_stats: MempoolStats;
};

type TransactionsStatus = {
    confirmed: boolean;
    block_height: number;
    block_hash: string;
    block_time: number;
};

type TransactionsInfo = {
    txid: string;
    version: number;
    locktime: number;
    vin: {
        txid: string;
        vout: number;
        prevout: {
            scriptpubkey: string;
            scriptpubkey_asm: string;
            scriptpubkey_type: string;
            scriptpubkey_address: string;
            value: number;
        };
        scriptsig: string;
        scriptsig_asm: string;
        witness: string[];
        is_coinbase: boolean;
        sequence: number;
    }[];
    vout: {
        scriptpubkey: string;
        scriptpubkey_asm: string;
        scriptpubkey_type: string;
        scriptpubkey_address: string;
        value: number;
    }[];
    size: number;
    weight: number;
    fee: number;
    status: TransactionsStatus;
};

type ScriptInfo = {
    scripthash: string;
    chain_stats: ChainStats;
    mempool_stats: MempoolStats;
};

type NetworkType = "Mainnet" | "Regtest" | "Testnet";
type CreateWalletOptions = {
    network: NetworkType;
    key: {
        type: "mnemonic";
        words: string[];
    } | {
        type: "address";
        address: string;
    };
    path?: string;
    provider?: IBitcoinProvider;
};
type GetAddressResult = {
    address: string;
    publicKey: string;
    purpose: "payment" | "ordinals";
    addressType: "p2tr" | "p2wpkh" | "p2sh";
    network: "mainnet" | "testnet" | "regtest";
    walletType: "software" | "ledger";
};
type SignMessageParams = {
    address: string;
    message: string;
    protocol?: "ECDSA" | "BIP322";
};
type SignMessageResult = {
    signature: string;
    messageHash: string;
    address: string;
};
type SignPsbtParams = {
    psbt: string;
    signInputs: Record<string, number[]>;
    broadcast?: boolean;
};
type SignPsbtResult = {
    psbt: string;
    txid?: string;
};
type SendTransferParams = {
    recipients: Array<{
        address: string;
        amount: number;
    }>;
};
type SendTransferResult = {
    txid: string;
};
type GetBalanceResult = {
    confirmed: string;
    unconfirmed: string;
    total: string;
};
type SignMultipleTransactionsParams = {
    network: {
        type: NetworkType;
    };
    message: string;
    psbts: Array<{
        psbtBase64: string;
        inputsToSign: Array<{
            address: string;
            signingIndexes: number[];
            sigHash?: number;
        }>;
    }>;
};
type TransactionPayload = {
    inputs: {
        txid: string;
        vout: number;
        value: number;
    }[];
    outputs: {
        address: string;
        value: number;
    }[];
};

type MaestroSupportedNetworks = "mainnet" | "testnet";
interface MaestroConfig {
    network: MaestroSupportedNetworks;
    apiKey: string;
}
interface SatoshiActivity {
    confirmations: number;
    height: number;
    tx_hash: string;
    sat_activity: {
        kind: "self_transfer" | "increase" | "decrease";
        amount: string;
    };
}
interface SatoshiActivityResponse {
    data: SatoshiActivity[];
    last_updated: {
        block_hash: string;
        block_height: number;
    };
    next_cursor: string | null;
}
type BalanceResponse = {
    data: number;
};

interface IBitcoinProvider {
    fetchAddress(address: string): Promise<AddressInfo>;
    fetchAddressTransactions(address: string, last_seen_txid?: string): Promise<TransactionsInfo[]>;
    fetchAddressUTxOs(address: string): Promise<UTxO[]>;
    fetchScript(hash: string): Promise<ScriptInfo>;
    fetchScriptTransactions(hash: string, last_seen_txid?: string): Promise<TransactionsInfo[]>;
    fetchScriptUTxOs(hash: string): Promise<UTxO[]>;
    fetchTransactionStatus(txid: string): Promise<TransactionsStatus>;
    fetchFeeEstimates(blocks: number): Promise<number>;
    submitTx(tx: string): Promise<string>;
}

/**
 * https://github.com/Blockstream/esplora/blob/master/API.md
 */
declare class BlockstreamProvider implements IBitcoinProvider {
    private readonly _axiosInstance;
    constructor(network?: "mainnet" | "testnet");
    /**
     * Get information about an address.
     * @param address - The address.
     * @returns AddressInfo
     */
    fetchAddress(address: string): Promise<AddressInfo>;
    /**
     * Get transaction history for the specified address, sorted with newest first.
     * Returns up to 50 mempool transactions plus the first 25 confirmed transactions. You can request more confirmed transactions using `last_seen_txid`.
     * @param address - The address.
     * @param last_seen_txid - The last seen transaction ID (optional).
     * @returns TransactionsInfo[]
     */
    fetchAddressTransactions(address: string, last_seen_txid?: string): Promise<TransactionsInfo[]>;
    /**
     * Get the list of unspent transaction outputs associated with the address.
     * @param address - The address.
     * @returns UTxO[]
     */
    fetchAddressUTxOs(address: string): Promise<UTxO[]>;
    /**
     * Get information about a scripthash.
     * @param hash - The hash of the script.
     * @returns ScriptInfo
     */
    fetchScript(hash: string): Promise<ScriptInfo>;
    /**
     * Get transaction history for the specified scripthash, sorted with newest first.
     * Returns up to 50 mempool transactions plus the first 25 confirmed transactions. You can request more confirmed transactions using `last_seen_txid`.
     * @param hash - The hash of the script.
     * @param last_seen_txid - The last seen transaction ID (optional).
     * @returns TransactionsInfo[]
     */
    fetchScriptTransactions(hash: string, last_seen_txid?: string): Promise<TransactionsInfo[]>;
    /**
     * Get the list of unspent transaction outputs associated with the scripthash.
     * @param hash - The hash of the script.
     * @returns UTxO[]
     */
    fetchScriptUTxOs(hash: string): Promise<UTxO[]>;
    /**
     * Fetches the status of a transaction
     * @param txid - The transaction ID.
     * @returns TransactionsStatus
     */
    fetchTransactionStatus(txid: string): Promise<TransactionsStatus>;
    /**
     * Get fee estimates for confirmation within a specified number of blocks.
     * Returns fee rate in sat/vB based on Blockstream's fee estimates API.
     * @param blocks - Confirmation target in blocks (1-25, 144, 504, 1008)
     * @returns Fee rate in sat/vB
     */
    fetchFeeEstimates(blocks: number): Promise<number>;
    /**
     * Broadcast a raw transaction to the network.
     * The transaction should be provided as hex in the request body. The txid will be returned on success.
     * @param tx - The transaction in hex format.
     * @returns The transaction ID.
     */
    submitTx(tx: string): Promise<string>;
}

/**
 * Maestro provider for Bitcoin operations.
 */
declare class MaestroProvider implements IBitcoinProvider {
    private readonly _axiosInstance;
    private readonly _network;
    /**
     * Create provider with custom base URL (for proxy endpoints).
     * @param baseUrl - The base URL of the proxy endpoint.
     * @param apiKey - The API key for the proxy.
     */
    constructor(baseUrl: string, apiKey: string);
    /**
     * Create provider with Maestro configuration.
     * @param config - The Maestro configuration object.
     */
    constructor(config: MaestroConfig);
    /**
     * Get information about a script hash.
     * @param hash - The script hash.
     * @returns ScriptInfo
     * @note Maestro does not have any endpoint available for this yet
     */
    fetchScript(hash: string): Promise<ScriptInfo>;
    /**
     * Get transaction history for the specified script hash, sorted with newest first.
     * @param hash - The script hash.
     * @param last_seen_txid - The last seen transaction ID (optional).
     * @returns TransactionsInfo[]
     * @note Maestro does not have any endpoint available for this yet
     */
    fetchScriptTransactions(hash: string, last_seen_txid?: string): Promise<TransactionsInfo[]>;
    /**
     * Get the list of unspent transaction outputs associated with the script hash.
     * @param hash - The script hash.
     * @returns UTxO[]
     * @note Maestro does not have any endpoint available for this yet
     */
    fetchScriptUTxOs(hash: string): Promise<UTxO[]>;
    /**
     * Get information about an address.
     * @param address - The address.
     * @returns AddressInfo
     */
    fetchAddress(address: string): Promise<AddressInfo>;
    /**
     * Get transaction history for the specified address, sorted with newest first.
     * Returns up to 50 mempool transactions plus the first 25 confirmed transactions. You can request more confirmed transactions using `last_seen_txid`.
     * @param address - The address.
     * @param last_seen_txid - The last seen transaction ID (optional).
     * @returns TransactionsInfo[]
     */
    fetchAddressTransactions(address: string, last_seen_txid?: string): Promise<TransactionsInfo[]>;
    /**
     * Get the list of unspent transaction outputs associated with the address.
     * @param address - The address.
     * @returns UTxO[]
     */
    fetchAddressUTxOs(address: string): Promise<UTxO[]>;
    /**
     * Get the spending status of a transaction output.
     * @param txid - The transaction ID.
     * @returns TransactionsStatus
     */
    fetchTransactionStatus(txid: string): Promise<TransactionsStatus>;
    /**
     * Broadcast a raw transaction to the network.
     * @param txHex - The raw transaction in hexadecimal format.
     * @returns The transaction ID.
     */
    submitTx(txHex: string): Promise<string>;
    /**
     * Get fee estimates for Bitcoin transactions.
     * @param blocks - The number of blocks to estimate fees for (default: 6).
     * @returns The estimated fee rate in satoshis per vByte.
     */
    fetchFeeEstimates(blocks?: number): Promise<number>;
    /**
     * Fetch satoshi activity for a Bitcoin address (transaction history).
     * @param address - The Bitcoin address.
     * @param options - Optional parameters for filtering and pagination.
     * @param options.order - Sort order ('asc' or 'desc').
     * @param options.count - Maximum number of results to return.
     * @param options.from - Start block height.
     * @param options.to - End block height.
     * @param options.cursor - Pagination cursor.
     * @returns SatoshiActivityResponse containing transaction activity data.
     */
    fetchSatoshiActivity(address: string, options?: {
        order?: "asc" | "desc";
        count?: number;
        from?: number;
        to?: number;
        cursor?: string;
    }): Promise<SatoshiActivityResponse>;
    /**
     * Get transaction details by hash.
     * @param hash - The transaction hash.
     * @returns TransactionsInfo containing transaction details.
     */
    fetchTxInfo(hash: string): Promise<TransactionsInfo>;
    /**
     * Get address balance (raw response).
     * @param address - The Bitcoin address.
     * @returns BalanceResponse containing the raw balance data.
     */
    fetchAddressBalance(address: string): Promise<BalanceResponse>;
    /**
     * Get balance for a Bitcoin address (convenience method).
     * @param address - The Bitcoin address.
     * @returns The balance as a bigint in satoshis.
     */
    getBalance(address: string): Promise<bigint>;
    /**
     * Generic GET request for Bitcoin API endpoints.
     * @param url - The API endpoint URL.
     * @returns The response data.
     */
    get(url: string): Promise<any>;
    /**
     * Generic POST request for Bitcoin API endpoints.
     * @param url - The API endpoint URL.
     * @param body - The request body data.
     * @returns The response data.
     */
    post(url: string, body: any): Promise<any>;
    /**
     * Get the network this provider is configured for.
     * @returns The network configuration (mainnet or testnet).
     */
    getNetwork(): MaestroSupportedNetworks;
}

declare function resolveAddress(publicKey: string | Buffer, network: "mainnet" | "testnet" | bitcoin.networks.Network): Address;

declare class BrowserWallet implements IBitcoinWallet {
    private readonly _purposes;
    constructor(purposes: string[]);
    /**
     * This is the entrypoint to start communication with the user's wallet. The wallet should request the user's permission to connect the web page to the user's wallet, and if permission has been granted, the wallet will be returned and exposing the full API for the dApp to use.
     * @param message - A message to display to the user when requesting permission to connect the wallet.
     * @param purposes - An array of purposes for which the wallet is being connected. Default is `["payment"]`. Options are `["payment", "ordinals", "stacks"]`.
     * @returns
     */
    static enable(message: string, purposes?: string[]): Promise<BrowserWallet>;
    getAddresses(): Promise<Address[] | undefined>;
    getChangeAddress(): Promise<string>;
    getCollateral(): Promise<never[]>;
    getNetworkId(): Promise<0 | 1>;
    request(method: string, params?: any): Promise<any>;
    signData(payload: string, address?: string, addressType?: "p2wpkh" | "p2tr" | "stacks"): Promise<{
        address: string;
        signature: string;
        messageHash: string;
    } | undefined>;
    signTx(signedTx: string): Promise<string>;
    submitTx(signedTx: string): Promise<string>;
}

/**
 * EmbeddedWallet is a class that provides a simple interface to interact with Bitcoin wallets.
 */
declare class EmbeddedWallet {
    private readonly _network;
    private readonly _wallet?;
    private readonly _provider?;
    private readonly _isReadOnly;
    private readonly _address?;
    constructor(options: CreateWalletOptions);
    /**
     * Apps can specify which wallet addresses they require: Bitcoin ordinals address or Bitcoin payment address,
     * using the `purposes` request parameter. The `message` request param gives apps the option to display a
     * message to the user when requesting their addresses. (note: ignored for embedded wallets)
     *
     * @param purposes Array of strings used to specify the purpose of the address(es) to request:
     *   - `'ordinals'` is preferably used to manage the user's ordinals
     *   - `'payment'` is preferably used to manage the user's bitcoin
     *   Example: `['ordinals', 'payment']`
     * @param message Optional - a message to be displayed to the user in the request prompt (ignored for embedded wallets)
     * @returns {Promise<GetAddressResult[]>} Once resolved, returns an array of the user's wallet address objects:
     *   - `address`: string - the user's connected wallet address
     *   - `publicKey`: A hex string representing the bytes of the public key of the account. You can use this to construct partially signed Bitcoin transactions (PSBT)
     *   - `purpose`: string - The purpose of the address ('ordinals' for managing ordinals, 'payment' for managing bitcoin)
     *   - `addressType`: string - the address's format ('P2TR' for ordinals, 'P2SH' for payment, 'P2WPKH' for payment using Ledger)
     *   - `network`: string - the network where the address is being used ('mainnet', 'testnet', 'signet')
     *   - `walletType`: string - the type of wallet used for the account ('ledger' for Ledger devices, 'software' otherwise)
     * @throws {Error} If wallet is not properly initialized.
     */
    getAddresses(purposes?: Array<"payment" | "ordinals">, message?: string): Promise<GetAddressResult[]>;
    /**
     * Returns the hex-encoded public key of the wallet.
     *
     * @returns {string} The public key in hexadecimal format.
     * @throws {Error} If the wallet is read-only and public key is not available.
     */
    getPublicKey(): string;
    /**
     * Returns the network identifier of the wallet.
     * 0: Indicates the Bitcoin testnet.
     * 1: Indicates the Bitcoin mainnet.
     * 2: Indicates the Bitcoin regtest.
     *
     * @returns {0 | 1 | 2} The Bitcoin network ID.
     */
    getNetworkId(): 0 | 1 | 2;
    /**
     * Returns the network type as a string for API responses.
     */
    private _getNetworkString;
    /**
     * Get UTXOs for the wallet address.
     * @returns An array of UTXOs.
     */
    getUTxOs(): Promise<UTxO[]>;
    /**
     * You can request to sign a message with wallet's Bitcoin addresses, by invoking the `signMessage` method.
     *
     * @param params - Object containing the following parameters:
     *   - `address`: a string representing the address to use to sign the message
     *   - `message`: a string representing the message to be signed by the wallet
     *   - `protocol` (optional): By default, signMessage will use two type of signatures depending on the Bitcoin address used for signing:
     *     - ECDSA signatures over the secp256k1 curve when signing with the Bitcoin payment (`p2sh`) address
     *     - BIP322 signatures when signing with the Bitcoin Ordinals (`p2tr`) address or a Ledger-based Bitcoin payment address (`p2wpkh`)
     *
     *     You have the option to specify your preferred signature type with the `protocol` parameter:
     *     - `ECDSA` to request ECDSA signatures over the secp256k1 curve (available for payment addresses only: `p2sh` and `p2wpkh`)
     *     - `BIP322` to request BIP322 signatures (available for all payment (`p2sh` and `p2wpkh`) & ordinals addresses (`p2tr`))
     * @returns Promise that resolves to the `SignMessageResult` object containing:
     *   - `signature`: a string representing the signed message
     *   - `messageHash`: a string representing the hash of the message
     *   - `address`: a string representing the address used for signing
     * @throws {Error} If the wallet is read-only or private key is not available.
     */
    signMessage(params: SignMessageParams): Promise<SignMessageResult>;
    /**
     * You can use the `signPsbt` method to request the signature of a Partially Signed Bitcoin Transaction (PSBT)
     * from Bitcoin wallet addresses.
     *
     * The PSBT to be signed must be base64-encoded. You can use any Bitcoin library to construct this transaction.
     *
     * @param params - Object containing the following parameters:
     *   - `psbt`: a string representing the psbt to sign, encoded in base64
     *   - `signInputs`: A Record<string, number[]> where:
     *     - the keys are the addresses to use for signing
     *     - the values are the indexes of the inputs to sign with each address
     *   - `broadcast`: a boolean flag that specifies whether to broadcast the signed transaction after signature
     *
     * Depending on your use case, you can request that the PSBT be finalized and broadcasted after signing,
     * by setting the broadcast flag to true. Otherwise, the signed PSBT will be returned in the response without broadcasting.
     *
     * @returns Promise that resolves to the `SignPsbtResult` object containing:
     *   - `psbt`: The base64 encoded signed PSBT
     *   - `txid`: The transaction id as a hex-encoded string (only returned if the transaction was broadcasted)
     * @throws {Error} If the wallet is read-only or private key is not available.
     */
    signPsbt(params: SignPsbtParams): Promise<SignPsbtResult>;
    /**
     * You can use the `sendTransfer` method to request a transfer of any amount of Bitcoin to one or more recipients from the wallet.
     *
     * @param params - Object containing the following parameters:
     *   - `recipients`: an array of objects with <address, amount> properties:
     *     - `address`: a string representing the recipient's address
     *     - `amount`: a number representing the amount of Bitcoin to send, denominated in satoshis (Bitcoin base unit)
     * @returns Promise that resolves to the `sendTransferResult` object containing:
     *   - `txid`: The transaction id as a hex-encoded string
     * @throws {Error} If the wallet is read-only or provider is not available.
     */
    sendTransfer(params: SendTransferParams): Promise<SendTransferResult>;
    /**
     * You can use the `getBalance` method to retrieve Bitcoin balance.
     *
     * The `getBalance` method will return an object representing the connected wallet's payment address BTC holdings:
     *
     * @returns Promise that resolves to an object containing the following balance information:
     *   - `confirmed`: a string representing the connected wallet's confirmed BTC balance, i.e. the amount of confirmed BTC which the payment address holds, in satoshis
     *   - `unconfirmed`: a string representing the connected wallet's unconfirmed BTC balance, i.e. the amount of unconfirmed BTC which the payment address will send/receive as a result of pending mempool transactions, in satoshis (Note: this amount can be negative if the net result of pending mempool transaction decreases the address balance)
     *   - `total`: a string representing the sum of confirmed and unconfirmed BTC balances
     * @throws {Error} If provider is not available.
     */
    getBalance(): Promise<GetBalanceResult>;
    /**
     * To request signing of multiple PSBTs, you can use the `signMultipleTransactions` function.
     *
     * @param params - Object containing an array of PSBTs to sign, where each PSBT contains:
     *   - `psbtBase64`: a valid psbt encoded in base64
     *   - `inputsToSign`: an array of objects describing the address and index of input to sign
     * @returns Promise resolving to signed PSBTs
     * @throws {Error} If the wallet is read-only or private key is not available.
     */
    signMultipleTransactions(params: SignMultipleTransactionsParams): Promise<SignPsbtResult[]>;
    /**
     * Simple largest-first coin selection algorithm.
     * Selects UTXOs in descending order by value until target amount + fees is reached.
     *
     * @param utxos Available UTXOs
     * @param targetAmount Amount needed in satoshis
     * @param feeRate Fee rate in sat/vByte
     * @returns Selected UTXOs and change amount
     */
    private _selectUtxosLargestFirst;
    /**
     * Build PSBT for transfer using optimal coin selection.
     * @param utxos Available UTXOs
     * @param recipients Transfer recipients
     * @param walletAddress Wallet address for change
     * @returns Built PSBT ready for signing
     */
    private _buildTransferPsbt;
    /**
     * Generates a mnemonic phrase and returns it as an array of words.
     *
     * @param {number} [strength=128] - The strength of the mnemonic in bits (must be a multiple of 32 between 128 and 256).
     * @returns {string[]} An array of words representing the generated mnemonic.
     * @throws {Error} If the strength is not valid.
     */
    static brew(strength?: number): string[];
}
/**
 * Verifies if a signature is valid for a given message and public key.
 * @param message - The original message that was signed.
 * @param signatureBase64 - The base64-encoded signature to verify.
 * @param publicKeyHex - The hex-encoded public key to verify against.
 * @returns {boolean} True if the signature is valid and matches the public key.
 */
declare function verifySignature(message: string, signatureBase64: string, publicKeyHex: string): boolean;

export { type Address, type AddressInfo, type BalanceResponse, BlockstreamProvider, BrowserWallet, type ChainStats, type CreateWalletOptions, ECPair, EmbeddedWallet, type GetAddressResult, type GetBalanceResult, type IBitcoinProvider, type IBitcoinWallet, type MaestroConfig, MaestroProvider, type MaestroSupportedNetworks, type MempoolStats, type NetworkType, type SatoshiActivity, type SatoshiActivityResponse, type ScriptInfo, type SendTransferParams, type SendTransferResult, type SignMessageParams, type SignMessageResult, type SignMultipleTransactionsParams, type SignPsbtParams, type SignPsbtResult, type TransactionPayload, type TransactionsInfo, type TransactionsStatus, type UTxO, bip32, resolveAddress, verifySignature };
