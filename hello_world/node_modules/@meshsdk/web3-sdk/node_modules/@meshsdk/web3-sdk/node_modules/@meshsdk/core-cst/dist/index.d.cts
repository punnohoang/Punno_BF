import { Cardano, Serialization } from '@cardano-sdk/core';
import * as core from '@cardano-sdk/core';
export { core as CardanoSDK };
export { Cardano, Serialization } from '@cardano-sdk/core';
import { OpaqueString, HexBlob as HexBlob$1 } from '@cardano-sdk/util';
import * as util from '@cardano-sdk/util';
export { util as CardanoSDKUtil };
import * as Crypto from '@cardano-sdk/crypto';
export { Crypto };
import { DataSignature, BuilderData, PlutusDataType, NativeScript as NativeScript$1, PlutusScript, IMeshTxSerializer, Protocol, DeserializedAddress, IDeserializer, IResolver, MeshTxBuilderBody, Asset, Output, UTxO, LanguageVersion, Data, PubKeyAddress, ScriptAddress } from '@meshsdk/common';
import { Buffer as Buffer$1 } from 'buffer';
import { CborMap, CborBytes } from '@harmoniclabs/cbor';

declare const Slot: (value: number) => Cardano.Slot;
type Slot = Cardano.Slot;
declare const Value: typeof Serialization.Value;
type Value = Serialization.Value;
type TokenMap = Cardano.TokenMap;
declare const Transaction: typeof Serialization.Transaction;
type Transaction = Serialization.Transaction;
declare const TransactionId: (value: string) => Cardano.TransactionId;
type TransactionId = Cardano.TransactionId;
declare const TransactionBody: typeof Serialization.TransactionBody;
type TransactionBody = Serialization.TransactionBody;
declare const TransactionWitnessSet: typeof Serialization.TransactionWitnessSet;
type TransactionWitnessSet = Serialization.TransactionWitnessSet;
declare const AuxilliaryData: typeof Serialization.AuxiliaryData;
type AuxiliaryData = Serialization.AuxiliaryData;
declare const TransactionMetadatum: typeof Serialization.TransactionMetadatum;
type TransactionMetadatum = Serialization.TransactionMetadatum;
declare const MetadatumMap: typeof Serialization.MetadatumMap;
type MetadatumMap = Serialization.MetadatumMap;
declare const MetadatumList: typeof Serialization.MetadatumList;
type MetadatumList = Serialization.MetadatumList;
declare const TransactionUnspentOutput: typeof Serialization.TransactionUnspentOutput;
type TransactionUnspentOutput = Serialization.TransactionUnspentOutput;
declare const TransactionInput: typeof Serialization.TransactionInput;
type TransactionInput = Serialization.TransactionInput;
declare const TransactionOutput: typeof Serialization.TransactionOutput;
type TransactionOutput = Serialization.TransactionOutput;
type TransactionInputSet = Serialization.CborSet<ReturnType<TransactionInput["toCore"]>, TransactionInput>;
type TransactionWitnessPlutusData = Set<PlutusData>;
declare const PlutusData: typeof Serialization.PlutusData;
type PlutusData = Serialization.PlutusData;
declare const PlutusList: typeof Serialization.PlutusList;
type PlutusList = Serialization.PlutusList;
declare const PlutusMap: typeof Serialization.PlutusMap;
type PlutusMap = Serialization.PlutusMap;
declare const Redeemers: typeof Serialization.Redeemers;
type Redeemers = Serialization.Redeemers;
declare const Redeemer: typeof Serialization.Redeemer;
type Redeemer = Serialization.Redeemer;
declare const RedeemerPurpose: typeof Cardano.RedeemerPurpose;
type RedeemerPurpose = Cardano.RedeemerPurpose;
declare const RedeemerTag: typeof Serialization.RedeemerTag;
type RedeemerTag = Serialization.RedeemerTag;
declare const Script: typeof Serialization.Script;
type Script = Serialization.Script;
declare const PolicyId: (value: string) => Cardano.PolicyId;
type PolicyId = Cardano.PolicyId;
declare const AssetName: {
    (value: string): Cardano.AssetName;
    toUTF8(assetName: Cardano.AssetName, stripInvisibleCharacters?: boolean): string;
};
type AssetName = Cardano.AssetName;
declare const AssetId: {
    (value: string): Cardano.AssetId;
    getPolicyId(id: Cardano.AssetId): Cardano.PolicyId;
    getAssetName(id: Cardano.AssetId): Cardano.AssetName;
    fromParts(policyId: Cardano.PolicyId, assetName: Cardano.AssetName): Cardano.AssetId;
};
type AssetId = Cardano.AssetId;
declare const ScriptHash: {
    (value: string): Crypto.Hash28ByteBase16;
    fromEd25519KeyHashHex(value: Crypto.Ed25519KeyHashHex): Crypto.Hash28ByteBase16;
};
type ScriptHash = Crypto.Hash28ByteBase16;
declare const Address: typeof Cardano.Address;
type Address = Cardano.Address;
declare const RewardAddress: typeof Cardano.RewardAddress;
type RewardAddress = Cardano.RewardAddress;
declare const AddressType: typeof Cardano.AddressType;
type AddressType = Cardano.AddressType;
declare const BaseAddress: typeof Cardano.BaseAddress;
type BaseAddress = Cardano.BaseAddress;
declare const EnterpriseAddress: typeof Cardano.EnterpriseAddress;
type EnterpriseAddress = Cardano.EnterpriseAddress;
declare const PaymentAddress: (value: string) => Cardano.PaymentAddress;
type PaymentAddress = Cardano.PaymentAddress;
declare const AssetFingerprint: {
    (value: string): Cardano.AssetFingerprint;
    fromParts(policyId: Cardano.PolicyId, assetName: Cardano.AssetName): Cardano.AssetFingerprint;
};
type AssetFingerprint = Cardano.AssetFingerprint;
declare const Credential: typeof Serialization.Credential;
type Credential = Serialization.Credential;
type CredentialCore = Cardano.Credential;
declare const Ed25519PublicKeyHex: (value: string) => Crypto.Ed25519PublicKeyHex;
type Ed25519PublicKeyHex = Crypto.Ed25519PublicKeyHex;
type Ed25519PrivateNormalKeyHex = OpaqueString<"Ed25519PrivateKeyHex">;
declare const Ed25519PrivateNormalKeyHex: (value: string) => Ed25519PrivateNormalKeyHex;
type Ed25519PrivateExtendedKeyHex = OpaqueString<"Ed25519PrivateKeyHex">;
declare const Ed25519PrivateExtendedKeyHex: (value: string) => Ed25519PrivateExtendedKeyHex;
declare const Ed25519KeyHash: typeof Crypto.Ed25519KeyHash;
type Ed25519KeyHash = Crypto.Ed25519KeyHash;
declare const Ed25519KeyHashHex: (value: string) => Crypto.Ed25519KeyHashHex;
type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;
declare const Hash28ByteBase16: {
    (value: string): Crypto.Hash28ByteBase16;
    fromEd25519KeyHashHex(value: Crypto.Ed25519KeyHashHex): Crypto.Hash28ByteBase16;
};
type Hash28ByteBase16 = Crypto.Hash28ByteBase16;
declare const Hash32ByteBase16: (value: string) => Crypto.Hash32ByteBase16;
type Hash32ByteBase16 = Crypto.Hash32ByteBase16;
declare const CredentialType: typeof Cardano.CredentialType;
type CredentialType = Cardano.CredentialType;
declare const Certificate: typeof Serialization.Certificate;
type Certificate = Serialization.Certificate;
declare const PoolId: {
    (value: string): Cardano.PoolId;
    fromKeyHash(value: Crypto.Ed25519KeyHashHex): Cardano.PoolId;
    toKeyHash(poolId: Cardano.PoolId): Crypto.Ed25519KeyHashHex;
};
type PoolId = Cardano.PoolId;
declare const StakeRegistration: typeof Serialization.StakeRegistration;
type StakeRegistration = Serialization.StakeRegistration;
declare const StakeDelegation: typeof Serialization.StakeDelegation;
type StakeDelegation = Serialization.StakeDelegation;
type StakeDelegationCertificate = Cardano.StakeDelegationCertificate;
declare const CertificateType: typeof Cardano.CertificateType;
type CertificateType = Cardano.CertificateType;
declare const VkeyWitness: typeof Serialization.VkeyWitness;
type VkeyWitness = Serialization.VkeyWitness;
declare const Ed25519SignatureHex: (value: string) => Crypto.Ed25519SignatureHex;
type Ed25519SignatureHex = Crypto.Ed25519SignatureHex;
declare const Ed25519PublicKey: typeof Crypto.Ed25519PublicKey;
type Ed25519PublicKey = Crypto.Ed25519PublicKey;
declare const Ed25519Signature: typeof Crypto.Ed25519Signature;
type Ed25519Signature = Crypto.Ed25519Signature;
declare const Bip32PrivateKey: typeof Crypto.Bip32PrivateKey;
type Bip32PrivateKey = Crypto.Bip32PrivateKey;
declare const Bip32PrivateKeyHex: (key: string) => Crypto.Bip32PrivateKeyHex;
type Bip32PrivateKeyHex = Crypto.Bip32PrivateKeyHex;
declare const Bip32PublicKey: typeof Crypto.Bip32PublicKey;
type Bip32PublicKey = Crypto.Bip32PublicKey;
declare const Bip32PublicKeyHex: (key: string) => Crypto.Bip32PublicKeyHex;
type Bip32PublicKeyHex = Crypto.Bip32PublicKeyHex;
declare const PlutusLanguageVersion: typeof Cardano.PlutusLanguageVersion;
type PlutusLanguageVersion = Cardano.PlutusLanguageVersion;
declare const NativeScript: typeof Serialization.NativeScript;
type NativeScript = Serialization.NativeScript;
declare const PlutusV1Script: typeof Serialization.PlutusV1Script;
type PlutusV1Script = Serialization.PlutusV1Script;
declare const PlutusV2Script: typeof Serialization.PlutusV2Script;
type PlutusV2Script = Serialization.PlutusV2Script;
declare const PlutusV3Script: typeof Serialization.PlutusV3Script;
type PlutusV3Script = Serialization.PlutusV3Script;
declare const PlutusDataKind: typeof Serialization.PlutusDataKind;
type PlutusDataKind = Serialization.PlutusDataKind;
declare const PointerAddress: typeof Cardano.PointerAddress;
type PointerAddress = Cardano.PointerAddress;
declare const CertIndex: (value: number) => Cardano.CertIndex;
type CertIndex = Cardano.CertIndex;
declare const TxIndex: (value: number) => Cardano.TxIndex;
type TxIndex = Cardano.TxIndex;
declare const Costmdls: typeof Serialization.Costmdls;
type Costmdls = Serialization.Costmdls;
declare const CostModel: typeof Serialization.CostModel;
type CostModel = Serialization.CostModel;
declare const CborWriter: typeof Serialization.CborWriter;
type CborWriter = Serialization.CborWriter;
declare const ConstrPlutusData: typeof Serialization.ConstrPlutusData;
type ConstrPlutusData = Serialization.ConstrPlutusData;
declare const RewardAccount: {
    (value: string): Cardano.RewardAccount;
    toHash(rewardAccount: Cardano.RewardAccount): Crypto.Hash28ByteBase16;
    fromCredential(credential: Cardano.Credential, networkId: Cardano.NetworkId): Cardano.RewardAccount;
    toNetworkId(rewardAccount: Cardano.RewardAccount): Cardano.NetworkId;
};
type RewardAccount = Cardano.RewardAccount;
declare const Hash: typeof Serialization.Hash;
type Hash<T extends string> = Serialization.Hash<T>;
declare const DatumHash: (value: string) => Crypto.Hash32ByteBase16;
type DatumHash = Crypto.Hash32ByteBase16;
declare const Datum: typeof Serialization.Datum;
type Datum = PlutusData | DatumHash;
type CostModels = Cardano.CostModels;
type ExUnits = Serialization.ExUnits;
declare const ExUnits: typeof Serialization.ExUnits;
declare const NetworkId: typeof Cardano.NetworkId;
type NetworkId = Cardano.ChainId["networkId"];
declare const DatumKind: typeof Serialization.DatumKind;
declare const CborSet: typeof Serialization.CborSet;
type Witness = Cardano.Witness;
type Signatures = Cardano.Signatures;
type RequireAllOf = Cardano.NativeScriptKind.RequireAllOf;
declare const RequireAllOf = Cardano.NativeScriptKind.RequireAllOf;
type RequireAnyOf = Cardano.NativeScriptKind.RequireAnyOf;
declare const RequireAnyOf = Cardano.NativeScriptKind.RequireAnyOf;
type RequireNOf = Cardano.NativeScriptKind.RequireNOf;
declare const RequireNOf = Cardano.NativeScriptKind.RequireNOf;
type RequireSignature = Cardano.NativeScriptKind.RequireSignature;
declare const RequireSignature = Cardano.NativeScriptKind.RequireSignature;
type RequireTimeAfter = Cardano.NativeScriptKind.RequireTimeAfter;
declare const RequireTimeAfter = Cardano.NativeScriptKind.RequireTimeAfter;
type RequireTimeBefore = Cardano.NativeScriptKind.RequireTimeBefore;
declare const RequireTimeBefore = Cardano.NativeScriptKind.RequireTimeBefore;
type VrfVkBech32 = Cardano.VrfVkBech32;
declare const VrfVkBech32: {
    (value: string): Cardano.VrfVkBech32;
    fromHex(value: string): Cardano.VrfVkBech32;
};
type ScriptPubkey = Serialization.ScriptPubkey;
declare const ScriptPubkey: typeof Serialization.ScriptPubkey;
type DRepID = Cardano.DRepID;
declare const DRepID: {
    (value: string): Cardano.DRepID;
    isValid(value: string): boolean;
    cip105FromCredential(credential: Cardano.Credential): Cardano.DRepID;
    cip129FromCredential(credential: Cardano.Credential): Cardano.DRepID;
    toCredential(drepId: Cardano.DRepID): Cardano.Credential;
    toCip105DRepID(drepId: Cardano.DRepID): Cardano.DRepID;
    toCip129DRepID(drepId: Cardano.DRepID): Cardano.DRepID;
    toAddress(drepId: Cardano.DRepID): Cardano.EnterpriseAddress | undefined;
};
type DRep = Serialization.DRep;
declare const DRep: typeof Serialization.DRep;
type StakeCredentialStatus = Cardano.StakeCredentialStatus;
declare const StakeCredentialStatus: typeof Cardano.StakeCredentialStatus;
type Metadatum = Cardano.Metadatum;
type HexBlob = HexBlob$1;
declare const HexBlob: {
    (target: string): HexBlob$1;
    fromBytes(bytes: Uint8Array): HexBlob$1;
    fromBase64(rawData: string): HexBlob$1;
    toTypedBech32<T>(prefix: string, hexString: HexBlob$1): T;
};
type TxCBOR = Serialization.TxCBOR;
declare const TxCBOR: {
    (tx: string): Serialization.TxCBOR;
    serialize(tx: Cardano.Tx): Serialization.TxCBOR;
    deserialize(tx: Serialization.TxCBOR): Cardano.Tx;
};
type Ed25519PrivateKey = Crypto.Ed25519PrivateKey;
declare const Ed25519PrivateKey: typeof Crypto.Ed25519PrivateKey;
declare const computeAuxiliaryDataHash: (data: Cardano.AuxiliaryData | undefined) => Crypto.Hash32ByteBase16 | undefined;
declare const blake2b: typeof Crypto.blake2b;
type BootstrapWitness = Serialization.BootstrapWitness;
declare const BootstrapWitness: typeof Serialization.BootstrapWitness;
type ByronAttributes = Cardano.ByronAttributes;

type Signer = {
    address: Address;
    key: Ed25519PrivateKey;
};

/**
 * Check the signature of a given data string
 * @param data The data string to verify the signature against
 * @param {key, signature} The signature obtained by `signData`
 * @param address Optional Bech32 string of a stake, stake_test1, addr, or addr_test1 address. If provided, this function will validate the signer's address against this value.
 * @returns boolean
 */
declare const checkSignature: (data: string, { key, signature }: DataSignature, address?: string) => Promise<boolean>;

declare class CoseSign1 {
    private protectedMap;
    private unProtectedMap;
    private payload;
    private signature;
    constructor(payload: {
        protectedMap: CborMap;
        unProtectedMap: CborMap;
        payload: CborBytes | null;
        signature?: CborBytes;
    });
    static fromCbor(cbor: string): CoseSign1;
    createSigStructure(externalAad?: Buffer$1): Buffer$1;
    buildMessage(signature: Buffer$1): Buffer$1;
    verifySignature({ externalAad, publicKeyBuffer, }?: {
        externalAad?: Buffer$1;
        publicKeyBuffer?: Buffer$1;
    }): boolean;
    hashPayload(): void;
    getAddress(): Buffer$1;
    getPublicKey(): Buffer$1;
    getSignature(): Buffer$1 | undefined;
    getPayload(): Buffer$1 | null;
}
declare const getPublicKeyFromCoseKey: (cbor: string) => Buffer$1;
declare const getCoseKeyFromPublicKey: (cbor: string) => Buffer$1;

/**
 * Generate a nonce string
 * @param label The label to prepend to the nonce
 * @param length The length of the nonce
 * @returns The generated nonce in hex format
 */
declare const generateNonce: (label?: string, length?: number) => string;

/**
 * Sign the data string using the provided signer
 * @param data The data string to sign
 * @param signer The signer object containing the key and address
 * @returns DataSignature for verification
 */
declare const signData: (data: string, signer: Signer) => DataSignature;

declare const resolveDataHash: (rawData: BuilderData["content"], type?: PlutusDataType) => string;
declare const resolveNativeScriptAddress: (script: NativeScript$1, networkId?: number) => string;
declare const resolveNativeScriptHash: (script: NativeScript$1) => string;
declare const resolvePaymentKeyHash: (bech32: string) => string;
declare const resolvePlutusScriptAddress: (script: PlutusScript, networkId?: number) => string;
declare const resolvePlutusScriptHash: (bech32: string) => string;
declare const resolvePoolId: (hash: string) => string;
declare const resolvePrivateKey: (words: string[]) => string;
declare const resolveScriptRef: (script: PlutusScript | NativeScript$1) => string;
declare const resolveRewardAddress: (bech32: string) => string;
declare const resolveStakeKeyHash: (bech32: string) => string;
declare const resolveTxHash: (txHex: string) => string;
declare const resolveScriptHashDRepId: (scriptHash: string) => string;
declare const resolveEd25519KeyHash: (bech32: string) => string;

declare class CardanoSDKSerializer implements IMeshTxSerializer {
    protocolParams: Protocol;
    constructor(protocolParams?: Protocol);
    serializeRewardAddress(stakeKeyHash: string, isScriptHash?: boolean, network_id?: 0 | 1): string;
    serializePoolId(hash: string): string;
    serializeAddress(address: Partial<DeserializedAddress>, networkId?: 0 | 1): string;
    serializeData(data: BuilderData): string;
    deserializer: IDeserializer;
    resolver: IResolver;
    serializeTxBody: (txBuilderBody: MeshTxBuilderBody, protocolParams?: Protocol) => string;
    serializeTxBodyWithMockSignatures(txBuilderBody: MeshTxBuilderBody, protocolParams: Protocol): string;
    addSigningKeys: (txHex: string, signingKeys: string[]) => string;
    serializeValue(value: Asset[]): string;
    serializeOutput(output: Output): string;
}

declare const buildBaseAddress: (networkId: number, paymentKeyHash: Hash28ByteBase16, stakeKeyHash: Hash28ByteBase16) => BaseAddress;
declare const buildEnterpriseAddress: (networkId: number, paymentKeyHash: Hash28ByteBase16) => EnterpriseAddress;
declare const clampScalar: (scalar: Buffer) => Buffer;
declare const buildBip32PrivateKey: (entropy: string, password?: string) => Bip32PrivateKey;
declare const buildRewardAddress: (networkId: number, stakeKeyHash: Hash28ByteBase16) => RewardAddress;
/**
 * Build a set of keys from a given private key
 *
 * NOTE - Must be called after `await Crypto.Ready()`
 *
 * @param privateKeyHex - The BIP32 private key hex to derive keys from
 * @param accountIndex - The account index to derive keys for
 * @param keyIndex - The key index to derive keys for
 * @returns The payment and stake keys, and optionally the dRep key if a Bip32PrivateKey is provided
 */
declare const buildKeys: (privateKeyHex: string | [string, string], accountIndex: number, keyIndex?: number) => {
    paymentKey: Ed25519PrivateKey;
    stakeKey: Ed25519PrivateKey;
    dRepKey?: Ed25519PrivateKey;
};
declare const buildEd25519PrivateKeyFromSecretKey: (secretKeyHex: string) => Crypto.Ed25519PrivateKey;
declare const buildScriptPubkey: (keyHash: Ed25519KeyHash) => NativeScript;
declare const buildDRepID: (dRepKey: Ed25519PublicKeyHex, networkId?: NetworkId, addressType?: AddressType) => DRepID;

declare const toAddress: (bech32: string) => Address;
declare const toCardanoAddress: (address: string) => Address;
declare const toBaseAddress: (bech32: string) => BaseAddress | undefined;
declare const toEnterpriseAddress: (bech32: string) => EnterpriseAddress | undefined;
declare const toRewardAddress: (bech32: string) => RewardAddress | undefined;
declare const fromTxUnspentOutput: (txUnspentOutput: TransactionUnspentOutput) => UTxO;
declare const toTxUnspentOutput: (utxo: UTxO) => Serialization.TransactionUnspentOutput;
declare const addressToBech32: (address: Address) => string;
declare const fromValue: (value: Value) => Asset[];
declare const toScriptRef: (script: PlutusScript | NativeScript$1) => Script;
declare const fromScriptRef: (scriptRef: string) => PlutusScript | NativeScript$1 | undefined;
declare const fromNativeScript: (script: NativeScript) => NativeScript$1;
declare const toNativeScript: (script: NativeScript$1) => Serialization.NativeScript;
declare const toValue: (assets: Asset[]) => Serialization.Value;
declare const toDRep: (dRepId: string) => Serialization.DRep;
declare const getDRepIds: (dRepId: string) => {
    cip105: string;
    cip129: string;
};

declare const deserializeEd25519KeyHash: (ed25519KeyHash: string) => Crypto.Ed25519KeyHash;
declare const deserializePlutusScript: (plutusScript: string, version: LanguageVersion) => PlutusV1Script | PlutusV2Script | PlutusV3Script;
declare const deserializeNativeScript: (nativeScript: string) => NativeScript;
declare const deserializeScriptHash: (scriptHash: string) => Crypto.Hash28ByteBase16;
declare const deserializeScriptRef: (scriptRef: string) => Script;
declare const deserializeTxUnspentOutput: (txUnspentOutput: string) => TransactionUnspentOutput;
declare const deserializeValue: (value: string) => Value;
declare const deserializeTx: (tx: string) => Transaction;
declare const deserializeTxHash: (txHash: string) => TransactionId;

declare function mergeValue(a: Value, b: Value): Value;
declare function negateValue(v: Value): Value;
declare function subValue(a: Value, b: Value): Value;
declare function negatives(v: Value): Value;
declare function assetTypes(v: Value): number;
declare function empty(v: Value): boolean;

declare const toPlutusData: (data: Data) => PlutusData;
declare const fromJsonToPlutusData: (data: object) => PlutusData;
declare const fromBuilderToPlutusData: (data: BuilderData) => PlutusData;
declare const fromPlutusDataToJson: (data: PlutusData) => object;
declare const parseDatumCbor: <T = any>(datumCbor: string) => T;
declare const parseInlineDatum: <T extends {
    inline_datum?: string;
}, X>(utxo: T) => X;
declare const deserializeDataHash: (dataHash: string) => DatumHash;
declare const deserializePlutusData: (plutusData: string) => PlutusData;

declare const serialzeAddress: (deserializedAddress: Partial<DeserializedAddress>, networkId?: number) => string;
declare const addrBech32ToPlutusDataHex: (bech32: string) => string;
declare const addrBech32ToPlutusDataObj: <T>(bech32: string) => T;
declare const serializeAddressObj: (plutusDataAddressObject: PubKeyAddress | ScriptAddress, networkId?: number) => string;
declare const serializePlutusAddressToBech32: (plutusHex: string, networkId?: number) => string;
declare const deserializeBech32Address: (bech32Addr: string) => DeserializedAddress;
declare const deserializeAddress: (address: string) => Address;
declare const scriptHashToBech32: (scriptHash: string, stakeCredentialHash?: string, networkId?: number, isScriptStakeCredentialHash?: boolean) => string;
declare const v2ScriptToBech32: (scriptCbor: string, stakeCredential?: string, networkId?: number, isScriptStakeCredential?: boolean) => string;
declare const scriptHashToRewardAddress: (hash: string, networkId?: number) => string;
declare const keyHashToRewardAddress: (hash: string, networkId?: number) => string;

declare const bytesToHex: (bytes: Uint8Array) => HexBlob$1;
declare const hexToBytes: (hex: HexBlob$1) => Uint8Array;
declare const utf8ToBytes: (str: string) => Uint8Array;
declare const utf8ToHex: (str: string) => HexBlob$1;
declare const hexToBech32: (prefix: string, hex: string) => string;

declare const addVKeyWitnessSetToTransaction: (txHex: string, vkeyWitnessSet: string) => string;

declare const calculateFees: (minFeeA: number, minFeeB: number, minFeeRefScriptCostPerByte: number, priceMem: number, priceStep: number, tx: Transaction, refScriptSize: number) => bigint;

type OutputEncoding = "SingleCBOR" | "DoubleCBOR" | "PurePlutusScriptBytes";
/**
 * Normalizes a Plutus script by extracting its pure Plutus bytes and applying a specified encoding.
 *
 * @param {Uint8Array} plutusScript - The Plutus script to be normalized as a Uint8Array.
 * @param {OutputEncoding} encoding - The desired encoding for the output.
 * @returns {Uint8Array} The normalized Plutus script.
 *
 * @description
 * This function performs the following steps:
 * 1. Extracts the pure Plutus bytes in hex from the input script.
 * 2. Applies the specified encoding to the pure Plutus bytes.
 *
 * @note
 * - This function is useful for standardizing the format of Plutus scripts, ensuring they are in a consistent state for further processing or comparison.
 * - The normalization process does not modify the logical content of the script, only its representation.
 */
declare const normalizePlutusScript: (plutusScript: string, encoding: OutputEncoding) => string;
declare const applyEncoding: (plutusScript: Uint8Array, outputEncoding: OutputEncoding) => Uint8Array;
declare const applyParamsToScript: (rawScript: string, params: object[] | Data[], type?: PlutusDataType) => string;

export { Address, AddressType, AssetFingerprint, AssetId, AssetName, type AuxiliaryData, AuxilliaryData, BaseAddress, Bip32PrivateKey, Bip32PrivateKeyHex, Bip32PublicKey, Bip32PublicKeyHex, BootstrapWitness, type ByronAttributes, CardanoSDKSerializer, CborSet, CborWriter, CertIndex, Certificate, CertificateType, ConstrPlutusData, CoseSign1, CostModel, type CostModels, Costmdls, Credential, type CredentialCore, CredentialType, DRep, DRepID, Datum, DatumHash, DatumKind, Ed25519KeyHash, Ed25519KeyHashHex, Ed25519PrivateExtendedKeyHex, Ed25519PrivateKey, Ed25519PrivateNormalKeyHex, Ed25519PublicKey, Ed25519PublicKeyHex, Ed25519Signature, Ed25519SignatureHex, EnterpriseAddress, ExUnits, Hash, Hash28ByteBase16, Hash32ByteBase16, HexBlob, type Metadatum, MetadatumList, MetadatumMap, NativeScript, NetworkId, type OutputEncoding, PaymentAddress, PlutusData, PlutusDataKind, PlutusLanguageVersion, PlutusList, PlutusMap, PlutusV1Script, PlutusV2Script, PlutusV3Script, PointerAddress, PolicyId, PoolId, Redeemer, RedeemerPurpose, RedeemerTag, Redeemers, RequireAllOf, RequireAnyOf, RequireNOf, RequireSignature, RequireTimeAfter, RequireTimeBefore, RewardAccount, RewardAddress, Script, ScriptHash, ScriptPubkey, type Signatures, type Signer, Slot, StakeCredentialStatus, StakeDelegation, type StakeDelegationCertificate, StakeRegistration, type TokenMap, Transaction, TransactionBody, TransactionId, TransactionInput, type TransactionInputSet, TransactionMetadatum, TransactionOutput, TransactionUnspentOutput, type TransactionWitnessPlutusData, TransactionWitnessSet, TxCBOR, TxIndex, Value, VkeyWitness, VrfVkBech32, type Witness, addVKeyWitnessSetToTransaction, addrBech32ToPlutusDataHex, addrBech32ToPlutusDataObj, addressToBech32, applyEncoding, applyParamsToScript, assetTypes, blake2b, buildBaseAddress, buildBip32PrivateKey, buildDRepID, buildEd25519PrivateKeyFromSecretKey, buildEnterpriseAddress, buildKeys, buildRewardAddress, buildScriptPubkey, bytesToHex, calculateFees, checkSignature, clampScalar, computeAuxiliaryDataHash, deserializeAddress, deserializeBech32Address, deserializeDataHash, deserializeEd25519KeyHash, deserializeNativeScript, deserializePlutusData, deserializePlutusScript, deserializeScriptHash, deserializeScriptRef, deserializeTx, deserializeTxHash, deserializeTxUnspentOutput, deserializeValue, empty, fromBuilderToPlutusData, fromJsonToPlutusData, fromNativeScript, fromPlutusDataToJson, fromScriptRef, fromTxUnspentOutput, fromValue, generateNonce, getCoseKeyFromPublicKey, getDRepIds, getPublicKeyFromCoseKey, hexToBech32, hexToBytes, keyHashToRewardAddress, mergeValue, negateValue, negatives, normalizePlutusScript, parseDatumCbor, parseInlineDatum, resolveDataHash, resolveEd25519KeyHash, resolveNativeScriptAddress, resolveNativeScriptHash, resolvePaymentKeyHash, resolvePlutusScriptAddress, resolvePlutusScriptHash, resolvePoolId, resolvePrivateKey, resolveRewardAddress, resolveScriptHashDRepId, resolveScriptRef, resolveStakeKeyHash, resolveTxHash, scriptHashToBech32, scriptHashToRewardAddress, serializeAddressObj, serializePlutusAddressToBech32, serialzeAddress, signData, subValue, toAddress, toBaseAddress, toCardanoAddress, toDRep, toEnterpriseAddress, toNativeScript, toPlutusData, toRewardAddress, toScriptRef, toTxUnspentOutput, toValue, utf8ToBytes, utf8ToHex, v2ScriptToBech32 };
