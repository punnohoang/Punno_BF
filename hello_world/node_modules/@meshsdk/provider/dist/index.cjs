"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  BeginProvider: () => BeginProvider,
  BlockfrostProvider: () => BlockfrostProvider,
  KoiosProvider: () => KoiosProvider,
  KupoProvider: () => KupoProvider,
  MaestroMultiChainProvider: () => MaestroMultiChainProvider,
  MaestroProvider: () => MaestroProvider,
  OfflineFetcher: () => OfflineFetcher,
  OgmiosProvider: () => OgmiosProvider,
  U5CProvider: () => U5CProvider,
  YaciProvider: () => YaciProvider
});
module.exports = __toCommonJS(index_exports);

// src/begin.ts
var import_axios2 = __toESM(require("axios"), 1);

// src/utils/parse-http-error.ts
var import_axios = __toESM(require("axios"), 1);
var parseHttpError = (error) => {
  if (import_axios.default.isAxiosError(error)) {
    if (error.response) {
      return JSON.stringify({
        data: error.response.data,
        headers: error.response.headers,
        status: error.response.status
      });
    } else if (error.request && !(error.request instanceof XMLHttpRequest)) {
      return JSON.stringify(error.request);
    } else {
      return JSON.stringify({ code: error.code, message: error.message });
    }
  } else {
    return JSON.stringify(error);
  }
};

// src/utils/parse-asset-unit.ts
var import_common = require("@meshsdk/common");
var parseAssetUnit = (unit) => {
  const policyId = unit.slice(0, import_common.POLICY_ID_LENGTH);
  const assetName = unit.includes(".") ? (0, import_common.fromUTF8)(unit.split(".")[1] || "") : unit.slice(import_common.POLICY_ID_LENGTH);
  return { policyId, assetName };
};

// src/utils/get-additional-utxos.ts
var import_common2 = require("@meshsdk/common");
var import_core_cst = require("@meshsdk/core-cst");
function getTransactionOutputsFromCbor(txCbor) {
  const tx = (0, import_core_cst.deserializeTx)(txCbor);
  const txBody = tx.body();
  const txHash = tx.getId();
  const outputs = txBody.outputs();
  const utxos = [];
  for (let i = 0; i < outputs.length; i++) {
    const output = outputs[i];
    if (output) {
      const txInput = new import_core_cst.TransactionInput((0, import_core_cst.TransactionId)(txHash), BigInt(i));
      const txUnspentOutput = new import_core_cst.TransactionUnspentOutput(txInput, output);
      const utxo = (0, import_core_cst.fromTxUnspentOutput)(txUnspentOutput);
      utxos.push(utxo);
    }
  }
  return utxos;
}
function getAdditionalUtxos(format, additionalUtxos, additionalTxs) {
  const foundUtxos = /* @__PURE__ */ new Set();
  const uniqueUtxos = [];
  if (!additionalUtxos && !additionalTxs) return [];
  if (additionalUtxos) {
    for (const utxo of additionalUtxos) {
      addUniqueUtxo(utxo, foundUtxos, uniqueUtxos);
    }
  }
  if (additionalTxs) {
    for (const txCbor of additionalTxs) {
      const utxos = getTransactionOutputsFromCbor(txCbor);
      for (const utxo of utxos) {
        addUniqueUtxo(utxo, foundUtxos, uniqueUtxos);
      }
    }
  }
  const result = {
    blockfrost: uniqueUtxos.map((utxo) => {
      const txIn = {
        txId: utxo.input.txHash,
        index: utxo.input.outputIndex
      };
      const value = parseValueForBlockfrost(utxo);
      const txOut = {
        address: utxo.output.address,
        value
      };
      return [txIn, txOut];
    }),
    maestro: uniqueUtxos.map((utxo) => {
      const txUnspentOutput = (0, import_core_cst.toTxUnspentOutput)(utxo);
      const cborHex = txUnspentOutput.output().toCbor();
      return {
        tx_hash: utxo.input.txHash,
        index: utxo.input.outputIndex,
        txout_cbor: cborHex
      };
    }),
    koios: uniqueUtxos.map((utxo) => {
      return {
        transaction: {
          id: utxo.input.txHash
        },
        index: utxo.input.outputIndex,
        address: utxo.output.address,
        value: parseValueForOgmios(utxo)
      };
    }),
    ogmios: uniqueUtxos.map((utxo) => {
      return {
        transaction: {
          id: utxo.input.txHash
        },
        index: utxo.input.outputIndex,
        address: utxo.output.address,
        value: parseValueForOgmios(utxo)
      };
    })
  };
  return result[format];
}
var parseValueForBlockfrost = (utxo) => {
  const value = {};
  utxo.output.amount.forEach(({ unit, quantity }) => {
    if (unit === "lovelace") {
      value.coins = Number(quantity);
    } else {
      const { policyId, assetName } = (0, import_common2.parseAssetUnit)(unit);
      if (!value[policyId]) {
        value[policyId] = {};
      }
      value[policyId][assetName] = Number(quantity);
    }
  });
  return value;
};
var parseValueForOgmios = (utxo) => {
  const value = {};
  utxo.output.amount.forEach(({ unit, quantity }) => {
    if (unit === "lovelace") {
      value.ada = { lovelace: Number(quantity) };
    } else {
      const { policyId, assetName } = (0, import_common2.parseAssetUnit)(unit);
      if (!value[policyId]) {
        value[policyId] = {};
      }
      value[policyId][assetName] = Number(quantity);
    }
  });
  return value;
};
var addUniqueUtxo = (utxo, set, list) => {
  const key = `${utxo.input.txHash}:${utxo.input.outputIndex}`;
  if (!set.has(key)) {
    set.add(key);
    list.push(utxo);
  }
};

// src/begin.ts
var BeginProvider = class {
  apikey;
  chainNumber = 1815;
  domainUrl = ".bgin.id";
  /**
   * Creates a new instance of the BeginProvider.
   * @param apikey The API key for querying Begin ID.
   */
  constructor(apikey) {
    this.apikey = apikey ?? "31cab9edcc1c530e29924a56167d4ed17d50b7fds";
  }
  /**
   * Given a Begin ID, resolves the address and other information.
   * @param name name of Begin ID, e.g. `mesh`
   * @param url optional URL to override the default: https://resolveidaddress-ylo5dtxzdq-uc.a.run.app
   * @returns
   * - name: string
   * - domain: string
   * - image: string
   * - address: string
   */
  async resolveAddress(name, url) {
    try {
      const axiosInstance = import_axios2.default.create({
        baseURL: url ?? "https://resolveidaddress-ylo5dtxzdq-uc.a.run.app",
        headers: {
          "Content-Type": "application/json",
          Authorization: this.apikey
        }
      });
      const { data, status } = await axiosInstance.post(``, {
        name: name.replace("@", "").replace(/(\.bgin\.id|\.beginid\.io|\.bgn\.is)$/, ""),
        chain: this.chainNumber
      });
      if (status === 200) {
        const result = data.result;
        return {
          name: result.name,
          domain: `${"".concat(result.name, this.domainUrl)}`,
          image: result.image,
          address: result.addresses[this.chainNumber]
        };
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Given an address, resolves the Begin ID and other information.
   * @param address address to resolve
   * @param url optional URL to override the default: https://resolveIdReserveAddress-ylo5dtxzdq-uc.a.run.app
   * @returns
   * - name: string
   * - domain: string
   * - image: string
   * - address: string
   */
  async resolveAdressReverse(address, url) {
    try {
      const axiosInstance = import_axios2.default.create({
        baseURL: url ?? "https://resolveIdReserveAddress-ylo5dtxzdq-uc.a.run.app",
        headers: {
          "Content-Type": "application/json",
          Authorization: this.apikey
        }
      });
      const { data, status } = await axiosInstance.post(``, {
        address,
        chain: this.chainNumber
      });
      if (status === 200) {
        const result = data.result;
        return {
          name: result.name,
          domain: `${"".concat(result.name, this.domainUrl)}`,
          image: result.image,
          address: result.addresses[this.chainNumber]
        };
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
};

// src/blockfrost.ts
var import_axios3 = __toESM(require("axios"), 1);
var import_common4 = require("@meshsdk/common");
var import_core_cst3 = require("@meshsdk/core-cst");

// src/common/utxos-to-assets.ts
function utxosToAssets(utxos) {
  const _balance = utxos.map((utxo) => {
    return utxo.output.amount;
  }).reduce(
    (acc, amount) => {
      for (const asset of amount) {
        if (asset) {
          if (acc[asset.unit] == void 0) {
            acc[asset.unit] = 0;
          }
          if (asset.unit in acc) {
            acc[asset.unit] += parseFloat(asset.quantity);
          }
        }
      }
      return acc;
    },
    {}
  );
  return Object.fromEntries(
    Object.entries(_balance).map(([key, value]) => [key, value.toString()])
  );
}

// src/offline/offline-fetcher.ts
var import_crypto = require("crypto");
var import_common3 = require("@meshsdk/common");
var import_core_cst2 = require("@meshsdk/core-cst");
var OfflineFetcher = class _OfflineFetcher {
  constructor(network) {
    this.network = network;
  }
  accounts = {};
  utxos = {};
  assetAddresses = {};
  assetMetadata = {};
  blocks = {};
  collections = {};
  protocolParameters = {};
  transactions = {};
  paginate(items, cursor, pageSize = 20) {
    const startIndex = cursor != null ? parseInt(String(cursor), 10) : 0;
    const paginatedItems = items.slice(startIndex, startIndex + pageSize);
    const nextCursor = startIndex + pageSize < items.length ? startIndex + pageSize : void 0;
    return { paginatedItems, nextCursor };
  }
  /**
   * Fetches account information for a given address.
   * @param address - Address to fetch info for
   * @returns Promise resolving to account information
   * @throws Error if account not found
   */
  async fetchAccountInfo(address) {
    const account = this.accounts[address];
    if (!account) throw new Error(`Account not found: ${address}`);
    return account;
  }
  /**
   * Fetches UTXOs for a given address, optionally filtered by asset.
   * @param address - Address to fetch UTXOs for
   * @param asset - Optional asset ID to filter UTXOs
   * @returns Promise resolving to array of UTXOs
   */
  async fetchAddressUTxOs(address, asset) {
    const addressUtxos = this.utxos[address] || [];
    return asset ? addressUtxos.filter(
      (utxo) => utxo.output.amount.some((a) => a.unit === asset)
    ) : addressUtxos;
  }
  /**
   * WIP - NOT IMPLEMENTED
   * @param address
   * @param options
   */
  fetchAddressTxs(address, options) {
    throw new Error("Method not implemented.");
  }
  /**
   * Fetches addresses holding a specific asset.
   * @param asset - Asset identifier
   * @returns Promise resolving to array of asset addresses and quantities
   */
  async fetchAssetAddresses(asset) {
    if (!_OfflineFetcher.isValidHex(asset)) {
      throw new Error("Invalid asset: must be a hex string");
    }
    const addressMap = /* @__PURE__ */ new Map();
    const registryAddresses = this.assetAddresses[asset] || [];
    for (const addr of registryAddresses) {
      addressMap.set(addr.address, BigInt(addr.quantity));
    }
    for (const [address, utxos] of Object.entries(this.utxos)) {
      for (const utxo of utxos) {
        const assetAmount = utxo.output.amount.find(
          (amt) => amt.unit === asset
        );
        if (assetAmount) {
          const currentAmount = addressMap.get(address) || BigInt(0);
          addressMap.set(address, currentAmount + BigInt(assetAmount.quantity));
        }
      }
    }
    return Array.from(addressMap.entries()).filter(([_, quantity]) => quantity > BigInt(0)).map(([address, quantity]) => ({
      address,
      quantity: quantity.toString()
    }));
  }
  /**
   * Fetches all assets associated with an address.
   * @param address - Address to fetch assets for
   * @returns Promise resolving to array of assets held by the address
   */
  async fetchAddressAssets(address) {
    if (!_OfflineFetcher.isValidAddress(address)) {
      throw new Error(
        "Invalid address: must be a valid Bech32 or Base58 address"
      );
    }
    const assetMap = /* @__PURE__ */ new Map();
    const addressUtxos = this.utxos[address] || [];
    for (const utxo of addressUtxos) {
      for (const amount of utxo.output.amount) {
        const currentAmount = assetMap.get(amount.unit) || BigInt(0);
        assetMap.set(amount.unit, currentAmount + BigInt(amount.quantity));
      }
    }
    for (const [assetId, addresses] of Object.entries(this.assetAddresses)) {
      const assetAddress = addresses.find((addr) => addr.address === address);
      if (assetAddress) {
        const currentAmount = assetMap.get(assetId) || BigInt(0);
        assetMap.set(assetId, currentAmount + BigInt(assetAddress.quantity));
      }
    }
    return Array.from(assetMap.entries()).map(([unit, quantity]) => ({
      unit,
      quantity: quantity.toString()
    }));
  }
  /**
   * Fetches metadata for a specific asset.
   * @param asset - Asset identifier
   * @returns Promise resolving to asset metadata
   * @throws Error if asset metadata not found
   */
  async fetchAssetMetadata(asset) {
    const metadata = this.assetMetadata[asset];
    if (!metadata) throw new Error(`Asset metadata not found: ${asset}`);
    return metadata;
  }
  /**
   * Fetches information about a specific block.
   * @param hash - Block hash
   * @returns Promise resolving to block information
   * @throws Error if block not found
   */
  async fetchBlockInfo(hash) {
    const block = this.blocks[hash];
    if (!block) throw new Error(`Block not found: ${hash}`);
    return block;
  }
  /**
   * Fetches assets in a collection (by policy ID) with pagination.
   * @param policyId - Policy ID of the collection
   * @param cursor - Optional pagination cursor
   * @returns Promise resolving to paginated assets and next cursor
   * @throws Error if collection not found or invalid cursor
   */
  async fetchCollectionAssets(policyId, cursor) {
    const assets = this.collections[policyId];
    if (!assets) throw new Error(`Collection not found: ${policyId}`);
    if (cursor && !_OfflineFetcher.isIntegerString(String(cursor))) {
      throw new Error("Invalid cursor: must be a string of digits");
    }
    const { paginatedItems, nextCursor } = this.paginate(assets, cursor);
    return { assets: paginatedItems, next: nextCursor };
  }
  /**
   * Fetches metadata for a handle.
   * @param handle - Handle to fetch metadata for
   * @returns Promise resolving to handle metadata
   * @throws Error if handle not found or invalid
   */
  async fetchHandle(handle) {
    try {
      const assetName = (0, import_common3.fromUTF8)(handle.replace("$", ""));
      const handleAsset = `${import_common3.SUPPORTED_HANDLES[1]}000de140${assetName}`;
      return await this.fetchAssetMetadata(handleAsset);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches address associated with a handle.
   * @param handle - Handle to fetch address for
   * @returns Promise resolving to address
   * @throws Error if no address found for handle
   */
  async fetchHandleAddress(handle) {
    const assetName = (0, import_common3.fromUTF8)(handle.replace("$", ""));
    const policyId = import_common3.SUPPORTED_HANDLES[1];
    const addresses = await this.fetchAssetAddresses(`${policyId}${assetName}`);
    const address = addresses[0]?.address;
    if (!address) {
      throw new Error(`No addresses found for handle: ${handle}`);
    }
    return address;
  }
  /**
   * Fetches protocol parameters for a specific epoch.
   * @param epoch - Epoch number
   * @returns Promise resolving to protocol parameters
   * @throws Error if parameters not found for epoch
   */
  async fetchProtocolParameters(epoch) {
    if (!epoch) {
      const maxEpochNumber = Math.max(
        ...Object.keys(this.protocolParameters).map(Number)
      );
      return this.protocolParameters[maxEpochNumber];
    }
    const parameters = this.protocolParameters[epoch];
    if (!parameters)
      throw new Error(`Protocol parameters not found for epoch: ${epoch}`);
    return parameters;
  }
  /**
   * Fetches information about a specific transaction.
   * @param hash - Transaction hash
   * @returns Promise resolving to transaction information
   * @throws Error if transaction not found
   */
  async fetchTxInfo(hash) {
    const transaction = this.transactions[hash];
    if (!transaction) throw new Error(`Transaction not found: ${hash}`);
    return transaction;
  }
  /**
   * Fetches all UTXOs associated with a specific transaction hash.
   * @param hash - Transaction hash to fetch UTXOs for
   * @returns Promise resolving to array of UTXOs associated with the transaction
   * @throws Error if no UTXOs found for the transaction hash
   */
  async fetchUTxOs(hash) {
    const utxos = Object.values(this.utxos).flat().filter((utxo) => utxo.input.txHash === hash);
    if (!utxos.length)
      throw new Error(`No UTxOs found for transaction hash: ${hash}`);
    return utxos;
  }
  async fetchGovernanceProposal(txHash, certIndex) {
    throw new Error("Method not implemented");
  }
  /**
   * HTTP GET method required by IFetcher interface but not implemented in OfflineFetcher.
   * @param url - URL to fetch from
   * @throws Error always, as this fetcher operates offline
   */
  async get(url) {
    throw new Error("Method not implemented in OfflineFetcher.");
  }
  /**
   * Serializes fetcher data to JSON string.
   * @returns JSON string containing all fetcher data
   */
  toJSON() {
    return JSON.stringify({
      accounts: this.accounts,
      utxos: this.utxos,
      assetAddresses: this.assetAddresses,
      assetMetadata: this.assetMetadata,
      blocks: this.blocks,
      collections: this.collections,
      protocolParameters: this.protocolParameters,
      transactions: this.transactions
    });
  }
  /**
   * Creates an OfflineFetcher instance from JSON data.
   * @param json - JSON string containing fetcher data
   * @returns New OfflineFetcher instance
   */
  static fromJSON(json) {
    const data = JSON.parse(json);
    const fetcher = new _OfflineFetcher();
    Object.entries(data.accounts || {}).forEach(
      ([address, info]) => fetcher.addAccount(address, info)
    );
    Object.entries(data.utxos || {}).forEach(
      ([address, utxos]) => fetcher.addUTxOs(utxos)
    );
    Object.entries(data.assetAddresses || {}).forEach(
      ([asset, addresses]) => fetcher.addAssetAddresses(asset, addresses)
    );
    Object.entries(data.assetMetadata || {}).forEach(
      ([asset, metadata]) => fetcher.addAssetMetadata(asset, metadata)
    );
    Object.entries(data.blocks || {}).forEach(
      ([_, info]) => fetcher.addBlock(info)
    );
    Object.entries(data.collections || {}).forEach(
      ([policyId, assets]) => fetcher.addCollectionAssets(assets)
    );
    Object.entries(data.protocolParameters || {}).forEach(
      ([_, params]) => fetcher.addProtocolParameters(params)
    );
    Object.entries(data.transactions || {}).forEach(
      ([_, info]) => fetcher.addTransaction(info)
    );
    return fetcher;
  }
  static isValidHex(str, length) {
    if (length && str.length !== length) {
      return false;
    }
    return /^[0-9a-fA-F]+$/.test(str);
  }
  static isValidAddress(address) {
    return _OfflineFetcher.isValidBech32Address(address) || _OfflineFetcher.isValidBase58(address);
  }
  static isValidBase58(input) {
    const base58Regex = /^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/;
    if (!base58Regex.test(input)) {
      return false;
    }
    return true;
  }
  static isValidBech32(input, prefix) {
    if (input !== input.toLowerCase() && input !== input.toUpperCase()) {
      return false;
    }
    const pattern = new RegExp(`^${prefix}1[02-9ac-hj-np-z]+$`, "i");
    return pattern.test(input);
  }
  static isValidBech32Address(address) {
    return _OfflineFetcher.isValidBech32(address, "(addr|addr_test)");
  }
  static isValidBech32Pool(poolId) {
    return _OfflineFetcher.isValidBech32(poolId, "pool");
  }
  static isValidBech32VrfVk(vrfKey) {
    return _OfflineFetcher.isValidBech32(vrfKey, "vrf_vk");
  }
  static isIntegerString(str) {
    return /^\d+$/.test(str);
  }
  static isValidAssetOrLovelace(asset) {
    if (asset === "lovelace") {
      return true;
    }
    if (asset.length < 56) {
      return false;
    }
    return _OfflineFetcher.isValidHex(asset);
  }
  /**
   * Adds account information to the fetcher.
   * @param address - Account address
   * @param accountInfo - Account information
   * @throws Error if address or account info invalid
   */
  addAccount(address, accountInfo) {
    if (!_OfflineFetcher.isValidAddress(address)) {
      throw new Error(
        "Invalid address: must be a valid Bech32 or Base58 address"
      );
    }
    if (accountInfo.poolId) {
      if (!_OfflineFetcher.isValidBech32Pool(accountInfo.poolId)) {
        throw new Error(
          "Invalid 'poolId': must be a valid Bech32 pool address"
        );
      }
    }
    if (!_OfflineFetcher.isIntegerString(accountInfo.balance)) {
      throw new Error("Invalid 'balance': must be a string of digits");
    }
    if (!_OfflineFetcher.isIntegerString(accountInfo.rewards)) {
      throw new Error("Invalid 'rewards': must be a string of digits");
    }
    if (!_OfflineFetcher.isIntegerString(accountInfo.withdrawals)) {
      throw new Error("Invalid 'withdrawals': must be a string of digits");
    }
    this.accounts[address] = accountInfo;
  }
  /**
   * Adds UTXOs to the fetcher.
   * @param utxos - Array of UTXOs
   * @throws Error if UTXOs invalid
   */
  addUTxOs(utxos) {
    if (!Array.isArray(utxos) || utxos.length === 0) {
      throw new Error("Invalid utxos: must be a non-empty array");
    }
    utxos.forEach((utxo, index) => {
      if (!Number.isInteger(utxo.input.outputIndex) || utxo.input.outputIndex < 0) {
        throw new Error(
          `Invalid outputIndex for UTxO at index ${index}: must be a non-negative integer`
        );
      }
      if (!_OfflineFetcher.isValidHex(utxo.input.txHash, 64)) {
        throw new Error(
          `Invalid txHash for UTxO at index ${index}: must be a 64-character hexadecimal string`
        );
      }
      if (!_OfflineFetcher.isValidAddress(utxo.output.address)) {
        throw new Error(
          `Invalid address in output for UTxO at index ${index}: must be a valid Bech32 or Base58 address`
        );
      }
      if (!Array.isArray(utxo.output.amount) || utxo.output.amount.length === 0) {
        throw new Error(
          `Invalid amount for UTxO at index ${index}: must be a non-empty array of assets`
        );
      }
      utxo.output.amount.forEach((asset, assetIndex) => {
        if (!_OfflineFetcher.isValidAssetOrLovelace(asset.unit)) {
          throw new Error(
            `Invalid unit for asset at index ${assetIndex} in UTxO at index ${index}`
          );
        }
        if (!_OfflineFetcher.isIntegerString(asset.quantity)) {
          throw new Error(
            `Invalid quantity for asset at index ${assetIndex} in UTxO at index ${index}: must be a string of digits`
          );
        }
      });
      if (utxo.output.dataHash && !_OfflineFetcher.isValidHex(utxo.output.dataHash, 64)) {
        throw new Error(
          `Invalid dataHash for UTxO at index ${index}: must be a 64-character hexadecimal string or undefined`
        );
      }
      if (utxo.output.plutusData && !_OfflineFetcher.isValidHex(utxo.output.plutusData)) {
        throw new Error(
          `Invalid plutusData for UTxO at index ${index}: must be a hexadecimal string or undefined`
        );
      }
      if (utxo.output.scriptRef && !_OfflineFetcher.isValidHex(utxo.output.scriptRef)) {
        throw new Error(
          `Invalid scriptRef for UTxO at index ${index}: must be a hexadecimal string or undefined`
        );
      }
      if (utxo.output.scriptHash && !_OfflineFetcher.isValidHex(utxo.output.scriptHash, 56)) {
        throw new Error(
          `Invalid scriptHash for UTxO at index ${index}: must be a 56-character hexadecimal string or undefined`
        );
      }
    });
    for (const utxo of utxos) {
      if (!this.utxos[utxo.output.address]) {
        this.utxos[utxo.output.address] = [];
      }
      this.utxos[utxo.output.address].push(utxo);
    }
  }
  /**
   * Adds asset address information to the fetcher.
   * @param asset - Asset identifier
   * @param addresses - Array of asset addresses
   * @throws Error if asset or addresses invalid
   */
  addAssetAddresses(asset, addresses) {
    if (!_OfflineFetcher.isValidHex(asset)) {
      throw new Error("Invalid asset: must be a hex string");
    }
    if (addresses.length === 0) {
      throw new Error("Invalid addresses: must be a non-empty array");
    }
    addresses.forEach((item, index) => {
      if (!_OfflineFetcher.isValidAddress(item.address)) {
        throw new Error(
          `Invalid 'address' field at index ${index}, should be bech32 string`
        );
      }
      if (!_OfflineFetcher.isIntegerString(item.quantity)) {
        throw new Error(
          `Invalid 'quantity' field at index ${index}, should be a string of digits`
        );
      }
    });
    this.assetAddresses[asset] = addresses;
  }
  /**
   * Adds asset metadata to the fetcher.
   * @param asset - Asset identifier
   * @param metadata - Asset metadata
   * @throws Error if asset or metadata invalid
   */
  addAssetMetadata(asset, metadata) {
    if (asset.length < 56) {
      throw new Error(
        `Invalid asset ${asset}: must be a string longer than 56 characters`
      );
    }
    if (!_OfflineFetcher.isValidHex(asset)) {
      throw new Error("Invalid asset: must be a hex string");
    }
    if (typeof metadata !== "object" || metadata === null) {
      throw new Error("Invalid metadata object");
    }
    this.assetMetadata[asset] = metadata;
  }
  /**
   * Adds collection assets to the fetcher.
   * @param assets - Array of assets
   * @throws Error if assets invalid
   */
  addCollectionAssets(assets) {
    if (!Array.isArray(assets) || assets.length === 0) {
      throw new Error("Invalid assets: must be a non-empty array");
    }
    const groupedAssets = {};
    assets.forEach((asset, index) => {
      if (asset.unit.length < 56) {
        throw new Error(
          `Invalid unit for asset at index ${index}: must be a string longer than 56 characters`
        );
      }
      if (!_OfflineFetcher.isValidHex(asset.unit)) {
        throw new Error(
          `Invalid unit for asset at index ${index}: must be a hexadecimal string`
        );
      }
      const policyId = asset.unit.slice(0, 56);
      if (!_OfflineFetcher.isValidHex(policyId, 56)) {
        throw new Error(
          `Invalid policyId in asset unit at index ${index}: must be a 56-character hexadecimal string`
        );
      }
      if (!_OfflineFetcher.isIntegerString(asset.quantity)) {
        throw new Error(
          `Invalid quantity for asset at index ${index}: must be a string of digits`
        );
      }
      if (!groupedAssets[policyId]) {
        groupedAssets[policyId] = [];
      }
      groupedAssets[policyId].push(asset);
    });
    for (const [policyId, policyAssets] of Object.entries(groupedAssets)) {
      if (!this.collections[policyId]) {
        this.collections[policyId] = [];
      }
      this.collections[policyId] = this.collections[policyId].concat(policyAssets);
    }
  }
  /**
   * Adds protocol parameters to the fetcher.
   * @param parameters - Protocol parameters
   * @throws Error if parameters invalid
   */
  addProtocolParameters(parameters) {
    if (parameters.epoch < 0 || !Number.isInteger(parameters.epoch)) {
      throw new Error("Invalid epoch: must be a non-negative integer");
    }
    if (parameters.minFeeA < 0 || !Number.isInteger(parameters.minFeeA)) {
      throw new Error("Invalid 'minFeeA': must be a non-negative integer");
    }
    if (parameters.minFeeB < 0 || !Number.isInteger(parameters.minFeeB)) {
      throw new Error("Invalid 'minFeeB': must be a non-negative integer");
    }
    if (parameters.maxBlockSize <= 0 || !Number.isInteger(parameters.maxBlockSize)) {
      throw new Error("Invalid 'maxBlockSize': must be a positive integer");
    }
    if (parameters.maxTxSize <= 0 || !Number.isInteger(parameters.maxTxSize)) {
      throw new Error("Invalid 'maxTxSize': must be a positive integer");
    }
    if (parameters.maxBlockHeaderSize <= 0 || !Number.isInteger(parameters.maxBlockHeaderSize)) {
      throw new Error(
        "Invalid 'maxBlockHeaderSize': must be a positive integer"
      );
    }
    if (parameters.keyDeposit < 0 || !Number.isInteger(parameters.keyDeposit)) {
      throw new Error("Invalid 'keyDeposit': must be a non-negative integer");
    }
    if (parameters.poolDeposit < 0 || !Number.isInteger(parameters.poolDeposit)) {
      throw new Error("Invalid 'poolDeposit': must be a non-negative integer");
    }
    if (parameters.decentralisation < 0 || parameters.decentralisation > 1) {
      throw new Error("Invalid 'decentralisation': must be between 0 and 1");
    }
    if (parameters.priceMem < 0) {
      throw new Error("Invalid 'priceMem': must be non-negative");
    }
    if (parameters.priceStep < 0) {
      throw new Error("Invalid 'priceStep': must be non-negative");
    }
    if (parameters.maxValSize < 0 || !Number.isInteger(parameters.maxValSize)) {
      throw new Error("Invalid 'maxValSize': must be a non-negative integer");
    }
    if (parameters.collateralPercent < 0) {
      throw new Error(
        "Invalid 'collateralPercent': must be a non-negative integer"
      );
    }
    if (parameters.maxCollateralInputs < 0 || !Number.isInteger(parameters.maxCollateralInputs)) {
      throw new Error(
        "Invalid 'maxCollateralInputs': must be a non-negative integer"
      );
    }
    if (parameters.coinsPerUtxoSize < 0) {
      throw new Error("Invalid 'coinsPerUtxoSize': must be non-negative");
    }
    if (parameters.minFeeRefScriptCostPerByte < 0) {
      throw new Error(
        "Invalid 'minFeeRefScriptCostPerByte': must be non-negative"
      );
    }
    if (!_OfflineFetcher.isIntegerString(parameters.minPoolCost)) {
      throw new Error("Invalid 'minPoolCost': must be a string of digits");
    }
    if (!_OfflineFetcher.isIntegerString(parameters.maxTxExMem)) {
      throw new Error("Invalid 'maxTxExMem': must be a string of digits");
    }
    if (!_OfflineFetcher.isIntegerString(parameters.maxTxExSteps)) {
      throw new Error("Invalid 'maxTxExSteps': must be a string of digits");
    }
    if (!_OfflineFetcher.isIntegerString(parameters.maxBlockExMem)) {
      throw new Error("Invalid 'maxBlockExMem': must be a string of digits");
    }
    if (!_OfflineFetcher.isIntegerString(parameters.maxBlockExSteps)) {
      throw new Error("Invalid 'maxBlockExSteps': must be a string of digits");
    }
    this.protocolParameters[parameters.epoch] = parameters;
  }
  /**
   * Adds transaction information to the fetcher.
   * @param txInfo - Transaction information
   * @throws Error if transaction info invalid
   */
  addTransaction(txInfo) {
    if (!_OfflineFetcher.isValidHex(txInfo.hash, 64)) {
      throw new Error(
        "Invalid transaction hash: must be a 64-character hexadecimal string"
      );
    }
    if (!Number.isInteger(txInfo.index) || txInfo.index < 0) {
      throw new Error("Invalid 'index': must be a non-negative integer");
    }
    if (!_OfflineFetcher.isValidHex(txInfo.block, 64)) {
      throw new Error(
        "Invalid 'block': must be a 64-character hexadecimal string"
      );
    }
    if (!_OfflineFetcher.isIntegerString(txInfo.slot)) {
      throw new Error("Invalid 'slot': must be a string of digits");
    }
    if (!_OfflineFetcher.isIntegerString(txInfo.fees)) {
      throw new Error("Invalid 'fees': must be a string of digits");
    }
    if (!Number.isInteger(txInfo.size) || txInfo.size <= 0) {
      throw new Error("Invalid 'size': must be a positive integer");
    }
    if (!/^-?\d+$/.test(txInfo.deposit)) {
      throw new Error(
        "Invalid 'deposit': must be a string representing an integer (positive or negative)"
      );
    }
    if (txInfo.invalidBefore !== "" && !_OfflineFetcher.isIntegerString(txInfo.invalidBefore)) {
      throw new Error(
        "Invalid 'invalidBefore': must be a string of digits or empty string"
      );
    }
    if (txInfo.invalidAfter !== "" && !_OfflineFetcher.isIntegerString(txInfo.invalidAfter)) {
      throw new Error(
        "Invalid 'invalidAfter': must be a string of digits or empty string"
      );
    }
    this.transactions[txInfo.hash] = txInfo;
    this.addUTxOs(txInfo.outputs);
  }
  /**
   * Adds block information to the fetcher.
   * @param blockInfo - Block information
   * @throws Error if block info invalid
   */
  addBlock(blockInfo) {
    if (!_OfflineFetcher.isValidHex(blockInfo.hash, 64)) {
      throw new Error(
        "Invalid block hash: must be a 64-character hexadecimal string"
      );
    }
    if (!Number.isInteger(blockInfo.time) || blockInfo.time < 0) {
      throw new Error("Invalid 'time': must be a non-negative integer");
    }
    if (!_OfflineFetcher.isIntegerString(blockInfo.slot)) {
      throw new Error("Invalid 'slot': must be a string of digits");
    }
    if (!Number.isInteger(blockInfo.epoch) || blockInfo.epoch < 0) {
      throw new Error("Invalid 'epoch': must be a non-negative integer");
    }
    if (!_OfflineFetcher.isIntegerString(blockInfo.epochSlot)) {
      throw new Error("Invalid 'epochSlot': must be a string of digits");
    }
    if (!_OfflineFetcher.isValidBech32Pool(blockInfo.slotLeader)) {
      throw new Error(
        "Invalid 'slotLeader': must be a bech32 string with pool prefix"
      );
    }
    if (!Number.isInteger(blockInfo.size) || blockInfo.size <= 0) {
      throw new Error("Invalid 'size': must be a positive integer");
    }
    if (!Number.isInteger(blockInfo.txCount) || blockInfo.txCount < 0) {
      throw new Error("Invalid 'txCount': must be a non-negative integer");
    }
    if (!_OfflineFetcher.isIntegerString(blockInfo.output)) {
      throw new Error("Invalid 'output': must be a string of digits");
    }
    if (!_OfflineFetcher.isValidHex(blockInfo.operationalCertificate, 64)) {
      throw new Error(
        "Invalid 'operationalCertificate': must be a 64-character hexadecimal string"
      );
    }
    if (!_OfflineFetcher.isValidHex(blockInfo.previousBlock, 64)) {
      throw new Error(
        "Invalid 'previousBlock': must be a 64-character hexadecimal string"
      );
    }
    if (!_OfflineFetcher.isValidBech32VrfVk(blockInfo.VRFKey)) {
      throw new Error(
        "Invalid 'VRFKey': must be a bech32 string with vrf_vk1 prefix"
      );
    }
    this.blocks[blockInfo.hash] = blockInfo;
  }
  /**
   * Adds a serialized transaction to the fetcher, it's generates pseudo block in addition to transaction.
   * Removes spent UTxOs from the fetcher and adds new UTxOs from the transaction.
   * @param txHex - Hexadecimal string of the transaction
   * @throws Error if transaction hex invalid
   */
  addSerializedTransaction(txHex) {
    const tx = import_core_cst2.Serialization.Transaction.fromCbor(import_core_cst2.Serialization.TxCBOR(txHex));
    const time = Date.now();
    const slot = (0, import_common3.resolveSlotNo)(this.network ?? "mainnet", time);
    const epoch = (0, import_common3.resolveEpochNo)(this.network ?? "mainnet", time);
    const epochSlot = this.slotToEpochSlot(BigInt(slot));
    const randomBlockHash = (0, import_crypto.randomBytes)(32).toString("hex");
    const randomPrevBlockHash = (0, import_crypto.randomBytes)(32).toString("hex");
    const randomOCert = (0, import_crypto.randomBytes)(32).toString("hex");
    const fee = tx.body().fee().toString();
    const totalOutput = tx.body().outputs().reduce((acc, output) => {
      const amount = output.amount().coin();
      return acc + amount;
    }, 0n);
    const ttl = tx.body().ttl();
    const validityStartInterval = tx.body().validityStartInterval();
    const txHash = tx.body().hash();
    const blockInfo = {
      confirmations: 40,
      nextBlock: "undefined its a random block",
      hash: randomBlockHash,
      time,
      slot,
      epoch,
      epochSlot: epochSlot.toString(),
      fees: fee,
      slotLeader: "pool1qv3x5x5x5x5x5x5x5x5x5x5x5x5x5x5",
      size: txHex.length / 2,
      txCount: 1,
      output: totalOutput.toString(),
      operationalCertificate: randomOCert,
      previousBlock: randomPrevBlockHash,
      VRFKey: "vrf_vk1qv3x5x5x5x5x5x5x5x5x5x5x5x5x5"
    };
    const txInputs = tx.body().inputs();
    const fetchedUTxOs = txInputs.values().map((input) => {
      const txHash2 = input.transactionId();
      const outputIndex = Number(input.index());
      const utxo = Object.values(this.utxos).flat().find((utxo2) => {
        return utxo2.input.txHash === txHash2 && utxo2.input.outputIndex === outputIndex;
      });
      if (!utxo) {
        throw new Error(
          `UTxO not found for transaction hash and output index: ${txHash2} ${outputIndex}`
        );
      }
      return utxo;
    });
    for (const addressUtxos of Object.values(this.utxos)) {
      for (const utxo of fetchedUTxOs) {
        const index = addressUtxos.indexOf(utxo);
        if (index !== -1) {
          addressUtxos.splice(index, 1);
        }
      }
    }
    const newUtxOs = tx.body().outputs().map((output, index) => {
      return this.mapOutputToUTxO(output, txHash, index);
    });
    const transactionInfo = {
      inputs: fetchedUTxOs,
      hash: txHash,
      index: 0,
      block: randomBlockHash,
      slot: slot.toString(),
      fees: fee,
      size: txHex.length / 2,
      deposit: "0",
      invalidBefore: validityStartInterval ? validityStartInterval.toString() : "",
      invalidAfter: ttl ? ttl.toString() : "",
      outputs: newUtxOs
    };
    this.addBlock(blockInfo);
    this.addTransaction(transactionInfo);
  }
  slotToEpochSlot(slot) {
    const slotConfig = import_common3.SLOT_CONFIG_NETWORK[this.network ?? "mainnet"];
    const epochLength = BigInt(slotConfig.epochLength);
    return slot % epochLength;
  }
  mapOutputToUTxO(output, txHash, index) {
    return {
      input: {
        txHash,
        outputIndex: index
      },
      output: {
        address: output.address().toBech32(),
        amount: this.mapValueToAsset(output.amount()),
        dataHash: output.datum()?.asDataHash(),
        plutusData: output.datum()?.asInlineData()?.toCbor(),
        scriptRef: output.scriptRef()?.toCbor(),
        scriptHash: output.scriptRef()?.hash()
      }
    };
  }
  mapValueToAsset(value) {
    const assets = [];
    const multiAsset = value.multiasset();
    if (multiAsset) {
      for (const [assetId, quantity] of multiAsset) {
        const asset = {
          unit: assetId,
          quantity: quantity.toString()
        };
        assets.push(asset);
      }
    } else {
      const lovelace = value.coin().toString();
      assets.push({ unit: "lovelace", quantity: lovelace });
    }
    return assets;
  }
};

// src/blockfrost.ts
var BlockfrostProvider = class {
  _axiosInstance;
  _network;
  submitTxToBytes = true;
  _offlineFetcher;
  _enableCaching = false;
  constructor(...args) {
    let cachingOptions;
    if (typeof args[0] === "string" && (args[0].startsWith("http") || args[0].startsWith("/"))) {
      this._axiosInstance = import_axios3.default.create({ baseURL: args[0] });
      this._network = "mainnet";
      cachingOptions = args[1];
    } else {
      const projectId = args[0];
      const network = projectId.slice(0, 7);
      this._axiosInstance = import_axios3.default.create({
        baseURL: `https://cardano-${network}.blockfrost.io/api/v${args[1] ?? 0}`,
        headers: { project_id: projectId }
      });
      this._network = network;
      cachingOptions = args[2];
    }
    if (cachingOptions?.enableCaching) {
      this._enableCaching = true;
      this._offlineFetcher = cachingOptions.offlineFetcher || new OfflineFetcher(this._network);
    }
  }
  /**
   * Evaluates the resources required to execute the transaction
   * @param cbor - The transaction CBOR hex string to evaluate
   * @param additionalUtxos - Optional array of additional UTxOs to include in the evaluation context for resolving transaction inputs
   * @param additionalTxs - Optional array of transaction CBOR hex strings to provide additional UTxOs from their outputs
   */
  async evaluateTx(cbor2, additionalUtxos, additionalTxs) {
    const additionalUtxoSet = getAdditionalUtxos(
      "blockfrost",
      additionalUtxos,
      additionalTxs
    );
    const params = {
      cbor: cbor2,
      additionalUtxoSet
    };
    try {
      const headers = { "Content-Type": "application/json" };
      const { status, data } = await this._axiosInstance.post(
        "utils/txs/evaluate/utxos",
        params,
        {
          headers
        }
      );
      if (status === 200 && data.result.EvaluationResult) {
        const tagMap = {
          spend: "SPEND",
          mint: "MINT",
          certificate: "CERT",
          withdrawal: "REWARD"
        };
        const result = [];
        Object.keys(data.result.EvaluationResult).forEach((key) => {
          const [tagKey, index] = key.split(":");
          const { memory, steps } = data.result.EvaluationResult[key];
          result.push({
            tag: tagMap[tagKey],
            index: Number(index),
            budget: { mem: memory, steps }
          });
        });
        return result;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Obtain information about a specific stake account.
   * @param address - Wallet address to fetch account information
   */
  async fetchAccountInfo(address) {
    const rewardAddress = address.startsWith("addr") ? (0, import_core_cst3.resolveRewardAddress)(address) : address;
    try {
      const { data, status } = await this._axiosInstance.get(
        `accounts/${rewardAddress}`
      );
      if (status === 200 || status == 202)
        return {
          poolId: data.pool_id,
          active: data.active || data.active_epoch !== null,
          balance: data.controlled_amount,
          rewards: data.withdrawable_amount,
          withdrawals: data.withdrawals_sum
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the assets for a given address.
   * @param address - The address to fetch assets for
   * @returns A map of asset unit to quantity
   */
  async fetchAddressAssets(address) {
    const utxos = await this.fetchAddressUTxOs(address);
    return utxosToAssets(utxos);
  }
  /**
   * Transactions for an address. The `TransactionInfo` would only return the `hash`, `inputs`, and `outputs`.
   * @param address - The address to fetch transactions for
   * @returns - partial TransactionInfo
   */
  async fetchAddressTxs(address, option = import_common4.DEFAULT_FETCHER_OPTIONS) {
    const txs = [];
    try {
      const fetcherOptions = { ...import_common4.DEFAULT_FETCHER_OPTIONS, ...option };
      for (let i = 1; i <= fetcherOptions.maxPage; i++) {
        let { data, status } = await this._axiosInstance.get(
          `/addresses/${address}/transactions?page=${i}&order=${fetcherOptions.order}`
        );
        if (status !== 200) throw parseHttpError(data);
        if (data.length === 0) break;
        for (const tx of data) {
          const txInfo = await this.fetchTxInfo(tx.tx_hash);
          const _tx = {
            ...txInfo,
            blockHeight: tx.block_height,
            blockTime: tx.block_time
          };
          txs.push(_tx);
        }
      }
      return txs;
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Deprecated, use fetchAddressTxs instead
   * @param address
   * @returns - partial TransactionInfo
   */
  async fetchAddressTransactions(address) {
    return await this.fetchAddressTxs(address);
  }
  /**
   * UTXOs of the address.
   * @param address - The address to fetch UTXO
   * @param asset - UTXOs of a given assetâ€‹
   * @returns - Array of UTxOs
   */
  async fetchAddressUTxOs(address, asset) {
    if (this._enableCaching && this._offlineFetcher) {
      try {
        const cachedUtxos = await this._offlineFetcher.fetchAddressUTxOs(
          address,
          asset
        );
        if (cachedUtxos.length > 0) {
          return cachedUtxos;
        }
      } catch (error) {
      }
    }
    const filter = asset !== void 0 ? `/${asset}` : "";
    const url = `addresses/${address}/utxos` + filter;
    const paginateUTxOs = async (page = 1, utxos = []) => {
      const { data, status } = await this._axiosInstance.get(
        `${url}?page=${page}`
      );
      if (status === 200 || status == 202)
        return data.length > 0 ? paginateUTxOs(page + 1, [
          ...utxos,
          ...await Promise.all(
            data.map(
              (utxo) => this.toUTxO(utxo, utxo.tx_hash)
            )
          )
        ]) : utxos;
      throw parseHttpError(data);
    };
    try {
      const fetchedUtxos = await paginateUTxOs();
      if (this._enableCaching && this._offlineFetcher && fetchedUtxos.length > 0) {
        try {
          this._offlineFetcher.addUTxOs(fetchedUtxos);
        } catch (error) {
          console.warn("Failed to cache UTXOs:", error);
        }
      }
      return fetchedUtxos;
    } catch (error) {
      return [];
    }
  }
  /**
   * Fetches the asset addresses for a given asset.
   * @param asset - The asset to fetch addresses for
   */
  async fetchAssetAddresses(asset) {
    const paginateAddresses = async (page = 1, addresses = []) => {
      const { policyId, assetName } = parseAssetUnit(asset);
      const { data, status } = await this._axiosInstance.get(
        `assets/${policyId}${assetName}/addresses?page=${page}`
      );
      if (status === 200 || status == 202)
        return data.length > 0 ? paginateAddresses(page + 1, [...addresses, ...data]) : addresses;
      throw parseHttpError(data);
    };
    try {
      return await paginateAddresses();
    } catch (error) {
      return [];
    }
  }
  /**
   * Fetches the metadata for a given asset.
   * @param asset - The asset to fetch metadata for
   * @returns The metadata for the asset
   */
  async fetchAssetMetadata(asset) {
    try {
      const { policyId, assetName } = parseAssetUnit(asset);
      const { data, status } = await this._axiosInstance.get(
        `assets/${policyId}${assetName}`
      );
      if (status === 200 || status == 202)
        return {
          ...data.onchain_metadata,
          fingerprint: data.fingerprint,
          totalSupply: data.quantity,
          mintingTxHash: data.initial_mint_tx_hash,
          // todo: request for `initial_mint_tx_hash`
          mintCount: data.mint_or_burn_count
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the metadata for a given asset.
   * @param asset - The asset to fetch metadata for
   * @returns The metadata for the asset
   */
  async fetchLatestBlock() {
    try {
      const { data, status } = await this._axiosInstance.get(`blocks/latest`);
      if (status === 200 || status == 202)
        return {
          confirmations: data.confirmations,
          epoch: data.epoch,
          epochSlot: data.epoch_slot.toString(),
          fees: data.fees,
          hash: data.hash,
          nextBlock: data.next_block ?? "",
          operationalCertificate: data.op_cert,
          output: data.output ?? "0",
          previousBlock: data.previous_block,
          size: data.size,
          slot: data.slot.toString(),
          slotLeader: data.slot_leader ?? "",
          time: data.time,
          txCount: data.tx_count,
          VRFKey: data.block_vrf
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the block information for a given block hash.
   * @param hash The block hash to fetch from
   * @returns The block information
   */
  async fetchBlockInfo(hash) {
    try {
      const { data, status } = await this._axiosInstance.get(`blocks/${hash}`);
      if (status === 200 || status == 202)
        return {
          confirmations: data.confirmations,
          epoch: data.epoch,
          epochSlot: data.epoch_slot.toString(),
          fees: data.fees,
          hash: data.hash,
          nextBlock: data.next_block ?? "",
          operationalCertificate: data.op_cert,
          output: data.output ?? "0",
          previousBlock: data.previous_block,
          size: data.size,
          slot: data.slot.toString(),
          slotLeader: data.slot_leader ?? "",
          time: data.time,
          txCount: data.tx_count,
          VRFKey: data.block_vrf
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the list of assets for a given policy ID.
   * @param policyId The policy ID to fetch assets for
   * @param cursor The cursor for pagination
   * @returns The list of assets and the next cursor
   */
  async fetchCollectionAssets(policyId, cursor = 1) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `assets/policy/${policyId}?page=${cursor}`
      );
      if (status === 200 || status == 202)
        return {
          assets: data.map((asset) => ({
            unit: asset.asset,
            quantity: asset.quantity
          })),
          next: data.length === 100 ? cursor + 1 : null
        };
      throw parseHttpError(data);
    } catch (error) {
      return { assets: [], next: null };
    }
  }
  async fetchHandle(handle) {
    if (this._network !== "mainnet") {
      throw new Error(
        "Does not support fetching addresses by handle on non-mainnet networks."
      );
    }
    try {
      const assetName = (0, import_common4.fromUTF8)(`${handle.replace("$", "")}`);
      const asset = await this.fetchAssetMetadata(
        `${import_common4.SUPPORTED_HANDLES[1]}000de140${assetName}`
      );
      return asset;
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchHandleAddress(handle) {
    if (this._network !== "mainnet") {
      throw new Error(
        "Does not support fetching addresses by handle on non-mainnet networks."
      );
    }
    try {
      const assetName = (0, import_common4.fromUTF8)(handle.replace("$", ""));
      const { data, status } = await this._axiosInstance.get(
        `assets/${import_common4.SUPPORTED_HANDLES[1]}${assetName}/addresses`
      );
      if (status === 200 || status == 202) return data[0].address;
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetch the latest protocol parameters.
   * @param epoch Optional - The epoch to fetch protocol parameters for
   * @returns - Protocol parameters
   */
  async fetchProtocolParameters(epoch = Number.NaN) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `epochs/${isNaN(epoch) ? "latest" : epoch}/parameters`
      );
      if (status === 200 || status == 202)
        return (0, import_common4.castProtocol)({
          coinsPerUtxoSize: data.coins_per_utxo_word,
          collateralPercent: data.collateral_percent,
          decentralisation: data.decentralisation_param,
          epoch: data.epoch,
          keyDeposit: data.key_deposit,
          maxBlockExMem: data.max_block_ex_mem,
          maxBlockExSteps: data.max_block_ex_steps,
          maxBlockHeaderSize: data.max_block_header_size,
          maxBlockSize: data.max_block_size,
          maxCollateralInputs: data.max_collateral_inputs,
          maxTxExMem: data.max_tx_ex_mem,
          maxTxExSteps: data.max_tx_ex_steps,
          maxTxSize: data.max_tx_size,
          maxValSize: data.max_val_size,
          minFeeA: data.min_fee_a,
          minFeeB: data.min_fee_b,
          minPoolCost: data.min_pool_cost,
          poolDeposit: data.pool_deposit,
          priceMem: data.price_mem,
          priceStep: data.price_step
        });
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the transaction information for a given transaction hash.
   * @param hash The transaction hash to fetch
   * @returns The transaction information
   */
  async fetchTxInfo(hash) {
    try {
      const { data: txData, status } = await this._axiosInstance.get(
        `txs/${hash}`
      );
      if (status === 200 || status == 202) {
        const { data, status: status2 } = await this._axiosInstance.get(
          `/txs/${txData.hash}/utxos`
        );
        if (status2 !== 200) throw parseHttpError(data);
        return {
          block: txData.block,
          deposit: txData.deposit,
          fees: txData.fees,
          hash: txData.hash,
          index: txData.index,
          invalidAfter: txData.invalid_hereafter ?? "",
          invalidBefore: txData.invalid_before ?? "",
          slot: txData.slot.toString(),
          size: txData.size,
          inputs: data.inputs,
          outputs: data.outputs
        };
      }
      throw parseHttpError(txData);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Get UTxOs for a given hash.
   * @param hash The transaction hash
   * @param index Optional - The output index for filtering post fetching
   * @returns - Array of UTxOs
   */
  async fetchUTxOs(hash, index) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `txs/${hash}/utxos`
      );
      if (status === 200 || status == 202) {
        const bfOutputs = data.outputs;
        const outputsPromises = [];
        bfOutputs.forEach((output) => {
          outputsPromises.push(this.toUTxO(output, hash));
        });
        const outputs = await Promise.all(outputsPromises);
        if (index !== void 0) {
          return outputs.filter((utxo) => utxo.input.outputIndex === index);
        }
        return outputs;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the governance proposal information.
   * @param txHash The transaction hash of the proposal
   * @param certIndex The certificate index of the proposal
   * @returns The governance proposal information
   */
  async fetchGovernanceProposal(txHash, certIndex) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `governance/proposals/${txHash}/${certIndex}`
      );
      if (status === 200 || status == 202)
        return {
          txHash: data.tx_hash,
          certIndex: data.cert_index,
          governanceType: data.governance_type,
          deposit: data.deposit,
          returnAddress: data.return_address,
          governanceDescription: data.governance_description,
          ratifiedEpoch: data.ratified_epoch,
          enactedEpoch: data.enacted_epoch,
          droppedEpoch: data.dropped_epoch,
          expiredEpoch: data.expired_epoch,
          expiration: data.expiration,
          metadata: (await this._axiosInstance.get(
            `governance/proposals/${txHash}/${certIndex}/metadata`
          )).data
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * A generic method to fetch data from a URL.
   * @param url - The URL to fetch data from
   * @returns - The data fetched from the URL
   */
  async get(url) {
    try {
      const { data, status } = await this._axiosInstance.get(url);
      if (status === 200 || status == 202) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * A generic method to post data to a URL.
   * @param url - The URL to fetch data from
   * @param body - Payload
   * @param headers - Specify headers, default: { "Content-Type": "application/json" }
   * @returns - Data
   */
  async post(url, body, headers = { "Content-Type": "application/json" }) {
    try {
      const { data, status } = await this._axiosInstance.post(url, body, {
        headers
      });
      if (status === 200 || status == 202) return data;
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.
   * @param txHash - The transaction hash to listen for confirmation
   * @param callback - The callback function to call when the transaction is confirmed
   * @param limit - The number of blocks to wait for confirmation
   */
  onTxConfirmed(txHash, callback, limit = 100) {
    let attempts = 0;
    const checkTx = setInterval(() => {
      if (attempts >= limit) clearInterval(checkTx);
      this.fetchTxInfo(txHash).then((txInfo) => {
        this.fetchBlockInfo(txInfo.block).then((blockInfo) => {
          if (blockInfo?.confirmations > 0) {
            clearInterval(checkTx);
            callback();
          }
        }).catch(() => {
          attempts += 1;
        });
      }).catch(() => {
        attempts += 1;
      });
    }, 5e3);
  }
  setSubmitTxToBytes(value) {
    this.submitTxToBytes = value;
  }
  /**
   * Submit a serialized transaction to the network.
   * @param tx - The serialized transaction in hex to submit
   * @returns The transaction hash of the submitted transaction
   */
  async submitTx(tx) {
    try {
      const headers = { "Content-Type": "application/cbor" };
      const { data, status } = await this._axiosInstance.post(
        "tx/submit",
        this.submitTxToBytes ? (0, import_common4.toBytes)(tx) : tx,
        { headers }
      );
      if (status === 200 || status == 202) {
        if (this._enableCaching && this._offlineFetcher) {
          try {
            this._offlineFetcher.addSerializedTransaction(tx);
          } catch (error) {
            console.warn("Failed to cache submitted transaction:", error);
          }
        }
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  resolveScriptRef = async (scriptHash) => {
    if (scriptHash) {
      const { data, status } = await this._axiosInstance.get(
        `scripts/${scriptHash}`
      );
      if (status === 200 || status == 202) {
        let script;
        if (data.type.startsWith("plutus")) {
          const plutusScript = await this.fetchPlutusScriptCBOR(scriptHash);
          const normalized = (0, import_core_cst3.normalizePlutusScript)(plutusScript, "DoubleCBOR");
          script = {
            version: data.type.replace("plutus", ""),
            code: normalized
          };
        } else {
          script = await this.fetchNativeScriptJSON(scriptHash);
        }
        return (0, import_core_cst3.toScriptRef)(script).toCbor().toString();
      }
      throw parseHttpError(data);
    }
    return void 0;
  };
  toUTxO = async (bfUTxO, tx_hash) => ({
    input: {
      outputIndex: bfUTxO.output_index,
      txHash: tx_hash
    },
    output: {
      address: bfUTxO.address,
      amount: bfUTxO.amount,
      dataHash: bfUTxO.data_hash ?? void 0,
      plutusData: bfUTxO.inline_datum ?? void 0,
      scriptRef: bfUTxO.reference_script_hash ? await this.resolveScriptRef(bfUTxO.reference_script_hash) : void 0,
      scriptHash: bfUTxO.reference_script_hash
    }
  });
  async fetchPlutusScriptCBOR(scriptHash) {
    const { data, status } = await this._axiosInstance.get(
      `scripts/${scriptHash}/cbor`
    );
    if (status === 200 || status == 202) return data.cbor;
    throw parseHttpError(data);
  }
  async fetchNativeScriptJSON(scriptHash) {
    const { data, status } = await this._axiosInstance.get(
      `scripts/${scriptHash}/json`
    );
    if (status === 200 || status == 202) return data.json;
    throw parseHttpError(data);
  }
  /**
   * Enable or disable caching functionality.
   * @param enable - Whether to enable caching
   * @param offlineFetcher - Optional custom OfflineFetcher instance to use
   */
  setCaching(enable, offlineFetcher) {
    this._enableCaching = enable;
    if (enable) {
      this._offlineFetcher = offlineFetcher || new OfflineFetcher(this._network);
    } else {
      this._offlineFetcher = void 0;
    }
  }
  /**
   * Get the current OfflineFetcher instance if caching is enabled.
   * @returns The OfflineFetcher instance or undefined if caching is disabled
   */
  getOfflineFetcher() {
    return this._offlineFetcher;
  }
  /**
   * Check if caching is currently enabled.
   * @returns True if caching is enabled, false otherwise
   */
  isCachingEnabled() {
    return this._enableCaching;
  }
  /**
   * Export the cached data as JSON string.
   * @returns JSON string of cached data or null if caching is disabled
   */
  exportCache() {
    return this._offlineFetcher ? this._offlineFetcher.toJSON() : null;
  }
  /**
   * Import cached data from JSON string.
   * @param jsonData - JSON string containing cached data
   * @param enableCaching - Whether to enable caching if not already enabled
   */
  importCache(jsonData, enableCaching = true) {
    if (enableCaching && !this._enableCaching) {
      this.setCaching(true);
    }
    if (this._offlineFetcher) {
      const importedFetcher = OfflineFetcher.fromJSON(jsonData);
      this._offlineFetcher = importedFetcher;
    }
  }
  /**
   * Clear all cached data.
   */
  clearCache() {
    if (this._offlineFetcher) {
      this._offlineFetcher = new OfflineFetcher(this._network);
    }
  }
};

// src/koios.ts
var import_axios4 = __toESM(require("axios"), 1);
var import_common5 = require("@meshsdk/common");
var import_core_cst4 = require("@meshsdk/core-cst");
var KoiosProvider = class {
  _axiosInstance;
  _network;
  constructor(...args) {
    if (typeof args[0] === "string" && args[0].startsWith("http")) {
      this._axiosInstance = import_axios4.default.create({
        baseURL: args[0],
        headers: {
          Authorization: `Bearer ${args[1]}`
        }
      });
      this._network = "api";
    } else {
      let version = 1;
      if (typeof args[2] === "number") {
        version = args[2];
      }
      const config = {
        baseURL: `https://${args[0]}.koios.rest/api/v${version}`
      };
      this._network = args[0];
      if (typeof args[1] === "string") {
        config.headers = {
          Authorization: `Bearer ${args[1]}`
        };
      }
      this._axiosInstance = import_axios4.default.create(config);
    }
  }
  /**
   * Obtain information about a specific stake account.
   * @param address - Wallet address to fetch account information
   */
  async fetchAccountInfo(address) {
    try {
      const rewardAddress = address.startsWith("addr") ? (0, import_core_cst4.resolveRewardAddress)(address) : address;
      const { data, status } = await this._axiosInstance.post("account_info", {
        _stake_addresses: [rewardAddress]
      });
      if (status === 200)
        return {
          poolId: data[0].delegated_pool,
          active: data[0].status === "registered",
          balance: data[0].total_balance.toString(),
          rewards: data[0].rewards_available,
          withdrawals: data[0].withdrawals
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the assets for a given address.
   * @param address - The address to fetch assets for
   * @returns A map of asset unit to quantity
   */
  async fetchAddressAssets(address) {
    const utxos = await this.fetchAddressUTxOs(address);
    return utxosToAssets(utxos);
  }
  /**
   * Unimplemented - open for contribution, see blockfrost.ts for reference
   * @param address
   */
  async fetchAddressTxs(address, option = import_common5.DEFAULT_FETCHER_OPTIONS) {
    try {
      const { data, status } = await this._axiosInstance.post(`/address_txs`, {
        _addresses: [address]
      });
      if (status === 200 || status == 202) {
        return data.map((tx) => {
          return {
            hash: tx.tx_hash,
            index: 0,
            block: "",
            slot: "",
            fees: "",
            size: 0,
            deposit: "",
            invalidBefore: "",
            invalidAfter: ""
          };
        });
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * UTXOs of the address.
   * @param address - The address to fetch UTXO
   * @param asset - UTXOs of a given assetâ€‹
   * @returns - Array of UTxOs
   */
  async fetchAddressUTxOs(address, asset) {
    try {
      const { data, status } = await this._axiosInstance.post("address_info", {
        _addresses: [address]
      });
      if (status === 200) {
        const utxos = data.flatMap((info) => info.utxo_set).map((utxo) => this.toUTxO(utxo, address));
        return asset !== void 0 ? utxos.filter(
          (utxo) => utxo.output.amount.find((a) => a.unit === asset) !== void 0
        ) : utxos;
      }
      throw parseHttpError(data);
    } catch (error) {
      return [];
    }
  }
  /**
   * Fetches the asset addresses for a given asset.
   * @param asset - The asset to fetch addresses for
   */
  async fetchAssetAddresses(asset) {
    try {
      const { policyId, assetName } = parseAssetUnit(asset);
      const { data, status } = await this._axiosInstance.get(
        `asset_addresses?_asset_policy=${policyId}&_asset_name=${assetName}`
      );
      if (status === 200)
        return data.map(
          (item) => ({
            address: item.payment_address,
            quantity: item.quantity
          })
        );
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the metadata for a given asset.
   * @param asset - The asset to fetch metadata for
   * @returns The metadata for the asset
   */
  async fetchAssetMetadata(asset) {
    try {
      const { policyId, assetName } = parseAssetUnit(asset);
      const { data, status } = await this._axiosInstance.get(
        `asset_info?_asset_policy=${policyId}&_asset_name=${assetName}`
      );
      if (status === 200)
        return {
          ...data[0].minting_tx_metadata[721][policyId][(0, import_common5.toUTF8)(assetName)],
          fingerprint: data[0].fingerprint,
          totalSupply: data[0].total_supply,
          mintingTxHash: data[0].minting_tx_hash,
          mintCount: data[0].mint_cnt
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the block information for a given block hash.
   * @param hash The block hash to fetch from
   * @returns The block information
   */
  async fetchBlockInfo(hash) {
    try {
      const { data, status } = await this._axiosInstance.post("block_info", {
        _block_hashes: [hash]
      });
      if (status === 200)
        return {
          confirmations: data[0].num_confirmations,
          epoch: data[0].epoch_no,
          epochSlot: data[0].epoch_slot.toString(),
          fees: data[0].total_fees ?? "",
          hash: data[0].hash,
          nextBlock: data[0].child_hash ?? "",
          operationalCertificate: data[0].op_cert,
          output: data[0].total_output ?? "0",
          previousBlock: data[0].parent_hash,
          size: data[0].block_size,
          slot: data[0].abs_slot.toString(),
          slotLeader: data[0].pool ?? "",
          time: data[0].block_time,
          txCount: data[0].tx_count,
          VRFKey: data[0].vrf_key
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the list of assets for a given policy ID.
   * @param policyId The policy ID to fetch assets for
   * @param cursor The cursor for pagination
   * @returns The list of assets and the next cursor
   */
  async fetchCollectionAssets(policyId) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `policy_asset_info?_asset_policy=${policyId}`
      );
      if (status === 200)
        return {
          assets: data.map((asset) => ({
            unit: `${asset.policy_id}${asset.asset_name}`,
            quantity: asset.total_supply
          }))
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchHandle(handle) {
    if (this._network !== "api") {
      throw new Error(
        "Does not support fetching addresses by handle on non-mainnet networks."
      );
    }
    try {
      const assetName = (0, import_common5.fromUTF8)(`${handle.replace("$", "")}`);
      const asset = await this.fetchAssetMetadata(
        `${import_common5.SUPPORTED_HANDLES[1]}000de140${assetName}`
      );
      return asset;
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchHandleAddress(handle) {
    if (this._network !== "api") {
      throw new Error(
        "Does not support fetching addresses by handle on non-mainnet networks."
      );
    }
    try {
      const assetName = (0, import_common5.fromUTF8)(handle.replace("$", ""));
      const { data, status } = await this._axiosInstance.get(
        `asset_addresses?_asset_policy=${import_common5.SUPPORTED_HANDLES[1]}&_asset_name=${assetName}`
      );
      if (status === 200) return data[0].payment_address;
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetch the latest protocol parameters.
   * @param epoch
   * @returns - Protocol parameters
   */
  async fetchProtocolParameters(epoch = Number.NaN) {
    try {
      if (isNaN(epoch)) {
        const { data: data2 } = await this._axiosInstance.get(`tip`);
        epoch = data2[0].epoch_no;
      }
      const { data, status } = await this._axiosInstance.get(
        `epoch_params?_epoch_no=${epoch}`
      );
      if (status === 200)
        return (0, import_common5.castProtocol)({
          coinsPerUtxoSize: data[0].coins_per_utxo_size,
          collateralPercent: data[0].collateral_percent,
          decentralisation: data[0].decentralisation,
          epoch: data[0].epoch_no,
          keyDeposit: data[0].key_deposit,
          maxBlockExMem: data[0].max_block_ex_mem.toString(),
          maxBlockExSteps: data[0].max_block_ex_steps.toString(),
          maxBlockHeaderSize: data[0].max_bh_size,
          maxBlockSize: data[0].max_block_size,
          maxCollateralInputs: data[0].max_collateral_inputs,
          maxTxExMem: data[0].max_tx_ex_mem.toString(),
          maxTxExSteps: data[0].max_tx_ex_steps.toString(),
          maxTxSize: data[0].max_tx_size,
          maxValSize: data[0].max_val_size,
          minFeeA: data[0].min_fee_a,
          minFeeB: data[0].min_fee_b,
          minPoolCost: data[0].min_pool_cost,
          poolDeposit: data[0].pool_deposit,
          priceMem: data[0].price_mem,
          priceStep: data[0].price_step
        });
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the transaction information for a given transaction hash.
   * @param hash The transaction hash to fetch
   * @returns The transaction information
   */
  async fetchTxInfo(hash) {
    try {
      const { data, status } = await this._axiosInstance.post("tx_info", {
        _tx_hashes: [hash]
      });
      if (status === 200 && data.length == 1)
        return {
          block: data[0].block_hash,
          deposit: data[0].deposit,
          fees: data[0].fee,
          hash: data[0].tx_hash,
          index: data[0].tx_block_index,
          invalidAfter: data[0].invalid_after?.toString() ?? "",
          invalidBefore: data[0].invalid_before?.toString() ?? "",
          slot: data[0].absolute_slot.toString(),
          size: data[0].tx_size
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Get UTxOs for a given hash.
   * @param hash The transaction hash
   * @param index Optional - The output index for filtering post fetching
   * @returns - Array of UTxOs
   */
  async fetchUTxOs(hash, index) {
    try {
      const { data, status } = await this._axiosInstance.post("tx_info", {
        _tx_hashes: [hash],
        _assets: true,
        _scripts: true,
        _bytecode: true
      });
      if (status === 200) {
        const utxos = data[0].outputs.map(
          (utxo) => this.toUTxO(utxo, utxo.payment_addr.bech32)
        );
        if (index !== void 0) {
          return utxos.filter((utxo) => utxo.input.outputIndex === index);
        }
        return utxos;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchGovernanceProposal(txHash, certIndex) {
    throw new Error("Method not implemented");
  }
  /**
   * A generic method to fetch data from a URL.
   * @param url - The URL to fetch data from
   * @returns - The data fetched from the URL
   */
  async get(url) {
    try {
      const { data, status } = await this._axiosInstance.get(url);
      if (status === 200 || status == 202) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * A generic method to post data to a URL.
   * @param url - The URL to fetch data from
   * @param body - Payload
   * @param headers - Specify headers, default: { "Content-Type": "application/json" }
   * @returns - Data
   */
  async post(url, body, headers = { "Content-Type": "application/json" }) {
    try {
      const { data, status } = await this._axiosInstance.post(url, body, {
        headers
      });
      if (status === 200 || status == 202) return data;
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.
   * @param txHash - The transaction hash to listen for confirmation
   * @param callback - The callback function to call when the transaction is confirmed
   * @param limit - The number of blocks to wait for confirmation
   */
  onTxConfirmed(txHash, callback, limit = 100) {
    let attempts = 0;
    const checkTx = setInterval(() => {
      if (attempts >= limit) clearInterval(checkTx);
      this.fetchTxInfo(txHash).then((txInfo) => {
        this.fetchBlockInfo(txInfo.block).then((blockInfo) => {
          if (blockInfo?.confirmations > 0) {
            clearInterval(checkTx);
            callback();
          }
        }).catch(() => {
          attempts += 1;
        });
      }).catch(() => {
        attempts += 1;
      });
    }, 5e3);
  }
  /**
   * Deprecated, use fetchAddressTxs instead
   * @param address
   * @returns - partial TransactionInfo
   */
  async fetchAddressTransactions(address) {
    return await this.fetchAddressTxs(address);
  }
  /**
   * Submit a serialized transaction to the network.
   * @param tx - The serialized transaction in hex to submit
   * @returns The transaction hash of the submitted transaction
   */
  async submitTx(tx) {
    try {
      const headers = { "Content-Type": "application/cbor" };
      const { data, status } = await this._axiosInstance.post(
        "submittx",
        (0, import_common5.toBytes)(tx),
        { headers }
      );
      if (status === 202) return data;
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  toUTxO(utxo, address) {
    return {
      input: {
        outputIndex: utxo.tx_index,
        txHash: utxo.tx_hash
      },
      output: {
        address,
        amount: [
          { unit: "lovelace", quantity: utxo.value },
          ...utxo.asset_list.map(
            (a) => ({
              unit: `${a.policy_id}${a.asset_name}`,
              quantity: `${a.quantity}`
            })
          )
        ],
        dataHash: utxo.datum_hash ?? void 0,
        plutusData: utxo.inline_datum?.bytes ?? void 0,
        scriptRef: this.resolveScriptRef(utxo.reference_script),
        scriptHash: utxo.reference_script?.hash ?? void 0
      }
    };
  }
  resolveScriptRef = (kScriptRef) => {
    if (kScriptRef) {
      let script;
      if (kScriptRef.type.startsWith("plutus")) {
        const normalized = (0, import_core_cst4.normalizePlutusScript)(
          kScriptRef.bytes,
          "DoubleCBOR"
        );
        script = {
          code: normalized,
          version: kScriptRef.type.replace("plutus", "")
        };
      } else {
        script = (0, import_core_cst4.fromNativeScript)((0, import_core_cst4.deserializeNativeScript)(kScriptRef.bytes));
      }
      if (script) return (0, import_core_cst4.toScriptRef)(script).toCbor().toString();
    }
    return void 0;
  };
  /**
   * Evaluates the resources required to execute the transaction
   * @param cbor - The transaction CBOR hex string to evaluate
   * @param additionalUtxos - Optional array of additional UTxOs to include in the evaluation context for resolving transaction inputs
   * @param additionalTxs - Optional array of transaction CBOR hex strings to provide additional UTxOs from their outputs
   */
  async evaluateTx(cbor2, additionalUtxos, additionalTxs) {
    const additionalUtxo = getAdditionalUtxos(
      "koios",
      additionalUtxos,
      additionalTxs
    );
    try {
      const headers = {
        "Content-Type": "application/json",
        Accept: "application/json"
      };
      const body = {
        jsonrpc: "2.0",
        method: "evaluateTransaction",
        params: {
          transaction: {
            cbor: cbor2
          },
          additionalUtxo
        }
      };
      const { data, status } = await this._axiosInstance.post("ogmios", body, {
        headers
      });
      if (status === 200 || status === 202) {
        if (!data.result || !data.result.length) {
          return [];
        }
        return data.result.map((val) => {
          if (!val.validator || !val.budget) {
            throw new Error("Invalid response format");
          }
          return {
            index: val.validator.index,
            tag: val.validator.purpose.toUpperCase(),
            budget: {
              mem: val.budget.memory,
              steps: val.budget.cpu
            }
          };
        });
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
};

// src/maestro.ts
var import_axios5 = __toESM(require("axios"), 1);
var import_common6 = require("@meshsdk/common");
var import_core_cst5 = require("@meshsdk/core-cst");
var MaestroProvider = class {
  _axiosInstance;
  _amountsAsStrings = {
    headers: {
      "amounts-as-strings": "true"
    }
  };
  _network;
  submitTxToBytes = true;
  submitUrl;
  constructor({ network, apiKey, turboSubmit = false }) {
    this._axiosInstance = import_axios5.default.create({
      baseURL: `https://${network}.gomaestro-api.org/v1`,
      headers: { "api-key": apiKey }
    });
    this.submitUrl = turboSubmit ? "txmanager/turbosubmit" : "txmanager";
    this._network = network;
  }
  /**
   * Evaluates the resources required to execute the transaction
   * @param cbor - The transaction CBOR hex string to evaluate
   * @param additionalUtxos - Optional array of additional UTxOs to include in the evaluation context for resolving transaction inputs
   * @param additionalTxs - Optional array of transaction CBOR hex strings to provide additional UTxOs from their outputs
   */
  async evaluateTx(cbor2, additionalUtxos, additionalTxs) {
    const additional_utxos = getAdditionalUtxos(
      "maestro",
      additionalUtxos,
      additionalTxs
    );
    try {
      const { data, status } = await this._axiosInstance.post(
        "transactions/evaluate",
        { cbor: cbor2, additional_utxos }
      );
      if (status === 200) {
        const tagMap = {
          spend: "SPEND",
          mint: "MINT",
          cert: "CERT",
          wdrl: "REWARD"
        };
        const result = data.map((action) => {
          const budget = action.ex_units;
          const index = action.redeemer_index;
          const tag = tagMap[action.redeemer_tag];
          return { budget, index, tag };
        });
        return result;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Obtain information about a specific stake account.
   * @param address - Wallet address to fetch account information
   */
  async fetchAccountInfo(address) {
    const rewardAddress = address.startsWith("addr") ? (0, import_core_cst5.resolveRewardAddress)(address) : address;
    try {
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `accounts/${rewardAddress}`,
        this._amountsAsStrings
      );
      if (status === 200) {
        const data = timestampedData.data;
        return {
          poolId: data.delegated_pool,
          active: data.registered,
          balance: data.total_balance,
          rewards: data.rewards_available,
          withdrawals: data.total_withdrawn
        };
      }
      throw parseHttpError(timestampedData);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the assets for a given address.
   * @param address - The address to fetch assets for
   * @returns A map of asset unit to quantity
   */
  async fetchAddressAssets(address) {
    const utxos = await this.fetchAddressUTxOs(address);
    return utxosToAssets(utxos);
  }
  /**
   * UTXOs of the address.
   * @param address - The address to fetch UTXO
   * @param asset - UTXOs of a given assetâ€‹
   * @returns - Array of UTxOs
   */
  async fetchAddressUTxOs(address, asset) {
    const queryPredicate = (() => {
      if (address.startsWith("addr_vkh") || address.startsWith("addr_shared_vkh"))
        return `addresses/cred/${address}`;
      else return `addresses/${address}`;
    })();
    const appendAssetString = asset ? `&asset=${asset}` : "";
    const paginateUTxOs = async (cursor = null, utxos = []) => {
      const appendCursorString = cursor === null ? "" : `&cursor=${cursor}`;
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `${queryPredicate}/utxos?count=100${appendAssetString}${appendCursorString}`,
        this._amountsAsStrings
      );
      if (status === 200) {
        const data = timestampedData.data;
        const pageUTxOs = data.map(this.toUTxO);
        const addedUtxos = [...utxos, ...pageUTxOs];
        const nextCursor = timestampedData.next_cursor;
        return nextCursor == null ? addedUtxos : paginateUTxOs(nextCursor, addedUtxos);
      }
      throw parseHttpError(timestampedData);
    };
    try {
      return await paginateUTxOs();
    } catch (error) {
      return [];
    }
  }
  /**
   * Unimplemented - open for contribution
   *
   * Transactions for an address. The `TransactionInfo` would only return the `hash`, `inputs`, and `outputs`.
   * @param address
   * @returns - partial TransactionInfo
   */
  async fetchAddressTxs(address, option = { maxPage: 100, order: "desc" }) {
    throw new Error("Method not implemented.");
  }
  /**
   * Fetches the asset addresses for a given asset.
   * @param asset - The asset to fetch addresses for
   */
  async fetchAssetAddresses(asset) {
    const { policyId, assetName } = parseAssetUnit(asset);
    const paginateAddresses = async (cursor = null, addressesWithQuantity = []) => {
      const appendCursorString = cursor === null ? "" : `&cursor=${cursor}`;
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `assets/${policyId}${assetName}/addresses?count=100${appendCursorString}`,
        this._amountsAsStrings
      );
      if (status === 200) {
        const data = timestampedData.data;
        const pageAddressesWithQuantity = data.map((a) => {
          return { address: a.address, quantity: a.amount };
        });
        const nextCursor = timestampedData.next_cursor;
        const addedData = [
          ...addressesWithQuantity,
          ...pageAddressesWithQuantity
        ];
        return nextCursor == null ? addedData : paginateAddresses(nextCursor, addedData);
      }
      throw parseHttpError(timestampedData);
    };
    try {
      return await paginateAddresses();
    } catch (error) {
      return [];
    }
  }
  /**
   * Fetches the metadata for a given asset.
   * @param asset - The asset to fetch metadata for
   * @returns The metadata for the asset
   */
  async fetchAssetMetadata(asset) {
    try {
      const { policyId, assetName } = parseAssetUnit(asset);
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `assets/${policyId}${assetName}`
      );
      if (status === 200) {
        const data = timestampedData.data;
        return {
          ...data.asset_standards.cip25_metadata,
          ...data.asset_standards.cip68_metadata,
          fingerprint: data.fingerprint,
          totalSupply: data.total_supply,
          mintingTxHash: data.latest_mint_tx.tx_hash,
          mintCount: data.mint_tx_count
        };
      }
      throw parseHttpError(timestampedData);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the block information for a given block hash.
   * @param hash The block hash to fetch from
   * @returns The block information
   */
  async fetchBlockInfo(hash) {
    try {
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `blocks/${hash}`,
        this._amountsAsStrings
      );
      if (status === 200) {
        const data = timestampedData.data;
        return {
          confirmations: data.confirmations,
          epoch: data.epoch,
          epochSlot: data.epoch_slot.toString(),
          fees: data.total_fees,
          hash: data.hash,
          nextBlock: data.next_block ?? "",
          operationalCertificate: data.operational_certificate?.hot_vkey,
          output: data.total_output_lovelace ?? "0",
          previousBlock: data.previous_block,
          size: data.size,
          slot: data.absolute_slot.toString(),
          slotLeader: data.block_producer ?? "",
          time: Date.parse(data.timestamp) / 1e3,
          txCount: data.tx_hashes.length,
          VRFKey: import_core_cst5.VrfVkBech32.fromHex(data.vrf_key)
        };
      }
      throw parseHttpError(timestampedData);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the list of assets for a given policy ID.
   * @param policyId The policy ID to fetch assets for
   * @param cursor The cursor for pagination
   * @returns The list of assets and the next cursor
   */
  async fetchCollectionAssets(policyId, cursor) {
    try {
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `policy/${policyId}/assets?count=100${cursor ? `&cursor=${cursor}` : ""}`
      );
      if (status === 200) {
        const data = timestampedData.data;
        return {
          assets: data.map((asset) => ({
            unit: policyId + asset.asset_name,
            quantity: asset.total_supply
          })),
          next: timestampedData.next_cursor
        };
      }
      throw parseHttpError(timestampedData);
    } catch (error) {
      return { assets: [], next: null };
    }
  }
  async fetchHandle(handle) {
    if (this._network !== "Mainnet") {
      throw new Error(
        "Does not support fetching addresses by handle on non-mainnet networks."
      );
    }
    try {
      const assetName = (0, import_common6.fromUTF8)(`${handle.replace("$", "")}`);
      const asset = await this.fetchAssetMetadata(
        `${import_common6.SUPPORTED_HANDLES[1]}000643b0${assetName}`
      );
      if (asset.metadata !== void 0) return asset.metadata;
      throw "Problem fetching metadata";
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchHandleAddress(handle) {
    if (this._network !== "Mainnet") {
      throw new Error(
        "Does not support fetching addresses by handle on non-mainnet networks."
      );
    }
    try {
      const handleWithoutDollar = handle.charAt(0) === "$" ? handle.substring(1) : handle;
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `ecosystem/adahandle/${handleWithoutDollar}`
      );
      if (status === 200) return timestampedData.data;
      throw parseHttpError(timestampedData);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetch the latest protocol parameters.
   * @param epoch
   * @returns - Protocol parameters
   */
  async fetchProtocolParameters(epoch = Number.NaN) {
    if (!isNaN(epoch))
      throw new Error(
        "Maestro only supports fetching Protocol parameters of the latest completed epoch."
      );
    const decimalFromRationalString = (str) => {
      const forwardSlashIndex = str.indexOf("/");
      return parseInt(str.slice(0, forwardSlashIndex)) / parseInt(str.slice(forwardSlashIndex + 1));
    };
    try {
      const { data: timestampedData, status } = await this._axiosInstance.get("protocol-params");
      if (status === 200) {
        const data = timestampedData.data;
        try {
          const { data: timestampedDataEpochData, status: epochStatus } = await this._axiosInstance.get("epochs/current");
          if (epochStatus === 200) {
            const epochData = timestampedDataEpochData.data;
            return (0, import_common6.castProtocol)({
              coinsPerUtxoSize: parseInt(data.coins_per_utxo_byte),
              collateralPercent: parseInt(data.collateral_percentage),
              decentralisation: 0,
              // Deprecated in Babbage era.
              epoch: parseInt(epochData.epoch_no),
              keyDeposit: parseInt(data.stake_key_deposit),
              maxBlockExMem: data.max_execution_units_per_block.memory.toString(),
              maxBlockExSteps: data.max_execution_units_per_block.steps.toString(),
              maxBlockHeaderSize: parseInt(data.max_block_header_size),
              maxBlockSize: parseInt(data.max_block_body_size),
              maxCollateralInputs: parseInt(data.max_collateral_inputs),
              maxTxExMem: data.max_execution_units_per_transaction.memory.toString(),
              maxTxExSteps: data.max_execution_units_per_transaction.steps.toString(),
              maxTxSize: parseInt(data.max_tx_size),
              maxValSize: parseInt(data.max_value_sized),
              minFeeA: data.min_fee_coefficient,
              minFeeB: data.min_fee_constant,
              minPoolCost: data.min_pool_cost.toString(),
              poolDeposit: parseInt(data.pool_deposit),
              priceMem: decimalFromRationalString(data.prices.memory),
              priceStep: decimalFromRationalString(data.prices.steps)
            });
          }
          throw parseHttpError(timestampedDataEpochData);
        } catch (error) {
          throw parseHttpError(error);
        }
      }
      throw parseHttpError(timestampedData);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the transaction information for a given transaction hash.
   * @param hash The transaction hash to fetch
   * @returns The transaction information
   */
  async fetchTxInfo(hash) {
    try {
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `transactions/${hash}`
      );
      if (status === 200) {
        const data = timestampedData.data;
        return {
          block: data.block_hash,
          deposit: data.deposit.toString(),
          fees: data.fee.toString(),
          hash: data.tx_hash,
          index: data.block_tx_index,
          invalidAfter: data.invalid_hereafter ?? "",
          invalidBefore: data.invalid_before ?? "",
          slot: data.block_absolute_slot.toString(),
          size: data.size - 1
        };
      }
      throw parseHttpError(timestampedData);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Get UTxOs for a given hash.
   * @param hash The transaction hash
   * @param index Optional - The output index for filtering post fetching
   * @returns - Array of UTxOs
   */
  async fetchUTxOs(hash, index) {
    try {
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `transactions/${hash}`,
        this._amountsAsStrings
      );
      if (status === 200) {
        const msOutputs = timestampedData.data.outputs;
        const outputs = msOutputs.map(this.toUTxO);
        if (index !== void 0) {
          return outputs.filter((utxo) => utxo.input.outputIndex === index);
        }
        return outputs;
      }
      throw parseHttpError(timestampedData);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Unimplemented - open for contribution
   *
   * Fetches the governance proposal information.
   * @param txHash The transaction hash of the proposal
   * @param certIndex The certificate index of the proposal
   * @returns The governance proposal information
   */
  async fetchGovernanceProposal(txHash, certIndex) {
    throw new Error("Method not implemented by Maestro");
  }
  async get(url) {
    try {
      const { data, status } = await this._axiosInstance.get(url);
      if (status === 200) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async post(url, body) {
    try {
      const { data, status } = await this._axiosInstance.post(url, body, {
        headers: {
          "Content-Type": "application/json"
        }
      });
      if (status === 200) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.
   * @param txHash - The transaction hash to listen for confirmation
   * @param callback - The callback function to call when the transaction is confirmed
   * @param limit - The number of blocks to wait for confirmation
   */
  onTxConfirmed(txHash, callback, limit = 100) {
    let attempts = 0;
    const checkTx = setInterval(() => {
      if (attempts >= limit) clearInterval(checkTx);
      this.fetchTxInfo(txHash).then((txInfo) => {
        this.fetchBlockInfo(txInfo.block).then((blockInfo) => {
          if (blockInfo?.confirmations > 0) {
            clearInterval(checkTx);
            callback();
          }
        }).catch(() => {
          attempts += 1;
        });
      }).catch(() => {
        attempts += 1;
      });
    }, 5e3);
  }
  setSubmitTxToBytes(value) {
    this.submitTxToBytes = value;
  }
  /**
   * Submit a serialized transaction to the network.
   * @param tx - The serialized transaction in hex to submit
   * @returns The transaction hash of the submitted transaction
   */
  async submitTx(tx) {
    try {
      const headers = { "Content-Type": "application/cbor" };
      const { data, status } = await this._axiosInstance.post(
        this.submitUrl,
        this.submitTxToBytes ? (0, import_common6.toBytes)(tx) : tx,
        { headers }
      );
      if (status === 202) return data;
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  toUTxO = (utxo) => ({
    input: {
      outputIndex: utxo.index,
      txHash: utxo.tx_hash
    },
    output: {
      address: utxo.address,
      amount: utxo.assets.map((asset) => ({
        unit: asset.unit,
        quantity: asset.amount
      })),
      dataHash: utxo.datum?.hash,
      plutusData: utxo.datum?.bytes,
      scriptRef: this.resolveScript(utxo),
      scriptHash: utxo.reference_script?.hash
    }
  });
  resolveScript = (utxo) => {
    if (utxo.reference_script) {
      let script;
      if (utxo.reference_script.type === "native") {
        script = utxo.reference_script.json;
      } else {
        const scriptBytes = utxo.reference_script.bytes;
        if (scriptBytes) {
          const normalized = (0, import_core_cst5.normalizePlutusScript)(scriptBytes, "DoubleCBOR");
          script = {
            code: normalized,
            version: utxo.reference_script.type.replace("plutusv", "V")
          };
        } else {
          throw new Error("Script bytes not found");
        }
      }
      return (0, import_core_cst5.toScriptRef)(script).toCbor().toString();
    } else return void 0;
  };
};

// src/ogmios.ts
var import_common7 = require("@meshsdk/common");
var OgmiosProvider = class {
  _baseUrl;
  constructor(...args) {
    this._baseUrl = (0, import_common7.isNetwork)(args[0]) ? import_common7.SUPPORTED_OGMIOS_LINKS[args[0]] : args[0];
  }
  /**
   * Evaluates the resources required to execute the transaction
   * @param cbor - The transaction CBOR hex string to evaluate
   * @param additionalUtxos - Optional array of additional UTxOs to include in the evaluation context for resolving transaction inputs
   * @param additionalTxs - Optional array of transaction CBOR hex strings to provide additional UTxOs from their outputs
   */
  async evaluateTx(cbor2, additionalUtxos, additionalTxs) {
    const additionalUtxo = getAdditionalUtxos(
      "ogmios",
      additionalUtxos,
      additionalTxs
    );
    const client = await this.open();
    this.send(client, "evaluateTransaction", {
      transaction: {
        cbor: cbor2
      },
      additionalUtxo
    });
    return new Promise((resolve, reject) => {
      client.addEventListener(
        "message",
        (response) => {
          try {
            const { result } = JSON.parse(response.data);
            if (result) {
              resolve(
                Object.values(result).map((val) => {
                  return {
                    index: val.validator.index,
                    tag: val.validator.purpose.toUpperCase(),
                    budget: {
                      mem: val.budget.memory,
                      steps: val.budget.cpu
                    }
                  };
                })
              );
            } else {
              reject(result);
            }
            client.close();
          } catch (error) {
            reject(error);
          }
        },
        { once: true }
      );
    });
  }
  async onNextTx(callback) {
    const client = await this.open();
    this.send(client, "acquireMempool", {});
    client.addEventListener("message", (response) => {
      const { result } = JSON.parse(response.data);
      if (result === null) {
        return this.send(client, "acquireMempool", {});
      }
      if (result.transaction === null || result.transaction === void 0) {
        this.send(client, "acquireMempool", {});
      } else {
        callback(result);
      }
      this.send(client, "nextTransaction", {
        fields: "all"
      });
    });
    return () => client.close();
  }
  /**
   * Submit a serialized transaction to the network.
   * @param tx - The serialized transaction in hex to submit
   * @returns The transaction hash of the submitted transaction
   */
  async submitTx(tx) {
    const client = await this.open();
    this.send(client, "submitTransaction", {
      transaction: {
        cbor: tx
      }
    });
    return new Promise((resolve, reject) => {
      client.addEventListener(
        "message",
        (response) => {
          try {
            const { result } = JSON.parse(response.data);
            if (!result) {
              reject(JSON.parse(response.data).error);
            }
            if (result.transaction !== null && result.transaction !== void 0) {
              resolve(result.transaction.id);
            } else {
              reject(result);
            }
            client.close();
          } catch (error) {
            reject(error);
          }
        },
        { once: true }
      );
    });
  }
  async fetchProtocolParameters() {
    const client = await this.open();
    this.send(client, "queryLedgerState/protocolParameters", {});
    return new Promise((resolve, reject) => {
      client.addEventListener(
        "message",
        (response) => {
          try {
            const { result } = JSON.parse(response.data);
            if (!result) {
              reject(JSON.parse(response.data).error);
            }
            resolve(result);
            client.close();
          } catch (error) {
            reject(error);
          }
        },
        { once: true }
      );
    });
  }
  async open() {
    const client = new WebSocket(this._baseUrl);
    await new Promise((resolve) => {
      client.addEventListener("open", () => resolve(true), { once: true });
    });
    return client;
  }
  send(client, method, params) {
    client.send(
      JSON.stringify({
        jsonrpc: "2.0",
        type: "jsonwsp/request",
        servicename: "ogmios",
        method,
        params
      })
    );
  }
};

// src/utxo-rpc.ts
var import_sdk = require("@utxorpc/sdk");
var import_spec = require("@utxorpc/spec");
var import_cbor = __toESM(require("cbor"), 1);
var import_common8 = require("@meshsdk/common");
var import_core_cst6 = require("@meshsdk/core-cst");
var U5CProvider = class {
  // Clients for querying and submitting transactions on the Cardano blockchain.
  queryClient;
  submitClient;
  /**
   * Constructor initializes the query and submit clients with provided URL and optional headers.
   * @param url - The base URL for interacting with Cardano nodes.
   * @param headers - Optional HTTP headers for API requests.
   */
  constructor({
    url,
    headers
  }) {
    this.queryClient = new import_sdk.CardanoQueryClient({
      uri: url,
      headers
    });
    this.submitClient = new import_sdk.CardanoSubmitClient({
      uri: url,
      headers
    });
  }
  /**
   * Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.
   * @param txHash - The transaction hash to listen for confirmation
   * @param callback - The callback function to call when the transaction is confirmed
   * @param limit - The number of blocks to wait for confirmation
   */
  onTxConfirmed(txHash, callback, limit = 100) {
    const onConfirmed = async () => {
      const updates = this.submitClient.waitForTx((0, import_common8.hexToBytes)(txHash));
      for await (const stage of updates) {
        console.log(JSON.stringify(updates));
        if (stage === import_spec.submit.Stage.CONFIRMED) {
          callback();
          return;
        }
      }
    };
    const timeoutId = setTimeout(() => {
      console.log("Transaction confirmation timed out.");
    }, limit * 5e3);
    onConfirmed().finally(() => clearTimeout(timeoutId));
  }
  /**
   * Evaluates the resources required to execute the transaction
   * @param tx - The transaction to evaluate
   */
  async evaluateTx(tx, additionalUtxos, additionalTxs) {
    const report = await this.submitClient.evalTx((0, import_common8.hexToBytes)(tx));
    const evalResult = report.report[0].chain.value?.redeemers;
    const tagMap = {
      // 0: "UNSPECIFIED",   // REDEEMER_PURPOSE_UNSPECIFIED
      1: "SPEND",
      // REDEEMER_PURPOSE_SPEND
      2: "MINT",
      // REDEEMER_PURPOSE_MINT
      3: "CERT",
      // REDEEMER_PURPOSE_CERT
      4: "REWARD",
      // REDEEMER_PURPOSE_REWARD
      5: "VOTE",
      // REDEEMER_PURPOSE_VOTE
      6: "PROPOSE"
      // REDEEMER_PURPOSE_PROPOSE
    };
    const result = [];
    evalResult.map((action) => {
      result.push({
        tag: tagMap[action.purpose],
        index: action.index,
        budget: {
          mem: Number(action.exUnits.memory),
          steps: Number(action.exUnits.steps)
        }
      });
    });
    return result;
  }
  /**
   * Submit a serialized transaction to the network.
   * @param tx - The serialized transaction in hex to submit
   * @returns The transaction hash of the submitted transaction
   */
  async submitTx(tx) {
    const cbor2 = (0, import_common8.toBytes)(tx);
    const hash = await this.submitClient.submitTx(cbor2);
    return (0, import_common8.bytesToHex)(hash);
  }
  /**
   * Obtain information about a specific stake account.
   * @param address - Wallet address to fetch account information
   */
  fetchAccountInfo(address) {
    throw new Error("Method not implemented.");
  }
  async fetchAddressAssets(address) {
    const utxos = await this.fetchAddressUTxOs(address);
    return utxosToAssets(utxos);
  }
  /**
   * Fetches the UTxOs for a given address.
   * @param address - The address to fetch UTxOs for
   * @param asset - The asset to filter UTxOs by (optional)
   * @returns UTxOs for the given address
   */
  async fetchAddressUTxOs(address, asset) {
    const addressBytes = (0, import_common8.hexToBytes)(import_core_cst6.Address.fromBech32(address).toBytes());
    const utxoSearchResult = await this.queryClient.searchUtxosByAddress(addressBytes);
    return utxoSearchResult.map((item) => {
      const utxo = this._rpcUtxoToMeshUtxo(item.txoRef, item.parsedValued);
      if (asset) {
        if (utxo.output.amount.some((amountItem) => amountItem.unit === asset)) {
          return utxo;
        }
        return void 0;
      }
      return utxo;
    }).filter((utxo) => utxo !== void 0);
  }
  /**
   * Unimplemented - open for contribution
   *
   * Transactions for an address. The `TransactionInfo` would only return the `hash`, `inputs`, and `outputs`.
   * @param address - The address to fetch transactions for
   * @returns - partial TransactionInfo
   */
  async fetchAddressTxs(address, option = { maxPage: 100, order: "desc" }) {
    throw new Error("Method not implemented.");
  }
  /**
   * Unimplemented - open for contribution
   *
   * Fetches the asset addresses for a given asset.
   * @param asset - The asset to fetch addresses for
   */
  fetchAssetAddresses(asset) {
    throw new Error("Method not implemented.");
  }
  /**
   * Unimplemented - open for contribution
   *
   * Fetches the metadata for a given asset.
   * @param asset - The asset to fetch metadata for
   */
  fetchAssetMetadata(asset) {
    throw new Error("Method not implemented.");
  }
  /**
   * Unimplemented - open for contribution
   *
   * Fetches the block information for a given block hash.
   * @param hash - The block hash to fetch block information for
   */
  fetchBlockInfo(hash) {
    throw new Error("Method not implemented.");
  }
  /**
   * Unimplemented - open for contribution
   *
   * Fetches the collection assets for a given policy ID.
   * @param policyId - The policy ID to fetch collection assets for
   * @param cursor - The cursor to fetch the next set of assets (optional)
   */
  fetchCollectionAssets(policyId, cursor) {
    throw new Error("Method not implemented.");
  }
  /**
   * Unimplemented - open for contribution
   *
   * Fetches the information (AssetMetadata) for a given handle.
   * @param handle - The handle to fetch information for
   */
  fetchHandle(handle) {
    throw new Error("Method not implemented.");
  }
  /**
   * Unimplemented - open for contribution
   *
   * Resolve the handle's address from the handle.
   * @param handle - The handle to resolve
   */
  fetchHandleAddress(handle) {
    throw new Error("Method not implemented.");
  }
  /**
   * Unimplemented - open for contribution
   *
   * Fetches protocol parameters
   */
  async fetchProtocolParameters(epoch = Number.NaN) {
    const rpcPParams = await this.queryClient.readParams();
    if (rpcPParams === void 0 || rpcPParams === null) {
      throw new Error(`Error fetching protocol parameters`);
    }
    return this._rpcPParamsToProtocol(rpcPParams);
  }
  /**
   * Unimplemented - open for contribution
   *
   * Fetches transaction info for a given hash.
   * @param hash - The transaction hash
   */
  fetchTxInfo(hash) {
    throw new Error("Method not implemented.");
  }
  /**
   * Not complete - open for contribution
   *
   * Fetches output UTxOs of a given transaction hash.
   * @param hash - The transaction hash
   */
  async fetchUTxOs(hash, index) {
    const txHash = (0, import_common8.hexToBytes)(hash);
    if (index !== void 0) {
      const [utxo] = await this.queryClient.readUtxosByOutputRef([
        { txHash, outputIndex: index }
      ]);
      return utxo ? [this._rpcUtxoToMeshUtxo(utxo.txoRef, utxo.parsedValued)] : [];
    }
    const batchSize = 100;
    let outputIndex = 0;
    const allUtxos = [];
    while (true) {
      const batch = Array.from({ length: batchSize }, (_, i) => ({
        txHash,
        outputIndex: outputIndex + i
      }));
      const utxos = await this.queryClient.readUtxosByOutputRef(batch);
      const meshUtxos = utxos.map(
        (u) => this._rpcUtxoToMeshUtxo(u.txoRef, u.parsedValued)
      );
      allUtxos.push(...meshUtxos);
      if (utxos.length < batchSize) break;
      outputIndex += batchSize;
    }
    return allUtxos;
  }
  /**
   * Unimplemented - open for contribution
   *
   * Fetches the governance proposal information.
   * @param txHash The transaction hash of the proposal
   * @param certIndex The certificate index of the proposal
   * @returns The governance proposal information
   */
  async fetchGovernanceProposal(txHash, certIndex) {
    throw new Error("Method not implemented");
  }
  /**
   * Unimplemented - open for contribution
   *
   * @param url
   */
  get(url) {
    throw new Error("Method not implemented.");
  }
  /**
   * Waits for transaction confirmation within a given timeout.
   * @param txId - The transaction hash.
   * @param timeout - Optional timeout in milliseconds.
   * @returns True if the transaction is confirmed within the timeout, otherwise false.
   */
  awaitTransactionConfirmation(txId, timeout) {
    const onConfirmed = (async () => {
      const updates = this.submitClient.waitForTx((0, import_common8.hexToBytes)(txId));
      for await (const stage of updates) {
        if (stage == import_spec.submit.Stage.CONFIRMED) {
          return true;
        }
      }
      return false;
    })();
    const onTimeout = new Promise(
      (resolve) => setTimeout(() => resolve(false), timeout)
    );
    return Promise.race([onConfirmed, onTimeout]);
  }
  /**
   * Helper function to convert an RPC UTxO object to a Mesh UTxO object.
   * @param rpcTxoRef - The transaction output reference from RPC.
   * @param rpcTxOutput - The transaction output details from RPC.
   * @returns A formatted UTxO object.
   */
  _rpcUtxoToMeshUtxo(rpcTxoRef, rpcTxOutput) {
    const amount = [
      {
        unit: "lovelace",
        quantity: rpcTxOutput.coin.toString()
      }
    ];
    rpcTxOutput.assets.forEach((ma) => {
      ma.assets.forEach((asset) => {
        amount.push({
          unit: Buffer.from(ma.policyId).toString("hex") + Buffer.from(asset.name).toString("hex"),
          quantity: asset.outputCoin.toString()
        });
      });
    });
    let dataHash = void 0;
    let plutusData = void 0;
    if (rpcTxOutput.datum !== void 0) {
      if (rpcTxOutput.datum?.originalCbor && rpcTxOutput.datum.originalCbor.length > 0) {
        dataHash = Buffer.from(rpcTxOutput.datum.hash).toString("hex");
        plutusData = Buffer.from(rpcTxOutput.datum.originalCbor).toString(
          "hex"
        );
      } else if (rpcTxOutput.datum?.hash && rpcTxOutput.datum.hash.length > 0) {
        dataHash = Buffer.from(rpcTxOutput.datum.hash).toString("hex");
      }
    }
    let scriptRef = void 0;
    let scriptHash = void 0;
    if (rpcTxOutput.script !== void 0) {
      if (rpcTxOutput.script.script.case !== "native" && rpcTxOutput.script.script.value) {
        scriptRef = (0, import_common8.bytesToHex)(rpcTxOutput.script.script.value);
        scriptRef = import_cbor.default.encode(Buffer.from(scriptRef, "hex")).toString("hex");
        let V;
        if (rpcTxOutput.script.script.case === "plutusV1") {
          V = "V1";
        } else if (rpcTxOutput.script.script.case === "plutusV2") {
          V = "V2";
        } else {
          V = "V3";
        }
        scriptHash = (0, import_core_cst6.deserializePlutusScript)(scriptRef, V).hash();
      }
    }
    return {
      input: {
        outputIndex: rpcTxoRef.index,
        txHash: Buffer.from(rpcTxoRef.hash).toString("hex")
      },
      output: {
        address: import_core_cst6.Address.fromBytes(
          import_core_cst6.CardanoSDKUtil.HexBlob.fromBytes(rpcTxOutput.address)
        ).toBech32(),
        amount,
        dataHash,
        plutusData,
        scriptRef,
        scriptHash
      }
    };
  }
  /**
   * Converts RPC protocol parameters to a Mesh Protocol object.
   * @param rpcPParams - The protocol parameters from the RPC.
   * @returns A Protocol object.
   */
  _rpcPParamsToProtocol(rpcPParams) {
    return (0, import_common8.castProtocol)({
      coinsPerUtxoSize: Number(rpcPParams.coinsPerUtxoByte),
      collateralPercent: Number(rpcPParams.collateralPercentage),
      decentralisation: 0,
      // Deprecated in Babbage era.
      keyDeposit: Number(rpcPParams.stakeKeyDeposit),
      maxBlockExMem: Number(rpcPParams.maxExecutionUnitsPerBlock?.memory),
      maxBlockExSteps: Number(rpcPParams.maxExecutionUnitsPerBlock?.steps),
      maxBlockHeaderSize: Number(rpcPParams.maxBlockHeaderSize),
      maxBlockSize: Number(rpcPParams.maxBlockBodySize),
      maxCollateralInputs: Number(rpcPParams.maxCollateralInputs),
      maxTxExMem: Number(rpcPParams.maxExecutionUnitsPerTransaction?.memory),
      maxTxExSteps: Number(rpcPParams.maxExecutionUnitsPerTransaction?.steps),
      maxTxSize: Number(rpcPParams.maxTxSize),
      maxValSize: Number(rpcPParams.maxValueSize),
      minFeeA: Number(rpcPParams.minFeeCoefficient),
      minFeeB: Number(rpcPParams.minFeeConstant),
      minPoolCost: Number(rpcPParams.minPoolCost),
      poolDeposit: Number(rpcPParams.poolDeposit),
      priceMem: Number(rpcPParams.prices?.memory),
      priceStep: Number(rpcPParams.prices?.steps)
    });
  }
};

// src/yaci.ts
var import_axios6 = __toESM(require("axios"), 1);
var import_common9 = require("@meshsdk/common");
var import_core_cst7 = require("@meshsdk/core-cst");
var YaciProvider = class {
  _axiosInstance;
  _adminAxiosInstance;
  /**
   * Set the URL of the instance.
   * @param baseUrl The base URL of the instance.
   */
  constructor(baseUrl = "https://yaci-node.meshjs.dev/api/v1/", adminUrl) {
    this._axiosInstance = import_axios6.default.create({
      baseURL: baseUrl
    });
    if (adminUrl) {
      this._adminAxiosInstance = import_axios6.default.create({
        baseURL: adminUrl
      });
    }
  }
  /**
   * Obtain information about a specific stake account.
   * @param address - Wallet address to fetch account information
   */
  async fetchAccountInfo(address) {
    const rewardAddress = address.startsWith("addr") ? (0, import_core_cst7.resolveRewardAddress)(address) : address;
    try {
      const { data, status } = await this._axiosInstance.get(
        `accounts/${rewardAddress}`
      );
      if (status === 200)
        return {
          poolId: data.pool_id,
          active: data.active || data.active_epoch !== null,
          balance: data.controlled_amount,
          rewards: data.withdrawable_amount,
          withdrawals: data.withdrawals_sum
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  resolveScriptRef = async (scriptHash) => {
    if (scriptHash) {
      const { data, status } = await this._axiosInstance.get(
        `scripts/${scriptHash}`
      );
      if (status === 200) {
        let script;
        if (data.type.startsWith("plutus")) {
          const plutusScript = await this.fetchPlutusScriptCBOR(scriptHash);
          const normalized = (0, import_core_cst7.normalizePlutusScript)(plutusScript, "DoubleCBOR");
          script = {
            version: data.type.replace("plutus", ""),
            code: normalized
          };
        } else {
          script = await this.fetchNativeScriptJSON(scriptHash);
        }
        return (0, import_core_cst7.toScriptRef)(script).toCbor();
      }
      throw parseHttpError(data);
    }
    return void 0;
  };
  toUTxO = async (bfUTxO, tx_hash) => ({
    input: {
      outputIndex: bfUTxO.output_index,
      txHash: tx_hash
    },
    output: {
      address: bfUTxO.address,
      amount: bfUTxO.amount.map((utxo) => {
        return { ...utxo, quantity: utxo.quantity.toString() };
      }),
      dataHash: bfUTxO.data_hash ?? void 0,
      plutusData: bfUTxO.inline_datum ?? void 0,
      scriptRef: bfUTxO.script_ref ? bfUTxO.script_ref : bfUTxO.reference_script_hash ? await this.resolveScriptRef(bfUTxO.reference_script_hash) : void 0,
      scriptHash: bfUTxO.reference_script_hash
    }
  });
  /**
   * Fetches the assets for a given address.
   * @param address - The address to fetch assets for
   * @returns A map of asset unit to quantity
   */
  async fetchAddressAssets(address) {
    const utxos = await this.fetchAddressUTxOs(address);
    return utxosToAssets(utxos);
  }
  /**
   * UTXOs of the address.
   * @param address - The address to fetch UTXO
   * @param asset - UTXOs of a given assetâ€‹
   * @returns - Array of UTxOs
   */
  async fetchAddressUTxOs(address, asset) {
    const filter = asset !== void 0 ? `/${asset}` : "";
    const url = `addresses/${address}/utxos` + filter;
    const paginateUTxOs = async (page = 1, utxos = []) => {
      const { data, status } = await this._axiosInstance.get(
        `${url}?page=${page}`
      );
      if (status === 200)
        return data.length > 0 ? paginateUTxOs(page + 1, [
          ...utxos,
          ...await Promise.all(
            data.map((utxo) => this.toUTxO(utxo, utxo.tx_hash))
          )
        ]) : utxos;
      throw parseHttpError(data);
    };
    try {
      return await paginateUTxOs();
    } catch (error) {
      return [];
    }
  }
  /**
   * Unimplemented - open for contribution
   *
   * Transactions for an address. The `TransactionInfo` would only return the `hash`, `inputs`, and `outputs`.
   * @param address - The address to fetch transactions for
   * @returns - partial TransactionInfo
   */
  async fetchAddressTxs(address, option = { maxPage: 100, order: "desc" }) {
    throw new Error("Method not implemented.");
  }
  /**
   * Fetches the asset addresses for a given asset.
   * @param asset - The asset to fetch addresses for
   */
  async fetchAssetAddresses(asset) {
    const paginateAddresses = async (page = 1, addresses = []) => {
      const { policyId, assetName } = parseAssetUnit(asset);
      const { data, status } = await this._axiosInstance.get(
        `assets/${policyId}${assetName}/addresses?page=${page}`
      );
      if (status === 200)
        return data.length > 0 ? paginateAddresses(page + 1, [...addresses, ...data]) : addresses;
      throw parseHttpError(data);
    };
    try {
      return await paginateAddresses();
    } catch (error) {
      return [];
    }
  }
  /**
   * Fetches the metadata for a given asset.
   * @param asset - The asset to fetch metadata for
   * @returns The metadata for the asset
   */
  async fetchAssetMetadata(asset) {
    try {
      const { policyId, assetName } = parseAssetUnit(asset);
      const { data, status } = await this._axiosInstance.get(
        `assets/${policyId}${assetName}`
      );
      if (status === 200)
        return {
          ...data.onchain_metadata
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the block information for a given block hash.
   * @param hash The block hash to fetch from
   * @returns The block information
   */
  async fetchBlockInfo(hash) {
    try {
      const { data, status } = await this._axiosInstance.get(`blocks/${hash}`);
      if (status === 200)
        return {
          confirmations: data.confirmations,
          epoch: data.epoch,
          epochSlot: data.epoch_slot.toString(),
          fees: data.fees,
          hash: data.hash,
          nextBlock: data.next_block ?? "",
          operationalCertificate: data.op_cert,
          output: data.output ?? "0",
          previousBlock: data.previous_block,
          size: data.size,
          slot: data.slot.toString(),
          slotLeader: data.slot_leader ?? "",
          time: data.time,
          txCount: data.tx_count,
          VRFKey: data.block_vrf
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the list of assets for a given policy ID.
   * @param policyId The policy ID to fetch assets for
   * @param cursor The cursor for pagination
   * @returns The list of assets and the next cursor
   */
  async fetchCollectionAssets(policyId, cursor = 1) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `assets/policy/${policyId}?page=${cursor}`
      );
      if (status === 200)
        return {
          assets: data.map((asset) => ({
            unit: asset.asset,
            quantity: asset.quantity
          })),
          next: data.length === 100 ? cursor + 1 : null
        };
      throw parseHttpError(data);
    } catch (error) {
      return { assets: [], next: null };
    }
  }
  async fetchHandle(handle) {
    throw new Error("Method not implemented.");
  }
  async fetchHandleAddress(handle) {
    try {
      const assetName = (0, import_common9.fromUTF8)(handle.replace("$", ""));
      const { data, status } = await this._axiosInstance.get(
        `assets/${import_common9.SUPPORTED_HANDLES[1]}${assetName}/addresses`
      );
      if (status === 200) return data[0].address;
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetch the latest protocol parameters.
   * @param epoch Optional - The epoch to fetch protocol parameters for
   * @returns - Protocol parameters
   */
  async fetchProtocolParameters(epoch = Number.NaN) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `epochs/${isNaN(epoch) ? "latest" : epoch}/parameters`
      );
      if (status === 200)
        return (0, import_common9.castProtocol)({
          coinsPerUtxoSize: data.coins_per_utxo_size,
          collateralPercent: data.collateral_percent,
          decentralisation: data.decentralisation_param,
          epoch: data.epoch,
          keyDeposit: data.key_deposit,
          maxBlockExMem: data.max_block_ex_mem,
          maxBlockExSteps: data.max_block_ex_steps,
          maxBlockHeaderSize: data.max_block_header_size,
          maxBlockSize: data.max_block_size,
          maxCollateralInputs: data.max_collateral_inputs,
          maxTxExMem: data.max_tx_ex_mem,
          maxTxExSteps: data.max_tx_ex_steps,
          maxTxSize: data.max_tx_size,
          maxValSize: data.max_val_size,
          minFeeA: data.min_fee_a,
          minFeeB: data.min_fee_b,
          minPoolCost: data.min_pool_cost,
          poolDeposit: data.pool_deposit,
          priceMem: data.price_mem,
          priceStep: data.price_step
        });
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the transaction information for a given transaction hash.
   * @param hash The transaction hash to fetch
   * @returns The transaction information
   */
  async fetchTxInfo(hash) {
    try {
      const { data, status } = await this._axiosInstance.get(`txs/${hash}`);
      if (status === 200)
        return {
          block: data.block,
          deposit: data.deposit,
          fees: data.fees,
          hash: data.hash,
          index: data.index,
          invalidAfter: data.invalid_hereafter ?? "",
          invalidBefore: data.invalid_before ?? "",
          slot: data.slot.toString(),
          size: data.size
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Get UTxOs for a given hash.
   * @param hash The transaction hash
   * @param index Optional - The output index for filtering post fetching
   * @returns - Array of UTxOs
   */
  async fetchUTxOs(hash, index) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `txs/${hash}/utxos`
      );
      if (status === 200) {
        const bfOutputs = data.outputs;
        const outputsPromises = [];
        bfOutputs.forEach((output) => {
          outputsPromises.push(this.toUTxO(output, hash));
        });
        const outputs = await Promise.all(outputsPromises);
        if (index !== void 0) {
          return outputs.filter((utxo) => utxo.input.outputIndex === index);
        }
        return outputs;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Unimplemented - open for contribution
   *
   * Fetches the governance proposal information.
   * @param txHash The transaction hash of the proposal
   * @param certIndex The certificate index of the proposal
   * @returns The governance proposal information
   */
  async fetchGovernanceProposal(txHash, certIndex) {
    throw new Error("Method not implemented");
  }
  async get(url) {
    try {
      const { data, status } = await this._axiosInstance.get(url);
      if (status === 200) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.
   * @param txHash - The transaction hash to listen for confirmation
   * @param callback - The callback function to call when the transaction is confirmed
   * @param limit - The number of blocks to wait for confirmation
   */
  onTxConfirmed(txHash, callback, limit = 100) {
    let attempts = 0;
    const checkTx = setInterval(() => {
      if (attempts >= limit) clearInterval(checkTx);
      this.fetchTxInfo(txHash).then((txInfo) => {
        this.fetchBlockInfo(txInfo.block).then((blockInfo) => {
          if (blockInfo?.confirmations > 0) {
            clearInterval(checkTx);
            callback();
          }
        }).catch(() => {
          attempts += 1;
        });
      }).catch(() => {
        attempts += 1;
      });
    }, 5e3);
  }
  /**
   * Submit a serialized transaction to the network.
   * @param tx - The serialized transaction in hex to submit
   * @returns The transaction hash of the submitted transaction
   */
  async submitTx(txHex) {
    try {
      const headers = { "Content-Type": "text/plain" };
      const { status, data } = await this._axiosInstance.post(
        "/tx/submit",
        txHex,
        {
          headers
        }
      );
      if (status === 202) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Evaluates the resources required to execute the transaction
   * @param tx - The transaction to evaluate
   */
  async evaluateTx(txHex, additionalUtxos, additionalTxs) {
    try {
      const headers = { "Content-Type": "application/cbor" };
      const { status, data } = await this._axiosInstance.post(
        "utils/txs/evaluate",
        txHex,
        {
          headers
        }
      );
      if (status === 202 && data.result.EvaluationResult) {
        const tagMap = {
          spend: "SPEND",
          mint: "MINT",
          certificate: "CERT",
          reward: "REWARD"
        };
        const result = [];
        Object.keys(data.result.EvaluationResult).forEach((key) => {
          const [tagKey, index] = key.split(":");
          const { memory, steps } = data.result.EvaluationResult[key];
          result.push({
            tag: tagMap[tagKey],
            index: Number(index),
            budget: { mem: memory, steps }
          });
        });
        return result;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async getDevnetInfo() {
    try {
      if (this._adminAxiosInstance === void 0)
        throw parseHttpError("Admin URL not provided");
      const { status, data } = await this._adminAxiosInstance.get(
        `local-cluster/api/admin/devnet`
      );
      if (status === 200) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async getGenesisByEra(era) {
    try {
      if (this._adminAxiosInstance === void 0)
        throw parseHttpError("Admin URL not provided");
      const { status, data } = await this._adminAxiosInstance.get(
        `local-cluster/api/admin/devnet/genesis/${era}`
      );
      if (status === 200) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Topup address with ADA
   * @param address - Address to topup
   * @param amount - Amount to topup
   */
  async addressTopup(address, amount) {
    try {
      if (this._adminAxiosInstance === void 0)
        throw parseHttpError("Admin URL not provided");
      const headers = { "Content-Type": "application/json", accept: "*/*" };
      const { status, data } = await this._adminAxiosInstance.post(
        "local-cluster/api/addresses/topup",
        JSON.stringify({ address, adaAmount: parseInt(amount) }),
        {
          headers
        }
      );
      if (status === 200) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchPlutusScriptCBOR(scriptHash) {
    const { data, status } = await this._axiosInstance.get(
      `scripts/${scriptHash}/cbor`
    );
    if (status === 200) return data.cbor;
    throw parseHttpError(data);
  }
  async fetchNativeScriptJSON(scriptHash) {
    const { data, status } = await this._axiosInstance.get(
      `scripts/${scriptHash}/json`
    );
    if (status === 200) return data.json;
    throw parseHttpError(data);
  }
};

// src/kupo.ts
var import_axios7 = __toESM(require("axios"), 1);
var KupoProvider = class {
  baseUrl;
  _axiosInstance;
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
    this._axiosInstance = import_axios7.default.create({
      baseURL: this.baseUrl
    });
  }
  fetchAccountInfo(address) {
    throw new Error("Method not implemented.");
  }
  async fetchAddressUTxOs(address, asset) {
    const { status, data } = await this.get(address);
    if (status === 200) {
      return data.map((utxo) => {
        const meshValue = this.kupoValueToMeshValue(utxo.value);
        if (asset) {
          if (!meshValue.some((v) => v.unit === asset)) {
            return null;
          }
        }
        return {
          input: {
            txHash: utxo.transaction_id,
            outputIndex: utxo.output_index
          },
          output: {
            address: utxo.address,
            amount: this.kupoValueToMeshValue(utxo.value)
          }
        };
      }).filter((utxo) => utxo !== null);
    } else {
      parseHttpError(data);
    }
    return [];
  }
  fetchAddressTxs(address, options) {
    throw new Error("Method not implemented.");
  }
  fetchAssetAddresses(asset) {
    throw new Error("Method not implemented.");
  }
  fetchAssetMetadata(asset) {
    throw new Error("Method not implemented.");
  }
  fetchBlockInfo(hash) {
    throw new Error("Method not implemented.");
  }
  fetchCollectionAssets(policyId, cursor) {
    throw new Error("Method not implemented.");
  }
  fetchProtocolParameters(epoch) {
    throw new Error("Method not implemented.");
  }
  fetchTxInfo(hash) {
    throw new Error("Method not implemented.");
  }
  async fetchUTxOs(hash, index) {
    const { status, data } = await this.get(
      index === void 0 ? `*@${hash}` : `${index}@${hash}`
    );
    if (status === 200) {
      return data.map((utxo) => {
        return {
          input: {
            txHash: utxo.transaction_id,
            outputIndex: utxo.output_index
          },
          output: {
            address: utxo.address,
            amount: this.kupoValueToMeshValue(utxo.value)
          }
        };
      });
    } else {
      parseHttpError(data);
    }
    return [];
  }
  fetchGovernanceProposal(txHash, certIndex) {
    throw new Error("Method not implemented.");
  }
  get(pattern) {
    try {
      return this._axiosInstance.get(`matches/${pattern}`);
    } catch (error) {
      throw new Error(`Failed to fetch data from Kupo: ${error}`);
    }
  }
  kupoValueToMeshValue(value) {
    if (value === null || value === void 0) return value;
    let meshValue = [];
    meshValue.push({
      unit: "lovelace",
      quantity: String(value.coins)
    });
    for (const [assetClass, quantity] of Object.entries(value.assets)) {
      let [policyId, assetName] = assetClass.split(".");
      if (!policyId) {
        throw new Error("Invalid asset class format found");
      }
      if (!assetName) {
        assetName = "";
      }
      meshValue.push({
        unit: policyId + assetName,
        quantity: String(quantity)
      });
    }
    return meshValue;
  }
};

// src/multi-chain/maestro-unified.ts
var import_bitcoin = require("@meshsdk/bitcoin");
var MaestroMultiChainProvider = class {
  _cardanoProvider;
  _bitcoinProvider;
  _chain;
  /**
   * Create a Maestro provider for the specified chain.
   * @param config - Chain-specific configuration object.
   */
  constructor(config) {
    this._chain = config.chain;
    if (config.chain === "cardano") {
      this._cardanoProvider = new MaestroProvider({
        network: config.network,
        apiKey: config.apiKey,
        turboSubmit: config.turboSubmit
      });
    } else if (config.chain === "bitcoin") {
      this._bitcoinProvider = new import_bitcoin.MaestroProvider({
        network: config.network,
        apiKey: config.apiKey
      });
    }
  }
  /**
   * Get address transactions.
   * @param address - The address to query.
   * @param options - For Cardano: IFetcherOptions, for Bitcoin: lastSeenTxId string.
   * @returns Promise of transaction array (type depends on chain).
   */
  async getAddressTxs(address, options) {
    if (this._chain === "cardano") {
      if (!this._cardanoProvider) {
        throw new Error("Cardano provider not initialized.");
      }
      const cardanoOptions = typeof options === "string" ? void 0 : options;
      return this._cardanoProvider.fetchAddressTxs(address, cardanoOptions);
    }
    if (this._chain === "bitcoin") {
      if (!this._bitcoinProvider) {
        throw new Error("Bitcoin provider not initialized.");
      }
      const lastSeenTxId = typeof options === "string" ? options : void 0;
      return await this._bitcoinProvider.fetchAddressTransactions(address, lastSeenTxId);
    }
    throw new Error(`Unsupported chain: ${this._chain}`);
  }
  /**
   * Get address UTXOs.
   * @param address - The address to query.
   * @returns Promise of UTXO array (type depends on chain).
   */
  async getAddressUTxOs(address) {
    if (this._chain === "cardano") {
      if (!this._cardanoProvider) {
        throw new Error("Cardano provider not initialized.");
      }
      return this._cardanoProvider.fetchAddressUTxOs(address);
    }
    if (this._chain === "bitcoin") {
      if (!this._bitcoinProvider) {
        throw new Error("Bitcoin provider not initialized.");
      }
      return await this._bitcoinProvider.fetchAddressUTxOs(address);
    }
    throw new Error(`Unsupported chain: ${this._chain}`);
  }
  /**
   * Get address information including balance, transaction count, and UTXO statistics.
   * Available for Bitcoin only - Cardano doesn't have this endpoint.
   * @param address - The Bitcoin address to query.
   * @returns Promise of address info with chain_stats and mempool_stats.
   */
  async getAddressInfo(address) {
    if (this._chain !== "bitcoin") {
      throw new Error("Address info is only supported for Bitcoin chain. Cardano doesn't have this endpoint.");
    }
    if (!this._bitcoinProvider) {
      throw new Error("Bitcoin provider not initialized.");
    }
    return await this._bitcoinProvider.fetchAddress(address);
  }
  /**
   * Submit a transaction.
   * @param txData - The transaction data (format depends on chain).
   * @returns Promise of transaction ID.
   */
  async submitTx(txData) {
    if (this._chain === "cardano") {
      if (!this._cardanoProvider) {
        throw new Error("Cardano provider not initialized.");
      }
      return this._cardanoProvider.submitTx(txData);
    }
    if (this._chain === "bitcoin") {
      if (!this._bitcoinProvider) {
        throw new Error("Bitcoin provider not initialized.");
      }
      return this._bitcoinProvider.submitTx(txData);
    }
    throw new Error(`Unsupported chain: ${this._chain}`);
  }
  /**
   * Get the configured chain.
   * @returns The chain this provider is configured for.
   */
  getChain() {
    return this._chain;
  }
  /**
   * Get transaction details by hash.
   * @param txHash - The transaction hash.
   * @returns Promise of transaction details (type depends on chain).
   */
  async getTxInfo(txHash) {
    if (this._chain === "cardano") {
      if (!this._cardanoProvider) {
        throw new Error("Cardano provider not initialized.");
      }
      return this._cardanoProvider.fetchTxInfo(txHash);
    }
    if (this._chain === "bitcoin") {
      if (!this._bitcoinProvider) {
        throw new Error("Bitcoin provider not initialized.");
      }
      return await this._bitcoinProvider.fetchTxInfo(txHash);
    }
    throw new Error(`Unsupported chain: ${this._chain}`);
  }
  /**
   * Get transaction status/confirmation details.
   * @param txHash - The transaction hash.
   * @returns Promise of transaction status (type depends on chain).
   */
  async getTxStatus(txHash) {
    if (this._chain === "cardano") {
      if (!this._cardanoProvider) {
        throw new Error("Cardano provider not initialized.");
      }
      const txInfo = await this._cardanoProvider.fetchTxInfo(txHash);
      return { confirmed: true, details: txInfo };
    }
    if (this._chain === "bitcoin") {
      if (!this._bitcoinProvider) {
        throw new Error("Bitcoin provider not initialized.");
      }
      return await this._bitcoinProvider.fetchTransactionStatus(txHash);
    }
    throw new Error(`Unsupported chain: ${this._chain}`);
  }
  /**
   * Get the configured network.
   * @returns The network configuration.
   */
  async getNetwork() {
    if (this._chain === "cardano") {
      return "cardano-network";
    }
    if (this._chain === "bitcoin") {
      if (!this._bitcoinProvider) {
        throw new Error("Bitcoin provider not initialized.");
      }
      return this._bitcoinProvider.getNetwork();
    }
    throw new Error(`Unsupported chain: ${this._chain}`);
  }
  /**
   * Generic GET request to chain-specific API endpoints.
   * @param url - The API endpoint URL (relative to the chain's base URL).
   * @returns The response data.
   */
  async get(url) {
    if (this._chain === "cardano") {
      if (!this._cardanoProvider) {
        throw new Error("Cardano provider not initialized.");
      }
      return this._cardanoProvider.get(url);
    }
    if (this._chain === "bitcoin") {
      if (!this._bitcoinProvider) {
        throw new Error("Bitcoin provider not initialized.");
      }
      return this._bitcoinProvider.get(url);
    }
    throw new Error(`Unsupported chain: ${this._chain}`);
  }
  /**
   * Generic POST request to chain-specific API endpoints.
   * @param url - The API endpoint URL (relative to the chain's base URL).
   * @param body - The request body data.
   * @returns The response data.
   */
  async post(url, body) {
    if (this._chain === "cardano") {
      if (!this._cardanoProvider) {
        throw new Error("Cardano provider not initialized.");
      }
      return this._cardanoProvider.post(url, body);
    }
    if (this._chain === "bitcoin") {
      if (!this._bitcoinProvider) {
        throw new Error("Bitcoin provider not initialized.");
      }
      return this._bitcoinProvider.post(url, body);
    }
    throw new Error(`Unsupported chain: ${this._chain}`);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BeginProvider,
  BlockfrostProvider,
  KoiosProvider,
  KupoProvider,
  MaestroMultiChainProvider,
  MaestroProvider,
  OfflineFetcher,
  OgmiosProvider,
  U5CProvider,
  YaciProvider
});
