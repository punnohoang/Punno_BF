import * as ecpair from 'ecpair';
import * as _bip32 from 'bip32';
import * as bitcoin from 'bitcoinjs-lib';
export { bitcoin };
import * as bip39 from 'bip39';
export { bip39 };

declare const bip32: _bip32.BIP32API;
declare const ECPair: ecpair.ECPairAPI;

interface IBitcoinWallet {
    getChangeAddress(): Promise<string>;
    getNetworkId(): Promise<0 | 1>;
    signTx(signedTx: string): Promise<string>;
    submitTx(tx: string): Promise<string>;
}

type Address = {
    address: string;
    publicKey?: string;
    purpose: "payment" | "ordinals" | "stacks";
    addressType: "p2tr" | "p2wpkh" | "p2sh" | "stacks";
};

type UTxO = {
    status: {
        block_hash: string;
        block_height: number;
        block_time: number;
        confirmed: boolean;
    };
    txid: string;
    value: number;
    vout: number;
};

type ChainStats = {
    funded_txo_count: number;
    funded_txo_sum: number;
    spent_txo_count: number;
    spent_txo_sum: number;
    tx_count: number;
};

type MempoolStats = {
    funded_txo_count: number;
    funded_txo_sum: number;
    spent_txo_count: number;
    spent_txo_sum: number;
    tx_count: number;
};

type AddressInfo = {
    address: string;
    chain_stats: ChainStats;
    mempool_stats: MempoolStats;
};

type ScriptInfo = {
    scripthash: string;
    chain_stats: ChainStats;
    mempool_stats: MempoolStats;
};

type TransactionsStatus = {
    confirmed: boolean;
    block_height: number;
    block_hash: string;
    block_time: number;
};

type TransactionsInfo = {
    txid: string;
    version: number;
    locktime: number;
    vin: {
        txid: string;
        vout: number;
        prevout: {
            scriptpubkey: string;
            scriptpubkey_asm: string;
            scriptpubkey_type: string;
            scriptpubkey_address: string;
            value: number;
        };
        scriptsig: string;
        scriptsig_asm: string;
        witness: string[];
        is_coinbase: boolean;
        sequence: number;
    }[];
    vout: {
        scriptpubkey: string;
        scriptpubkey_asm: string;
        scriptpubkey_type: string;
        scriptpubkey_address: string;
        value: number;
    }[];
    size: number;
    weight: number;
    fee: number;
    status: TransactionsStatus;
};

interface IBitcoinProvider {
    fetchAddress(address: string): Promise<AddressInfo>;
    fetchAddressTransactions(address: string, last_seen_txid?: string): Promise<TransactionsInfo[]>;
    fetchAddressUTxOs(address: string): Promise<UTxO[]>;
    fetchScript(hash: string): Promise<ScriptInfo>;
    fetchScriptTransactions(hash: string, last_seen_txid?: string): Promise<TransactionsInfo[]>;
    fetchScriptUTxOs(hash: string): Promise<UTxO[]>;
    fetchTransactionStatus(txid: string): Promise<TransactionsStatus>;
    submitTx(tx: string): Promise<string>;
}

/**
 * https://github.com/Blockstream/esplora/blob/master/API.md
 */
declare class BlockstreamProvider implements IBitcoinProvider {
    private readonly _axiosInstance;
    constructor(network?: "mainnet" | "testnet");
    /**
     * Get information about an address.
     * @param address - The address.
     * @returns AddressInfo
     */
    fetchAddress(address: string): Promise<AddressInfo>;
    /**
     * Get transaction history for the specified address, sorted with newest first.
     * Returns up to 50 mempool transactions plus the first 25 confirmed transactions. You can request more confirmed transactions using `last_seen_txid`.
     * @param address - The address.
     * @param last_seen_txid - The last seen transaction ID (optional).
     * @returns TransactionsInfo[]
     */
    fetchAddressTransactions(address: string, last_seen_txid?: string): Promise<TransactionsInfo[]>;
    /**
     * Get the list of unspent transaction outputs associated with the address.
     * @param address - The address.
     * @returns UTxO[]
     */
    fetchAddressUTxOs(address: string): Promise<UTxO[]>;
    /**
     * Get information about a scripthash.
     * @param hash - The hash of the script.
     * @returns ScriptInfo
     */
    fetchScript(hash: string): Promise<ScriptInfo>;
    /**
     * Get transaction history for the specified scripthash, sorted with newest first.
     * Returns up to 50 mempool transactions plus the first 25 confirmed transactions. You can request more confirmed transactions using `last_seen_txid`.
     * @param hash - The hash of the script.
     * @param last_seen_txid - The last seen transaction ID (optional).
     * @returns TransactionsInfo[]
     */
    fetchScriptTransactions(hash: string, last_seen_txid?: string): Promise<TransactionsInfo[]>;
    /**
     * Get the list of unspent transaction outputs associated with the scripthash.
     * @param hash - The hash of the script.
     * @returns UTxO[]
     */
    fetchScriptUTxOs(hash: string): Promise<UTxO[]>;
    /**
     * Fetches the status of a transaction
     * @param txid - The transaction ID.
     * @returns TransactionsStatus
     */
    fetchTransactionStatus(txid: string): Promise<TransactionsStatus>;
    /**
     * Broadcast a raw transaction to the network.
     * The transaction should be provided as hex in the request body. The txid will be returned on success.
     * @param tx - The transaction in hex format.
     * @returns The transaction ID.
     */
    submitTx(tx: string): Promise<string>;
}

declare function resolveAddress(publicKey: string | Buffer, network: "mainnet" | "testnet" | bitcoin.networks.Network): Address;

declare class BrowserWallet implements IBitcoinWallet {
    private readonly _purposes;
    constructor(purposes: string[]);
    /**
     * This is the entrypoint to start communication with the user's wallet. The wallet should request the user's permission to connect the web page to the user's wallet, and if permission has been granted, the wallet will be returned and exposing the full API for the dApp to use.
     * @param message - A message to display to the user when requesting permission to connect the wallet.
     * @param purposes - An array of purposes for which the wallet is being connected. Default is `["payment"]`. Options are `["payment", "ordinals", "stacks"]`.
     * @returns
     */
    static enable(message: string, purposes?: string[]): Promise<BrowserWallet>;
    getAddresses(): Promise<Address[] | undefined>;
    getChangeAddress(): Promise<string>;
    getCollateral(): Promise<never[]>;
    getNetworkId(): Promise<0 | 1>;
    request(method: string, params?: any): Promise<any>;
    signData(payload: string, address?: string, addressType?: "p2wpkh" | "p2tr" | "stacks"): Promise<{
        address: string;
        signature: string;
        messageHash: string;
    } | undefined>;
    signTx(signedTx: string): Promise<string>;
    submitTx(signedTx: string): Promise<string>;
}

type CreateWalletOptions = {
    testnet: boolean;
    key: {
        type: "mnemonic";
        words: string[];
    } | {
        type: "address";
        address: string;
    };
    path?: string;
    provider?: IBitcoinProvider;
};
type TransactionPayload = {
    inputs: {
        txid: string;
        vout: number;
        value: number;
    }[];
    outputs: {
        address: string;
        value: number;
    }[];
};
/**
 * EmbeddedWallet is a class that provides a simple interface to interact with Bitcoin wallets.
 */
declare class EmbeddedWallet {
    private readonly _network;
    private readonly _wallet?;
    private readonly _provider?;
    private readonly _isReadOnly;
    private readonly _address?;
    constructor(options: CreateWalletOptions);
    /**
     * Returns the wallet's SegWit (P2WPKH) address and associated public key.
     *
     * @returns {Address} The wallet address object including address, public key, and metadata.
     * @throws {Error} If internal address or public key is not properly initialized.
     */
    getAddress(): Address;
    /**
     * Returns the hex-encoded public key of the wallet.
     *
     * @returns {string} The public key in hexadecimal format.
     * @throws {Error} If the wallet is read-only and public key is not available.
     */
    getPublicKey(): string;
    /**
     * Returns the network identifier of the wallet.
     * 0': Indicates the Bitcoin mainnet.
     * 1': Indicates the Bitcoin testnet.
     *
     * @returns {0 | 1} The Bitcoin network ID.
     */
    getNetworkId(): 0 | 1;
    /**
     * Get UTXOs for the wallet address.
     * @returns An array of UTXOs.
     */
    getUTxOs(): Promise<UTxO[]>;
    /**
     * Signs a given message using the wallet's private key.
     *
     * @param message - The message to be signed.
     * @returns The signature of the message as a string.
     * @throws {Error} If the wallet is read-only or private key is not available.
     */
    signData(message: string): Promise<string>;
    /**
     * Sign a transaction payload.
     * @param payload - The transaction payload to sign.
     * @returns The signed transaction in hex format.
     * @throws {Error} If the wallet is read-only or private key is not available.
     */
    signTx(payload: TransactionPayload): Promise<string>;
    /**
     * Generates a mnemonic phrase and returns it as an array of words.
     *
     * @param {number} [strength=128] - The strength of the mnemonic in bits (must be a multiple of 32 between 128 and 256).
     * @returns {string[]} An array of words representing the generated mnemonic.
     * @throws {Error} If the strength is not valid.
     */
    static brew(strength?: number): string[];
}
/**
 * Verifies if a signature is valid for a given message and public key.
 * @param message - The original message that was signed.
 * @param signatureBase64 - The base64-encoded signature to verify.
 * @param publicKeyHex - The hex-encoded public key to verify against.
 * @returns {boolean} True if the signature is valid and matches the public key.
 */
declare function verifySignature(message: string, signatureBase64: string, publicKeyHex: string): boolean;

export { type Address, BlockstreamProvider, BrowserWallet, type CreateWalletOptions, ECPair, EmbeddedWallet, type IBitcoinWallet, type TransactionPayload, type UTxO, bip32, resolveAddress, verifySignature };
