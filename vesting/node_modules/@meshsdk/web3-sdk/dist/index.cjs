"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  ApiError: () => ApiError,
  AuthRouteError: () => AuthRouteError,
  NotAuthenticatedError: () => NotAuthenticatedError,
  SessionExpiredError: () => SessionExpiredError,
  StorageInsertError: () => StorageInsertError,
  StorageRetrievalError: () => StorageRetrievalError,
  WalletServerCreationError: () => WalletServerCreationError,
  WalletServerRetrievalError: () => WalletServerRetrievalError,
  Web3NonCustodialProvider: () => Web3NonCustodialProvider,
  Web3Sdk: () => Web3Sdk,
  Web3Wallet: () => Web3Wallet,
  bytesToHex: () => bytesToHex,
  bytesToString: () => bytesToString,
  clientDeriveWallet: () => clientDeriveWallet,
  clientGenerateWallet: () => clientGenerateWallet,
  clientRecovery: () => clientRecovery,
  combineShardsBuildWallet: () => combineShardsBuildWallet,
  crypto: () => crypto2,
  decryptWithCipher: () => decryptWithCipher,
  decryptWithPrivateKey: () => decryptWithPrivateKey,
  encryptWithCipher: () => encryptWithCipher,
  encryptWithPublicKey: () => encryptWithPublicKey,
  generateHash: () => generateHash,
  generateKeyPair: () => generateKeyPair,
  getAddressFromHashes: () => getAddressFromHashes,
  hashData: () => hashData,
  hexToBytes: () => hexToBytes,
  meshUniversalStaticUtxo: () => meshUniversalStaticUtxo,
  openWindow: () => openWindow,
  shamirCombine: () => shamirCombine,
  shamirSplit: () => shamirSplit,
  spiltKeyIntoShards: () => spiltKeyIntoShards,
  stringToBytes: () => stringToBytes
});
module.exports = __toCommonJS(index_exports);

// src/functions/crypto/index.ts
var import_webcrypto = require("@peculiar/webcrypto");

// src/functions/crypto/encryption.ts
var IV_LENGTH = 16;
async function encryptWithCipher({
  data,
  key,
  algorithm = "AES-GCM",
  initializationVectorSize = IV_LENGTH
}) {
  const keyMaterial = await crypto2.subtle.importKey(
    "raw",
    new TextEncoder().encode(key),
    { name: "PBKDF2" },
    false,
    ["deriveKey"]
  );
  const cryptoKey = await crypto2.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: new Uint8Array(initializationVectorSize),
      // Use a fixed salt for simplicity
      iterations: 1e5,
      hash: "SHA-256"
    },
    keyMaterial,
    { name: algorithm, length: 256 },
    false,
    ["encrypt"]
  );
  const iv = crypto2.getRandomValues(new Uint8Array(initializationVectorSize));
  const encrypted = await crypto2.subtle.encrypt(
    { name: algorithm, iv },
    cryptoKey,
    new TextEncoder().encode(data)
  );
  return JSON.stringify({
    iv: Buffer.from(iv).toString("base64"),
    ciphertext: Buffer.from(encrypted).toString("base64")
  });
}
async function decryptWithCipher({
  encryptedDataJSON,
  key,
  algorithm = "AES-GCM"
}) {
  const _encryptedData = JSON.parse(encryptedDataJSON);
  const keyMaterial = await crypto2.subtle.importKey(
    "raw",
    new TextEncoder().encode(key),
    { name: "PBKDF2" },
    false,
    ["deriveKey"]
  );
  const cryptoKey = await crypto2.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: new Uint8Array(Buffer.from(_encryptedData.iv, "base64").length),
      // Use the same salt size as IV
      iterations: 1e5,
      hash: "SHA-256"
    },
    keyMaterial,
    { name: algorithm, length: 256 },
    false,
    ["decrypt"]
  );
  const decodedIv = Buffer.from(_encryptedData.iv, "base64");
  const decodedEncryptedData = Buffer.from(_encryptedData.ciphertext, "base64");
  const decrypted = await crypto2.subtle.decrypt(
    { name: algorithm, iv: decodedIv },
    cryptoKey,
    decodedEncryptedData
  );
  return new TextDecoder().decode(decrypted);
}
async function generateKeyPair() {
  const keyPair = await crypto2.subtle.generateKey(
    {
      name: "ECDH",
      namedCurve: "P-256"
    },
    true,
    ["deriveKey"]
  );
  const publicKey = await crypto2.subtle.exportKey("spki", keyPair.publicKey);
  const privateKey = await crypto2.subtle.exportKey("pkcs8", keyPair.privateKey);
  const key = {
    publicKey: Buffer.from(publicKey).toString("base64"),
    privateKey: Buffer.from(privateKey).toString("base64")
  };
  return key;
}
async function encryptWithPublicKey({
  publicKey,
  data
}) {
  const publicKeyBuffer = Buffer.from(publicKey, "base64");
  const _publicKey = await crypto2.subtle.importKey(
    "spki",
    publicKeyBuffer,
    { name: "ECDH", namedCurve: "P-256" },
    false,
    []
  );
  const ephemeralKeyPair = await crypto2.subtle.generateKey(
    { name: "ECDH", namedCurve: "P-256" },
    true,
    ["deriveKey"]
  );
  const sharedSecret = await crypto2.subtle.deriveKey(
    { name: "ECDH", public: _publicKey },
    ephemeralKeyPair.privateKey,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt"]
  );
  const iv = crypto2.getRandomValues(new Uint8Array(12));
  const encrypted = await crypto2.subtle.encrypt(
    { name: "AES-GCM", iv },
    sharedSecret,
    new TextEncoder().encode(data)
  );
  const encryptedData = {
    ephemeralPublicKey: await crypto2.subtle.exportKey(
      "spki",
      ephemeralKeyPair.publicKey
    ),
    iv,
    ciphertext: encrypted
  };
  return JSON.stringify({
    ephemeralPublicKey: Buffer.from(encryptedData.ephemeralPublicKey).toString(
      "base64"
    ),
    iv: Buffer.from(encryptedData.iv).toString("base64"),
    ciphertext: Buffer.from(encryptedData.ciphertext).toString("base64")
  });
}
async function decryptWithPrivateKey({
  privateKey,
  encryptedDataJSON
}) {
  const privateKeyBuffer = Buffer.from(privateKey, "base64");
  const _encryptedData = JSON.parse(encryptedDataJSON);
  const encryptedData = {
    ephemeralPublicKey: Buffer.from(
      _encryptedData.ephemeralPublicKey,
      "base64"
    ),
    iv: Buffer.from(_encryptedData.iv, "base64"),
    ciphertext: Buffer.from(_encryptedData.ciphertext, "base64")
  };
  const _privateKey = await crypto2.subtle.importKey(
    "pkcs8",
    privateKeyBuffer,
    { name: "ECDH", namedCurve: "P-256" },
    false,
    ["deriveKey"]
  );
  const ephemeralPublicKey = await crypto2.subtle.importKey(
    "spki",
    encryptedData.ephemeralPublicKey,
    { name: "ECDH", namedCurve: "P-256" },
    false,
    []
  );
  const sharedSecret = await crypto2.subtle.deriveKey(
    { name: "ECDH", public: ephemeralPublicKey },
    _privateKey,
    { name: "AES-GCM", length: 256 },
    false,
    ["decrypt"]
  );
  const decrypted = await crypto2.subtle.decrypt(
    { name: "AES-GCM", iv: encryptedData.iv },
    sharedSecret,
    encryptedData.ciphertext
  );
  return new TextDecoder().decode(decrypted);
}

// src/functions/crypto/hash.ts
var crypto3 = __toESM(require("crypto"), 1);
function generateHash({
  size = 64
}) {
  return new Promise((resolve, reject) => {
    crypto3.randomBytes(size, function(err, buffer) {
      resolve(buffer.toString("hex"));
    });
  });
}
async function hashData({
  data,
  privateKey = "",
  algorithm = "sha256"
}) {
  return new Promise((resolve, reject) => {
    const hmac = crypto3.createHmac(algorithm, privateKey);
    hmac.on("readable", () => {
      const data2 = hmac.read();
      if (data2) {
        resolve(data2.toString("hex"));
      }
    });
    hmac.write(data);
    hmac.end();
  });
}

// src/functions/crypto/index.ts
var crypto2;
if (typeof window !== "undefined" && window.crypto && window.crypto.subtle) {
  crypto2 = window.crypto;
} else if (typeof global !== "undefined") {
  const webCrypto = new import_webcrypto.Crypto();
  crypto2 = webCrypto;
} else {
  throw new Error("Web Crypto API is not supported in this environment.");
}

// src/functions/key-shard/combine-shards-build-wallet.ts
var import_wallet = require("@meshsdk/wallet");

// src/functions/key-shard/shamir-secret-sharing.ts
function getRandomBytes(numBytes) {
  return crypto.getRandomValues(new Uint8Array(numBytes));
}
var LOG_TABLE = new Uint8Array([
  0,
  255,
  200,
  8,
  145,
  16,
  208,
  54,
  90,
  62,
  216,
  67,
  153,
  119,
  254,
  24,
  35,
  32,
  7,
  112,
  161,
  108,
  12,
  127,
  98,
  139,
  64,
  70,
  199,
  75,
  224,
  14,
  235,
  22,
  232,
  173,
  207,
  205,
  57,
  83,
  106,
  39,
  53,
  147,
  212,
  78,
  72,
  195,
  43,
  121,
  84,
  40,
  9,
  120,
  15,
  33,
  144,
  135,
  20,
  42,
  169,
  156,
  214,
  116,
  180,
  124,
  222,
  237,
  177,
  134,
  118,
  164,
  152,
  226,
  150,
  143,
  2,
  50,
  28,
  193,
  51,
  238,
  239,
  129,
  253,
  48,
  92,
  19,
  157,
  41,
  23,
  196,
  17,
  68,
  140,
  128,
  243,
  115,
  66,
  30,
  29,
  181,
  240,
  18,
  209,
  91,
  65,
  162,
  215,
  44,
  233,
  213,
  89,
  203,
  80,
  168,
  220,
  252,
  242,
  86,
  114,
  166,
  101,
  47,
  159,
  155,
  61,
  186,
  125,
  194,
  69,
  130,
  167,
  87,
  182,
  163,
  122,
  117,
  79,
  174,
  63,
  55,
  109,
  71,
  97,
  190,
  171,
  211,
  95,
  176,
  88,
  175,
  202,
  94,
  250,
  133,
  228,
  77,
  138,
  5,
  251,
  96,
  183,
  123,
  184,
  38,
  74,
  103,
  198,
  26,
  248,
  105,
  37,
  179,
  219,
  189,
  102,
  221,
  241,
  210,
  223,
  3,
  141,
  52,
  217,
  146,
  13,
  99,
  85,
  170,
  73,
  236,
  188,
  149,
  60,
  132,
  11,
  245,
  230,
  231,
  229,
  172,
  126,
  110,
  185,
  249,
  218,
  142,
  154,
  201,
  36,
  225,
  10,
  21,
  107,
  58,
  160,
  81,
  244,
  234,
  178,
  151,
  158,
  93,
  34,
  136,
  148,
  206,
  25,
  1,
  113,
  76,
  165,
  227,
  197,
  49,
  187,
  204,
  31,
  45,
  59,
  82,
  111,
  246,
  46,
  137,
  247,
  192,
  104,
  27,
  100,
  4,
  6,
  191,
  131,
  56
]);
var EXP_TABLE = new Uint8Array([
  1,
  229,
  76,
  181,
  251,
  159,
  252,
  18,
  3,
  52,
  212,
  196,
  22,
  186,
  31,
  54,
  5,
  92,
  103,
  87,
  58,
  213,
  33,
  90,
  15,
  228,
  169,
  249,
  78,
  100,
  99,
  238,
  17,
  55,
  224,
  16,
  210,
  172,
  165,
  41,
  51,
  89,
  59,
  48,
  109,
  239,
  244,
  123,
  85,
  235,
  77,
  80,
  183,
  42,
  7,
  141,
  255,
  38,
  215,
  240,
  194,
  126,
  9,
  140,
  26,
  106,
  98,
  11,
  93,
  130,
  27,
  143,
  46,
  190,
  166,
  29,
  231,
  157,
  45,
  138,
  114,
  217,
  241,
  39,
  50,
  188,
  119,
  133,
  150,
  112,
  8,
  105,
  86,
  223,
  153,
  148,
  161,
  144,
  24,
  187,
  250,
  122,
  176,
  167,
  248,
  171,
  40,
  214,
  21,
  142,
  203,
  242,
  19,
  230,
  120,
  97,
  63,
  137,
  70,
  13,
  53,
  49,
  136,
  163,
  65,
  128,
  202,
  23,
  95,
  83,
  131,
  254,
  195,
  155,
  69,
  57,
  225,
  245,
  158,
  25,
  94,
  182,
  207,
  75,
  56,
  4,
  185,
  43,
  226,
  193,
  74,
  221,
  72,
  12,
  208,
  125,
  61,
  88,
  222,
  124,
  216,
  20,
  107,
  135,
  71,
  232,
  121,
  132,
  115,
  60,
  189,
  146,
  201,
  35,
  139,
  151,
  149,
  68,
  220,
  173,
  64,
  101,
  134,
  162,
  164,
  204,
  127,
  236,
  192,
  175,
  145,
  253,
  247,
  79,
  129,
  47,
  91,
  234,
  168,
  28,
  2,
  209,
  152,
  113,
  237,
  37,
  227,
  36,
  6,
  104,
  179,
  147,
  44,
  111,
  62,
  108,
  10,
  184,
  206,
  174,
  116,
  177,
  66,
  180,
  30,
  211,
  73,
  233,
  156,
  200,
  198,
  199,
  34,
  110,
  219,
  32,
  191,
  67,
  81,
  82,
  102,
  178,
  118,
  96,
  218,
  197,
  243,
  246,
  170,
  205,
  154,
  160,
  117,
  84,
  14,
  1
]);
function add(a, b) {
  if (!Number.isInteger(a) || a < 0 || a > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  if (!Number.isInteger(b) || b < 0 || b > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  return a ^ b;
}
function div(a, b) {
  if (!Number.isInteger(a) || a < 0 || a > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  if (!Number.isInteger(b) || b < 0 || b > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  if (b === 0) {
    throw new Error("cannot divide by zero");
  }
  const logA = LOG_TABLE[a];
  const logB = LOG_TABLE[b];
  const diff = (logA - logB + 255) % 255;
  const result = EXP_TABLE[diff];
  return a === 0 ? 0 : result;
}
function mult(a, b) {
  if (!Number.isInteger(a) || a < 0 || a > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  if (!Number.isInteger(b) || b < 0 || b > 255) {
    throw new RangeError("Number is out of Uint8 range");
  }
  const logA = LOG_TABLE[a];
  const logB = LOG_TABLE[b];
  const sum = (logA + logB) % 255;
  const result = EXP_TABLE[sum];
  return a === 0 || b === 0 ? 0 : result;
}
function interpolatePolynomial(xSamples, ySamples, x) {
  if (xSamples.length !== ySamples.length) {
    throw new Error("sample length mistmatch");
  }
  const limit = xSamples.length;
  let basis = 0;
  let result = 0;
  for (let i = 0; i < limit; i++) {
    basis = 1;
    for (let j = 0; j < limit; ++j) {
      if (i === j) {
        continue;
      }
      const num = add(x, xSamples[j]);
      const denom = add(xSamples[i], xSamples[j]);
      const term = div(num, denom);
      basis = mult(basis, term);
    }
    result = add(result, mult(ySamples[i], basis));
  }
  return result;
}
function evaluate(coefficients, x, degree) {
  if (x === 0) {
    throw new Error("cannot evaluate secret polynomial at zero");
  }
  let result = coefficients[degree];
  for (let i = degree - 1; i >= 0; i--) {
    const coefficient = coefficients[i];
    result = add(mult(result, x), coefficient);
  }
  return result;
}
function getRandomByte() {
  return getRandomBytes(1)[0];
}
function getNonZeroRandomByte() {
  while (true) {
    const byte = getRandomByte();
    if (byte > 0) {
      return byte;
    }
  }
}
function newCoefficients(intercept, degree) {
  const coefficients = new Uint8Array(degree + 1);
  coefficients[0] = intercept;
  for (let i = 1; i <= degree; i++) {
    const coefficientTMinus1 = i === degree;
    coefficients[i] = coefficientTMinus1 ? getNonZeroRandomByte() : getRandomByte();
  }
  return coefficients;
}
function newCoordinates() {
  const coordinates = new Uint8Array(255);
  for (let i = 0; i < 255; i++) {
    coordinates[i] = i + 1;
  }
  const randomIndices = getRandomBytes(255);
  for (let i = 0; i < 255; i++) {
    const j = randomIndices[i] % 255;
    const temp = coordinates[i];
    coordinates[i] = coordinates[j];
    coordinates[j] = temp;
  }
  return coordinates;
}
var AssertArgument = {
  instanceOf(object, constructor, message) {
    if (object.constructor !== constructor) {
      throw new TypeError(message);
    }
  },
  inRange(n, start, until, message) {
    if (!(start < until && n >= start && n < until)) {
      throw new RangeError(message);
    }
  },
  greaterThanOrEqualTo(a, b, message) {
    if (a < b) {
      throw new Error(message);
    }
  },
  equalTo(a, b, message) {
    if (a !== b) {
      throw new Error(message);
    }
  }
};
async function shamirSplit(secret, shares, threshold) {
  AssertArgument.instanceOf(secret, Uint8Array, "secret must be a Uint8Array");
  AssertArgument.greaterThanOrEqualTo(secret.byteLength, 1, "secret cannot be empty");
  AssertArgument.instanceOf(shares, Number, "shares must be a number");
  AssertArgument.inRange(shares, 2, 256, "shares must be at least 2 and at most 255");
  AssertArgument.instanceOf(threshold, Number, "threshold must be a number");
  AssertArgument.inRange(threshold, 2, 256, "threshold must be at least 2 and at most 255");
  AssertArgument.greaterThanOrEqualTo(shares, threshold, "shares cannot be less than threshold");
  const result = [];
  const secretLength = secret.byteLength;
  const xCoordinates = newCoordinates();
  for (let i = 0; i < shares; i++) {
    const share = new Uint8Array(secretLength + 1);
    share[secretLength] = xCoordinates[i];
    result.push(share);
  }
  const degree = threshold - 1;
  for (let i = 0; i < secretLength; i++) {
    const byte = secret[i];
    const coefficients = newCoefficients(byte, degree);
    for (let j = 0; j < shares; ++j) {
      const x = xCoordinates[j];
      const y = evaluate(coefficients, x, degree);
      result[j][i] = y;
    }
  }
  return result;
}
async function shamirCombine(shares) {
  AssertArgument.instanceOf(shares, Array, "shares must be an Array");
  AssertArgument.inRange(
    shares.length,
    2,
    256,
    "shares must have at least 2 and at most 255 elements"
  );
  const share1 = shares[0];
  AssertArgument.instanceOf(share1, Uint8Array, "each share must be a Uint8Array");
  for (const share of shares) {
    AssertArgument.instanceOf(share, Uint8Array, "each share must be a Uint8Array");
    AssertArgument.greaterThanOrEqualTo(share.byteLength, 2, "each share must be at least 2 bytes");
    AssertArgument.equalTo(
      share.byteLength,
      share1.byteLength,
      "all shares must have the same byte length"
    );
  }
  const sharesLength = shares.length;
  const shareLength = share1.byteLength;
  const secretLength = shareLength - 1;
  const secret = new Uint8Array(secretLength);
  const xSamples = new Uint8Array(sharesLength);
  const ySamples = new Uint8Array(sharesLength);
  const samples = /* @__PURE__ */ new Set();
  for (let i = 0; i < sharesLength; i++) {
    const share = shares[i];
    const sample = share[shareLength - 1];
    if (samples.has(sample)) {
      throw new Error("shares must contain unique values but a duplicate was found");
    }
    samples.add(sample);
    xSamples[i] = sample;
  }
  for (let i = 0; i < secretLength; i++) {
    for (let j = 0; j < sharesLength; ++j) {
      ySamples[j] = shares[j][i];
    }
    secret[i] = interpolatePolynomial(xSamples, ySamples, 0);
  }
  return secret;
}

// src/functions/convertors.ts
function stringToBytes(data) {
  return new TextEncoder().encode(data);
}
function bytesToString(data) {
  return new TextDecoder().decode(data);
}
function bytesToHex(bytes) {
  return Array.from(bytes).map((byte) => byte.toString(16).padStart(2, "0")).join("");
}
function hexToBytes(hex) {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
  }
  return bytes;
}

// src/functions/key-shard/combine-shards-build-wallet.ts
var import_bitcoin = require("@meshsdk/bitcoin");
async function combineShardsBuildWallet(networkId, keyShard1, keyShard2) {
  const _share1 = hexToBytes(keyShard1);
  const _share2 = hexToBytes(keyShard2);
  const reconstructed = await shamirCombine([_share1, _share2]);
  const key = bytesToString(reconstructed);
  const bitcoinWallet = new import_bitcoin.EmbeddedWallet({
    testnet: networkId === 0 ? true : false,
    key: {
      type: "mnemonic",
      words: key.split(" ")
    }
  });
  const cardanoWallet = new import_wallet.MeshWallet({
    networkId,
    key: {
      type: "mnemonic",
      words: key.split(" ")
    }
  });
  await cardanoWallet.init();
  return { key, bitcoinWallet, cardanoWallet };
}

// src/functions/key-shard/get-address-from-hashes.ts
var import_common = require("@meshsdk/common");
var import_core_cst = require("@meshsdk/core-cst");
function getAddressFromHashes(pubKeyHash, stakeCredentialHash, networkId) {
  return (0, import_core_cst.serializeAddressObj)(
    (0, import_common.pubKeyAddress)(pubKeyHash, stakeCredentialHash),
    networkId
  );
}

// src/functions/key-shard/spilt-key-into-shards.ts
async function spiltKeyIntoShards(key) {
  const secret = stringToBytes(key);
  const [share1, share2, share3] = await shamirSplit(secret, 3, 2);
  const keyShare1 = bytesToHex(share1);
  const keyShare2 = bytesToHex(share2);
  const keyShare3 = bytesToHex(share3);
  return [keyShare1, keyShare2, keyShare3];
}

// src/functions/client/derive-wallet.ts
async function clientDeriveWallet(encryptedKeyShard, spendingPassword, custodialShard, networkId) {
  const keyShare1 = await decryptWithCipher({
    encryptedDataJSON: encryptedKeyShard,
    key: spendingPassword
  });
  const keyShare2 = custodialShard;
  const { bitcoinWallet, cardanoWallet, key } = await combineShardsBuildWallet(
    networkId,
    keyShare1,
    keyShare2
  );
  return { bitcoinWallet, cardanoWallet, key };
}

// src/functions/client/generate-wallet.ts
var import_wallet2 = require("@meshsdk/wallet");
var import_common2 = require("@meshsdk/common");
var import_core_cst2 = require("@meshsdk/core-cst");
var import_bitcoin2 = require("@meshsdk/bitcoin");
async function clientGenerateWallet(spendingPassword, recoveryAnswer) {
  const mnemonic = await (0, import_common2.generateMnemonic)(256);
  const wallet = new import_wallet2.MeshWallet({
    networkId: 1,
    key: {
      type: "mnemonic",
      words: mnemonic.split(" ")
    }
  });
  await wallet.init();
  const addresses = await wallet.getAddresses();
  const keyHashes = (0, import_core_cst2.deserializeBech32Address)(addresses.baseAddressBech32);
  const [keyShare1, keyShare2, keyShare3] = await spiltKeyIntoShards(mnemonic);
  const encryptedDeviceShard = await encryptWithCipher({
    data: keyShare1,
    key: spendingPassword
  });
  const encryptedRecoveryShard = await encryptWithCipher({
    data: keyShare3,
    key: recoveryAnswer
  });
  const bitcoinWallet = new import_bitcoin2.EmbeddedWallet({
    testnet: true,
    key: {
      type: "mnemonic",
      words: mnemonic.split(" ")
    }
  });
  const bitcoinPubKeyHash = bitcoinWallet.getPublicKey();
  return {
    pubKeyHash: keyHashes.pubKeyHash,
    stakeCredentialHash: keyHashes.stakeCredentialHash,
    encryptedDeviceShard,
    authShard: keyShare2,
    encryptedRecoveryShard,
    bitcoinPubKeyHash
  };
}

// src/functions/client/recovery.ts
async function clientRecovery(authShard, recoveryShard, recoveryAnswer, spendingPassword) {
  try {
    const answer = recoveryAnswer.replace(/[^a-zA-Z0-9]/g, "").toLocaleLowerCase();
    const recoverKeyShare3 = await decryptWithCipher({
      encryptedDataJSON: recoveryShard,
      key: answer
    });
    const recoverKeyShare2 = authShard;
    const { key } = await combineShardsBuildWallet(
      0,
      // dont care about network here
      recoverKeyShare2,
      recoverKeyShare3
    );
    const [keyShare1, keyShare2] = await spiltKeyIntoShards(key);
    const encryptedAuthKey = await encryptWithCipher({
      data: keyShare1,
      key: spendingPassword
    });
    return {
      deviceShard: encryptedAuthKey,
      authShard: keyShare2
    };
  } catch (e) {
    console.error(e);
    throw new Error("Invalid recovery answer");
  }
}

// src/functions/window/open-window.ts
var buildWindowFeatures = () => {
  const sizeDefault = {
    width: 512,
    height: 768
  };
  const sizeTight = {
    width: 448,
    height: 668
  };
  const sizeSmall = {
    width: 340,
    height: 546
  };
  const size = sizeTight;
  const windowWidth = window.innerWidth || 0;
  const windowHeight = window.innerHeight || 0;
  const isMobile = windowWidth < 640;
  const isFullScreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
  const shouldDisplayFullScreen = isMobile || isFullScreen;
  const width = shouldDisplayFullScreen ? windowWidth : size.width;
  const height = shouldDisplayFullScreen ? windowHeight : size.height;
  const name = "_blank";
  const windowFeatures = `left=${(windowWidth - width) / 2},top=${(windowHeight - height) / 2},width=${width},height=${height},scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no`;
  return windowFeatures;
};
async function openWindow(params, appUrl = "https://utxos.dev/") {
  const p = new URLSearchParams(params);
  const _url = `${appUrl}/client/wallet?${p.toString()}`;
  return new Promise((resolve, reject) => {
    const newWindow = window.open(_url, "mesh", buildWindowFeatures());
    if (!newWindow) {
      return reject(new Error("Failed to open window"));
    }
    const interval = setInterval(() => {
      if (newWindow.closed) {
        clearInterval(interval);
        resolve({ success: false, message: "Window was closed by the user" });
      }
    }, 500);
    window.addEventListener("message", (event) => {
      if (event.data.target === "mesh") {
        clearInterval(interval);
        resolve(event.data);
      }
    });
  });
}

// src/sdk/index.ts
var import_axios = __toESM(require("axios"), 1);

// src/sdk/wallet-developer-controlled/index.ts
var import_wallet3 = require("@meshsdk/wallet");
var import_core_cst3 = require("@meshsdk/core-cst");
var import_uuid = require("uuid");
var WalletDeveloperControlled = class {
  sdk;
  constructor({ sdk }) {
    {
      this.sdk = sdk;
    }
  }
  /**
   * Creates a new wallet associated with the current project.
   * This method generates a new wallet encrypts it with the project's public key, and registers the wallet with the backend service.
   *
   * @param {Object} [options] - Optional parameters for wallet creation.
   * @param {string} [options.tag] - An optional tag to associate with the wallet.
   *
   * @returns {Promise<Web3ProjectWallet>} A promise that resolves to the created wallet instance.
   *
   * @throws {Error} If the project's public key is not found.
   * @throws {Error} If the wallet creation request to the backend fails.
   */
  async createWallet({
    tags
  } = {}) {
    const project = await this.sdk.getProject();
    if (!project.publicKey) {
      throw new Error("Project public key not found");
    }
    const mnemonic = import_wallet3.MeshWallet.brew();
    const encryptedMnemonic = await encryptWithPublicKey({
      publicKey: project.publicKey,
      data: mnemonic.join(" ")
    });
    const _wallet = new import_wallet3.MeshWallet({
      networkId: 1,
      key: {
        type: "mnemonic",
        words: mnemonic
      },
      fetcher: this.sdk.providerFetcher,
      submitter: this.sdk.providerSubmitter
    });
    await _wallet.init();
    const addresses = await _wallet.getAddresses();
    const baseAddressBech32 = addresses.baseAddressBech32;
    const { pubKeyHash, stakeCredentialHash } = (0, import_core_cst3.deserializeBech32Address)(baseAddressBech32);
    const web3Wallet = {
      id: (0, import_uuid.v4)(),
      key: encryptedMnemonic,
      tags: tags || [],
      projectId: this.sdk.projectId,
      pubKeyHash,
      stakeCredentialHash
    };
    const { data, status } = await this.sdk.axiosInstance.post(
      `api/project-wallet`,
      web3Wallet
    );
    if (status === 200) {
      return data;
    }
    throw new Error("Failed to create wallet");
  }
  /**
   * Retrieves a list of wallets associated with the current project.
   *
   * @returns {Promise<Web3ProjectWallet[]>} A promise that resolves to an array of wallets,
   * each containing the wallet's `id`, `address`, `networkId`, and `tag`.
   *
   * @throws {Error} Throws an error if the request to fetch wallets fails.
   */
  async getWallets() {
    const { data, status } = await this.sdk.axiosInstance.get(
      `api/project-wallet/${this.sdk.projectId}`
    );
    if (status === 200) {
      return data;
    }
    throw new Error("Failed to get wallets");
  }
  /**
   * Retrieves a wallet by its ID and decrypts the key with the project's private key.
   *
   * @param walletId - The unique identifier of the wallet to retrieve.
   * @param networkId - The network ID associated with the wallet (0 or 1).
   * @param decryptKey - A boolean indicating whether to decrypt the wallet key (default: false).
   *
   * @returns A promise that resolves to an initialized `MeshWallet` instance.
   * @throws Will throw an error if the private key is not found or if the wallet retrieval fails.
   */
  async getWallet(walletId, networkId, decryptKey = false) {
    if (this.sdk.privateKey === void 0) {
      throw new Error("Private key not found");
    }
    const { data, status } = await this.sdk.axiosInstance.get(
      `api/project-wallet/${this.sdk.projectId}/${walletId}`
    );
    if (status === 200) {
      const web3Wallet = data;
      const mnemonic = await decryptWithPrivateKey({
        privateKey: this.sdk.privateKey,
        encryptedDataJSON: web3Wallet.key
      });
      if (decryptKey) {
        web3Wallet.key = mnemonic;
      }
      const wallet = new import_wallet3.MeshWallet({
        networkId,
        key: {
          type: "mnemonic",
          words: mnemonic.split(" ")
        },
        fetcher: this.sdk.providerFetcher,
        submitter: this.sdk.providerSubmitter
      });
      await wallet.init();
      return { info: web3Wallet, wallet };
    }
    throw new Error("Failed to get wallet");
  }
  async getWalletsByTag(tag) {
    if (this.sdk.privateKey === void 0) {
      throw new Error("Private key not found");
    }
    const { data, status } = await this.sdk.axiosInstance.get(
      `api/project-wallet/${this.sdk.projectId}/tag/${tag}`
    );
    if (status === 200) {
      const web3Wallets = data;
      return web3Wallets;
    }
    throw new Error("Failed to get wallet");
  }
};

// src/sdk/sponsorship/index.ts
var import_core = require("@meshsdk/core");
var CONFIG_DURATION_CONSUME_UTXOS = 1e3 * 60;
var Sponsorship = class {
  sdk;
  constructor({ sdk }) {
    {
      this.sdk = sdk;
    }
  }
  /**
   * Retrieves static information about the sponsorship, including the change address
   * and a predefined UTXO used for sponsorship.
   *
   * @returns An object containing the change address and the static UTXO.
   */
  getStaticInfo(amount = "5") {
    if (this.sdk.network === "mainnet") {
      throw new Error("Sponsorship is not available on mainnet yet.");
    }
    return {
      changeAddress: meshUniversalStaticUtxo.testnet["5"].output.address,
      utxo: meshUniversalStaticUtxo.testnet[amount],
      collateral: meshUniversalStaticUtxo.testnet["5"]
    };
  }
  /**
   * Sponsors a transaction by associating it with a specific sponsorship ID and optionally
   * modifying its fee-related parameters.
   *
   * @param params - The parameters for sponsoring the transaction.
   * @param params.sponsorshipId - The unique identifier for the sponsorship.
   * @param params.tx - The transaction in CBOR format to be sponsored.
   * @param params.feeChangeAddress - (Optional) Either `feeChangeAddress` or `feeOutputIndex`. The address to which any change from the fee will be sent, the fee balance will be the first output with this address.
   * @param params.feeOutputIndex - (Optional) Either `feeChangeAddress` or `feeOutputIndex`. The index of the output in the transaction where the fee is specified, the fee balanace will combine with the output with this index.
   * @returns A promise that resolves to the new transaction in CBOR format after sponsorship.
   */
  async sponsorTx({
    sponsorshipId,
    tx
  }) {
    const { data, status } = await this.sdk.axiosInstance.post(
      `api/sponsorship/${sponsorshipId}`,
      {
        sponsorshipId,
        txHex: tx,
        projectId: this.sdk.projectId,
        network: this.sdk.network
      }
    );
    if (status !== 200) {
      throw new Error(
        "Invalid sponsorship ID or failed to fetch sponsorship config"
      );
    }
    const sponsorshipConfig = data;
    console.log("sponsorshipConfig", sponsorshipConfig);
    const signedRebuiltTxHex = await this.sponsorTxAndSign({
      txHex: tx,
      config: sponsorshipConfig
    });
    return { success: true, data: signedRebuiltTxHex };
  }
  /**
   * functions to sponsor a transaction and sign it with the sponsor wallet.
   */
  /**
   * This function looks for UTXOs in the sponsor wallet that can be used to sponsor a transaction.
   * If there are not enough UTXOs, it prepares more UTXOs using the `prepareSponsorUtxosTx` method.
   * It then rebuilds the original transaction by adding the selected UTXO as an input (`rebuildTx`) and signs it with the sponsor wallet.
   */
  async sponsorTxAndSign({
    txHex,
    config
  }) {
    const sponsorWallet = await this.getSponsorWallet(config.projectWalletId);
    const sponsorshipWalletUtxos = await sponsorWallet.getUtxos();
    const sponsorshipWalletAddress = await sponsorWallet.getChangeAddress();
    if (sponsorshipWalletUtxos.length === 0) {
      throw new Error(
        "No UTXOs available in the sponsorship wallet. Please fund the wallet."
      );
    }
    const dbPendingUtxos = await this.dbGetIsPendingUtxo(
      config.projectWalletId
    );
    const pendingUtxoIds = dbPendingUtxos.map((utxo) => {
      return `${utxo.txHash}#${utxo.outputIndex}`;
    });
    const utxosAvailableAsInput = sponsorshipWalletUtxos.filter((utxo) => {
      return utxo.output.amount[0].unit === "lovelace" && utxo.output.amount[0].quantity === (config.utxoAmount * 1e6).toString() && !pendingUtxoIds.includes(
        `${utxo.input.txHash}#${utxo.input.outputIndex}`
      );
    });
    console.log("sponsorshipWalletUtxos", sponsorshipWalletUtxos);
    console.log("UTXOs available as input:", utxosAvailableAsInput);
    let prepareUtxo = false;
    let sponsorshipTxHash = void 0;
    let sponsorshipIndex = void 0;
    if (utxosAvailableAsInput.length <= config.numUtxosTriggerPrepare) {
      console.log("Preparing more UTXOs");
      prepareUtxo = true;
    }
    if (prepareUtxo) {
      try {
        sponsorshipTxHash = await this.prepareSponsorUtxosTx({
          config
        });
        sponsorshipIndex = 0;
        console.log("prepareSponsorUtxosTx txHash:", sponsorshipTxHash);
      } catch (error) {
        console.error("Failed to prepare sponsor UTXOs:", error);
        const { data: resRefreshTxHash, status: refreshStatus } = await this.sdk.axiosInstance.get(
          `api/sponsorship/${config.id}/refreshTxHash`
        );
        if (refreshStatus !== 200 || !resRefreshTxHash.refreshTxHash) {
          throw new Error("Failed to get refresh transaction hash");
        }
        sponsorshipTxHash = resRefreshTxHash.refreshTxHash;
        sponsorshipIndex = Math.floor(Math.random() * config.numUtxosPrepare);
      }
    }
    let selectedUtxo = void 0;
    if (sponsorshipTxHash !== void 0 && sponsorshipIndex !== void 0) {
      selectedUtxo = {
        input: {
          txHash: sponsorshipTxHash,
          outputIndex: sponsorshipIndex
        },
        output: {
          amount: [
            {
              unit: "lovelace",
              quantity: (config.utxoAmount * 1e6).toString()
            }
          ],
          address: sponsorshipWalletAddress
        }
      };
      await this.dbAppendUtxosUsed(config, sponsorshipTxHash, sponsorshipIndex);
    }
    while (selectedUtxo === void 0 && utxosAvailableAsInput.length > 0) {
      const selectedIndex = Math.floor(
        Math.random() * utxosAvailableAsInput.length
      );
      const _selectedUtxo = utxosAvailableAsInput[selectedIndex];
      utxosAvailableAsInput.splice(selectedIndex, 1);
      const isUtxoUsed = await this.dbGetIfUtxoUsed(
        config.projectWalletId,
        _selectedUtxo.input.txHash,
        _selectedUtxo.input.outputIndex
      );
      if (!isUtxoUsed) {
        selectedUtxo = _selectedUtxo;
        await this.dbAppendUtxosUsed(
          config,
          selectedUtxo.input.txHash,
          selectedUtxo.input.outputIndex
        );
      }
    }
    if (selectedUtxo) {
      let _rebuiltTxHex = void 0;
      try {
        const body = {
          txHex,
          address: sponsorshipWalletAddress,
          utxos: JSON.stringify(sponsorshipWalletUtxos),
          sponsorUtxo: JSON.stringify(selectedUtxo),
          network: this.sdk.network
        };
        console.log("Rebuilding transaction with selected UTXO:", body);
        const { data, status } = await this.sdk.axiosInstance.post(
          `api/sponsorship/tx-parser`,
          body
        );
        if (status !== 200) {
          throw new Error("Failed to parse Tx on server!");
        }
        const { rebuiltTxHex } = data;
        _rebuiltTxHex = rebuiltTxHex;
      } catch (error) {
        console.log("First attempt failed, trying with refreshTxHash", error);
        const { data: resRefreshTxHash, status: refreshStatus } = await this.sdk.axiosInstance.get(
          `api/sponsorship/${config.id}/refreshTxHash`
        );
        if (refreshStatus !== 200 || !resRefreshTxHash.refreshTxHash) {
          throw new Error("Failed to get refresh transaction hash");
        }
        const txHash = resRefreshTxHash.refreshTxHash;
        let hasFoundUsableUtxo = false;
        for (let attempt = 0; attempt < config.numUtxosPrepare && !hasFoundUsableUtxo; attempt++) {
          const selectedIndex = Math.floor(
            Math.random() * config.numUtxosPrepare
          );
          try {
            const isUtxoUsed = await this.dbGetIfUtxoUsed(
              config.projectWalletId,
              txHash,
              selectedIndex
            );
            if (!isUtxoUsed) {
              await this.dbAppendUtxosUsed(config, txHash, selectedIndex);
              const newSelectedUtxo = {
                input: {
                  txHash,
                  outputIndex: selectedIndex
                },
                output: {
                  amount: [
                    {
                      unit: "lovelace",
                      quantity: (config.utxoAmount * 1e6).toString()
                    }
                  ],
                  address: sponsorshipWalletAddress
                }
              };
              const body = {
                txHex,
                address: sponsorshipWalletAddress,
                utxos: JSON.stringify(sponsorshipWalletUtxos),
                sponsorUtxo: JSON.stringify(newSelectedUtxo),
                network: this.sdk.network
              };
              const { data, status } = await this.sdk.axiosInstance.post(
                `api/sponsorship/tx-parser`,
                body
              );
              if (status === 200) {
                _rebuiltTxHex = data.rebuiltTxHex;
                hasFoundUsableUtxo = true;
                break;
              }
            }
          } catch (innerError) {
            console.log(`Attempt ${attempt + 1} failed:`, innerError);
          }
        }
      }
      if (_rebuiltTxHex == void 0) {
        throw new Error("Failed to rebuild transaction with selected UTXO.");
      }
      const signedRebuiltTxHex = await sponsorWallet.signTx(
        _rebuiltTxHex,
        true
      );
      return signedRebuiltTxHex;
    }
    throw new Error("No available UTXOs to sponsor the transaction.");
  }
  async getSponsorWallet(projectWalletId) {
    const networkId = this.sdk.network === "mainnet" ? 1 : 0;
    const wallet = await this.sdk.wallet.getWallet(projectWalletId, networkId);
    return wallet.wallet;
  }
  /**
   * Prepares UTXOs for sponsorship by creating new UTXOs in the sponsor wallet.
   * It uses existing UTXOs that are not the exact sponsor amount and those that have been pending for too long.
   * It creates a transaction that consumes these UTXOs and produces new UTXOs of the specified amount.
   */
  async prepareSponsorUtxosTx({
    config
  }) {
    const wallet = await this.getSponsorWallet(config.projectWalletId);
    const utxos = await wallet.getUtxos();
    const changeAddress = await wallet.getChangeAddress();
    const utxosAsInput = utxos.filter((utxo) => {
      return utxo.output.amount[0].unit === "lovelace" && parseInt(utxo.output.amount[0].quantity) !== config.utxoAmount * 1e6;
    });
    console.log("UTXOs used as inputs to prepare UTXOs:", utxosAsInput);
    const dbPendingUtxos = await this.dbGetIsPendingUtxo(
      config.projectWalletId
    );
    const pendingUtxosThatAreOld = dbPendingUtxos.filter((utxo) => {
      return utxo.isPending && !utxo.isSpent && new Date(utxo.createdAt).getTime() + CONFIG_DURATION_CONSUME_UTXOS < Date.now();
    });
    const utxosIdsThatAreOld = pendingUtxosThatAreOld.map((utxo) => {
      return `${utxo.txHash}#${utxo.outputIndex}`;
    });
    const utxosNotSpentAfterDuration = utxos.filter((utxo) => {
      return utxo.output.amount[0].unit === "lovelace" && parseInt(utxo.output.amount[0].quantity) === config.utxoAmount * 1e6 && utxosIdsThatAreOld.includes(
        `${utxo.input.txHash}#${utxo.input.outputIndex}`
      );
    });
    console.log("UTXOs pending for too long:", utxosNotSpentAfterDuration);
    const txBuilder = new import_core.MeshTxBuilder({
      fetcher: this.sdk.providerFetcher
    });
    txBuilder.changeAddress(changeAddress);
    for (let i = 0; i < utxosAsInput.length; i++) {
      const utxo = utxosAsInput[i];
      txBuilder.txIn(
        utxo.input.txHash,
        utxo.input.outputIndex,
        utxo.output.amount,
        utxo.output.address
      );
    }
    for (let i = 0; i < utxosNotSpentAfterDuration.length; i++) {
      const utxo = utxosNotSpentAfterDuration[i];
      txBuilder.txIn(
        utxo.input.txHash,
        utxo.input.outputIndex,
        utxo.output.amount,
        utxo.output.address
      );
      await this.dbMarkUtxoAsConsumed(
        config,
        utxo.input.txHash,
        utxo.input.outputIndex
      );
    }
    let totalBalance = 0;
    for (const utxo of utxosAsInput) {
      const lovelaceAmount = utxo.output.amount.find(
        (amount) => amount.unit === "lovelace"
      );
      if (lovelaceAmount) {
        totalBalance += parseInt(lovelaceAmount.quantity);
      }
    }
    for (const utxo of utxosNotSpentAfterDuration) {
      const lovelaceAmount = utxo.output.amount.find(
        (amount) => amount.unit === "lovelace"
      );
      if (lovelaceAmount) {
        totalBalance += parseInt(lovelaceAmount.quantity);
      }
    }
    const utxoAmountLovelace = config.utxoAmount * 1e6;
    const maxUtxosWeCanCreate = Math.floor(totalBalance / utxoAmountLovelace);
    const numUtxosToCreate = Math.min(
      config.numUtxosPrepare,
      maxUtxosWeCanCreate
    );
    console.log(`Total balance: ${totalBalance} lovelace`);
    console.log(`UTXO amount: ${utxoAmountLovelace} lovelace`);
    console.log(`Max UTXOs we can create: ${maxUtxosWeCanCreate}`);
    console.log(`UTXOs to create: ${numUtxosToCreate}`);
    for (let i = 0; i < numUtxosToCreate; i++) {
      txBuilder.txOut(changeAddress, [
        {
          unit: "lovelace",
          quantity: (config.utxoAmount * 1e6).toString()
        }
      ]);
    }
    const unsignedTx = await txBuilder.complete();
    const signedTx = await wallet.signTx(unsignedTx);
    const txHash = await this.sdk.providerSubmitter.submitTx(signedTx);
    await this.sdk.axiosInstance.post(
      `api/sponsorship/${config.id}/refreshTxHash`,
      {
        txHash
      }
    );
    return txHash;
  }
  /**
   * DB functions
   */
  async dbGetIsPendingUtxo(projectWalletId) {
    const { data, status } = await this.sdk.axiosInstance.get(
      `api/sponsorship/output/${projectWalletId}/pending`
    );
    if (status === 200) {
      return data;
    }
    throw new Error("Failed to get pending UTXOs");
  }
  async dbGetIfUtxoUsed(projectWalletId, txHash, outputIndex) {
    const { data, status } = await this.sdk.axiosInstance.get(
      `api/sponsorship/output/${projectWalletId}/${txHash}/${outputIndex}`
    );
    if (status === 200) {
      const output = data;
      return output ? output.isSpent : false;
    }
    throw new Error("Failed to check if UTXO is used");
  }
  async dbUpdateUtxos(projectWalletId, txHash, outputIndex, isPending = true, isSpent = false) {
    const { data, status } = await this.sdk.axiosInstance.put(
      `api/sponsorship/output/${projectWalletId}/${txHash}/${outputIndex}`,
      {
        isPending,
        isSpent
      }
    );
    if (status === 200) {
      return data;
    }
    throw new Error("Failed to mark UTXO as used");
  }
  async dbAppendUtxosUsed(config, txHash, outputIndex) {
    return this.dbUpdateUtxos(
      config.projectWalletId,
      txHash,
      outputIndex,
      true,
      false
    );
  }
  async dbMarkUtxoAsConsumed(config, txHash, outputIndex) {
    return this.dbUpdateUtxos(
      config.projectWalletId,
      txHash,
      outputIndex,
      false,
      true
    );
  }
};

// src/sdk/index.ts
var meshUniversalStaticUtxo = {
  mainnet: {
    // todo replace with mainnet
    "5": {
      input: {
        outputIndex: 0,
        txHash: "5a1edf7da58eff2059030abd456947a96cb2d16b9d8c3822ffff58d167ed8bfc"
      },
      output: {
        address: "addr_test1qrsj3xj6q99m4g9tu9mm2lzzdafy04035eya7hjhpus55r204nlu6dmhgpruq7df228h9gpujt0mtnfcnkcaj3wj457q5zv6kz",
        amount: [
          {
            unit: "lovelace",
            quantity: "5000000"
          }
        ]
      }
    }
  },
  testnet: {
    "5": {
      input: {
        outputIndex: 0,
        txHash: "5a1edf7da58eff2059030abd456947a96cb2d16b9d8c3822ffff58d167ed8bfc"
      },
      output: {
        address: "addr_test1qrsj3xj6q99m4g9tu9mm2lzzdafy04035eya7hjhpus55r204nlu6dmhgpruq7df228h9gpujt0mtnfcnkcaj3wj457q5zv6kz",
        amount: [
          {
            unit: "lovelace",
            quantity: "5000000"
          }
        ]
      }
    },
    "99": {
      input: {
        outputIndex: 0,
        txHash: "8222b0327a95e8c357016a5df64d93d7cf8a585a07c55327ae618a7e00d58d9e"
      },
      output: {
        address: "addr_test1qrsj3xj6q99m4g9tu9mm2lzzdafy04035eya7hjhpus55r204nlu6dmhgpruq7df228h9gpujt0mtnfcnkcaj3wj457q5zv6kz",
        amount: [
          {
            unit: "lovelace",
            quantity: "99000000"
          }
        ]
      }
    }
  }
};
var Web3Sdk = class {
  axiosInstance;
  appUrl;
  projectId;
  apiKey;
  privateKey;
  providerFetcher;
  providerSubmitter;
  network;
  project;
  wallet;
  sponsorship;
  constructor({
    appUrl,
    projectId,
    apiKey,
    network,
    privateKey,
    fetcher,
    submitter
  }) {
    this.appUrl = appUrl ? appUrl : "https://utxos.dev/";
    this.projectId = projectId;
    this.apiKey = apiKey;
    this.network = network;
    this.privateKey = privateKey;
    this.providerFetcher = fetcher;
    this.providerSubmitter = submitter;
    this.axiosInstance = import_axios.default.create({
      baseURL: this.appUrl,
      headers: { "x-api-key": apiKey }
    });
    this.wallet = new WalletDeveloperControlled({
      sdk: this
    });
    this.sponsorship = new Sponsorship({
      sdk: this
    });
  }
  async getProject() {
    if (this.project) {
      return this.project;
    }
    const { data, status } = await this.axiosInstance.get(
      `api/project/${this.projectId}`
    );
    if (status === 200) {
      this.project = data;
      return this.project;
    }
    throw new Error("Failed to get project");
  }
};

// src/wallet-user-controlled/web3-wallet.ts
var import_wallet4 = require("@meshsdk/wallet");
var import_bitcoin3 = require("@meshsdk/bitcoin");
var Web3Wallet = class _Web3Wallet {
  projectId;
  appUrl;
  user;
  chain;
  cardano;
  bitcoin;
  constructor(options) {
    this.projectId = options.projectId;
    this.appUrl = options.appUrl;
    this.user = options.user;
    this.chain = options.chain;
  }
  /**
   * Initializes a new instance of the Web3Wallet class.
   *
   * @param options - The options to initialize the wallet.
   * @param options.networkId - The network ID (0 for testnet, 1 for mainnet).
   * @param options.fetcher - An optional fetcher for network requests.
   * @param options.submitter - An optional submitter for transaction submissions.
   * @param options.projectId - An optional project ID for analytics or tracking.
   * @param options.appUrl - An optional application URL for the wallet.
   * @param options.directTo - An optional parameter to specify the user-controlled wallet direct-to option.
   *
   * @returns A promise that resolves to an instance of Web3Wallet.
   */
  static async enable(options) {
    const res = await openWindow(
      {
        method: "enable",
        projectId: options.projectId,
        directTo: options.directTo,
        chain: options.chain
      },
      options.appUrl
    );
    if (res.success === false)
      throw new ApiError({
        code: -3,
        info: "Refused - The request was refused due to lack of access - e.g. wallet disconnects."
      });
    if (res.data.method !== "enable") {
      throw new ApiError({
        code: 2,
        info: "Received the wrong response from the iframe."
      });
    }
    let address;
    if (options.chain === "cardano" || options.chain === void 0) {
      address = getAddressFromHashes(
        res.data.cardanoPubKeyHash,
        res.data.cardanoStakeCredentialHash,
        options.networkId
      );
    } else if (options.chain === "bitcoin" && res.data.bitcoinPubKeyHash) {
      const { address: _bitcoinAddress } = (0, import_bitcoin3.resolveAddress)(
        res.data.bitcoinPubKeyHash,
        options.networkId === 1 ? "mainnet" : "testnet"
      );
      address = _bitcoinAddress;
    }
    const wallet = await _Web3Wallet.initWallet({
      networkId: options.networkId,
      address,
      fetcher: options.fetcher,
      submitter: options.submitter,
      projectId: options.projectId,
      appUrl: options.appUrl,
      user: res.data.user,
      chain: options.chain
    });
    return wallet;
  }
  getUser() {
    return this.user;
  }
  /**
   * Requests user to sign the provided transaction (tx). The wallet should ask the user for permission, and if given, try to sign the supplied body and return a signed transaction. partialSign should be true if the transaction provided requires multiple signatures.
   *
   * @param unsignedTx - a transaction in CBOR
   * @param partialSign - if the transaction is partially signed (default: false)
   * @returns a signed transaction in CBOR
   */
  async signTx(unsignedTx, partialSign = false) {
    const res = await openWindow(
      {
        method: "sign-tx",
        projectId: this.projectId,
        unsignedTx,
        partialSign: partialSign === true ? "true" : "false",
        chain: this.chain
      },
      this.appUrl
    );
    if (res.success === false)
      throw new ApiError({
        code: 2,
        info: "UserDeclined - User declined to sign the transaction."
      });
    if (res.data.method !== "sign-tx") {
      throw new ApiError({
        code: 2,
        info: "Received the wrong response from the iframe."
      });
    }
    return res.data.tx;
  }
  /**
   * This endpoint utilizes the [CIP-8 - Message Signing](https://cips.cardano.org/cips/cip8/) to sign arbitrary data, to verify the data was signed by the owner of the private key.
   *
   * @param payload - the payload to sign
   * @param address - the address to use for signing (optional)
   * @returns a signature
   */
  async getChangeAddress() {
    if (this.chain === "bitcoin" && this.bitcoin) {
      return this.bitcoin.getAddress().address;
    } else if (this.cardano) {
      return await this.cardano.getChangeAddress();
    }
    throw new ApiError({
      code: 5,
      info: "No wallet initialized"
    });
  }
  async getNetworkId() {
    if (this.chain === "bitcoin" && this.bitcoin) {
      return this.bitcoin.getNetworkId();
    } else if (this.cardano) {
      return this.cardano.getNetworkId();
    }
    throw new ApiError({
      code: 5,
      info: "No wallet initialized"
    });
  }
  async signData(payload, address) {
    if (address === void 0) {
      address = await this.getChangeAddress();
    }
    const networkId = await this.getNetworkId();
    const res = await openWindow(
      {
        method: "sign-data",
        projectId: this.projectId,
        payload,
        address,
        networkId: String(networkId),
        chain: this.chain
      },
      this.appUrl
    );
    if (res.success === false)
      throw new ApiError({
        code: 3,
        info: "UserDeclined - User declined to sign the data."
      });
    if (res.data.method !== "sign-data") {
      throw new ApiError({
        code: 2,
        info: "Received the wrong response from the iframe."
      });
    }
    return res.data.signature;
  }
  /**
   * Initializes a new instance of a Web3 wallet with the specified options.
   *
   * @param params - The parameters required to initialize the wallet.
   * @param params.networkId - The network ID to connect to. Must be either `0` (testnet) or `1` (mainnet).
   * @param params.address - The wallet address to associate with the wallet instance.
   * @param params.fetcher - (Optional) An implementation of the `IFetcher` interface for fetching data.
   * @param params.submitter - (Optional) An implementation of the `ISubmitter` interface for submitting transactions.
   * @param params.projectId - (Optional) The project ID for analytics or tracking purposes.
   * @param params.appUrl - (Optional) The application URL for associating the wallet with a specific app.
   *
   * @returns A promise that resolves to an initialized instance of `Web3Wallet`.
   */
  static async initWallet({
    networkId,
    address,
    fetcher,
    submitter,
    projectId,
    appUrl,
    user,
    chain
  }) {
    const _options = {
      networkId,
      key: {
        type: "address",
        address
      },
      fetcher,
      submitter,
      projectId,
      appUrl,
      user,
      chain
    };
    const wallet = new _Web3Wallet(_options);
    if (!chain || chain === "cardano") {
      const cardanoWallet = new import_wallet4.MeshWallet({
        networkId,
        key: {
          type: "address",
          address
        },
        fetcher,
        submitter
      });
      await cardanoWallet.init();
      cardanoWallet.signTx = async (unsignedTx, partialSign = false) => {
        return wallet.signTx(unsignedTx, partialSign);
      };
      cardanoWallet.signData = async (payload, address2) => {
        return wallet.signData(payload, address2);
      };
      wallet.cardano = cardanoWallet;
    } else if (chain === "bitcoin") {
      const bitcoinWallet = new import_bitcoin3.EmbeddedWallet({
        testnet: networkId === 0,
        key: {
          type: "address",
          address
        }
      });
      bitcoinWallet.signTx = async (payload) => {
        return wallet.signTx(JSON.stringify(payload));
      };
      bitcoinWallet.signData = async (payload, address2) => {
        return wallet.signData(payload);
      };
      wallet.bitcoin = bitcoinWallet;
    }
    return wallet;
  }
};
var ApiError = class extends Error {
  json;
  constructor(json) {
    super(json.info || "An error occurred");
    this.name = "ApiError";
    this.json = json;
  }
};

// src/non-custodial/index.ts
var AUTH_KEY = "mesh-web3-services-auth";
var LOCAL_SHARD_KEY = "mesh-web3-services-local-shard";
var NotAuthenticatedError = class extends Error {
  constructor(message = "User is not authenticated") {
    super(message);
    this.name = "NotAuthenticatedError";
  }
};
var WalletServerRetrievalError = class extends Error {
  constructor(message = "Unable to get custodial shards from the server.") {
    super(message);
    this.name = "WalletServerRetrievalError";
  }
};
var WalletServerCreationError = class extends Error {
  constructor(message = "Unable to create custodial shards on the server.") {
    super(message);
    this.name = "WalletServerCreationError";
  }
};
var SessionExpiredError = class extends Error {
  constructor(message = "User session has expired") {
    super(message);
    this.name = "SessionExpiredError";
  }
};
var AuthRouteError = class extends Error {
  constructor(message = "Unable to finish authentication process.") {
    super(message);
    this.name = "AuthRouteError";
  }
};
var StorageRetrievalError = class extends Error {
  constructor(message = "Unable to retrieve key from storage.") {
    super(message);
    this.name = "StorageRetrievalError";
  }
};
var StorageInsertError = class extends Error {
  constructor(message = "Unable to insert data in storage.") {
    super(message);
    this.name = "StorageInsertError";
  }
};
var Web3NonCustodialProvider = class {
  projectId;
  appOrigin;
  storageLocation;
  googleOauth2ClientId;
  twitterOauth2ClientId;
  discordOauth2ClientId;
  appleOauth2ClientId;
  constructor(params) {
    this.projectId = params.projectId;
    this.appOrigin = params.appOrigin ? params.appOrigin : "https://web3.meshjs.dev";
    this.storageLocation = params.storageLocation ? params.storageLocation : "local_storage";
    this.googleOauth2ClientId = params.googleOauth2ClientId;
    this.twitterOauth2ClientId = params.twitterOauth2ClientId;
    this.discordOauth2ClientId = params.discordOauth2ClientId;
    this.appleOauth2ClientId = params.appleOauth2ClientId;
  }
  async checkNonCustodialWalletsOnServer() {
    const { data: user, error: userError } = await this.getUser();
    if (userError) {
      return { error: userError, data: null };
    }
    const result = await fetch(this.appOrigin + "/api/wallet", {
      headers: { Authorization: "Bearer " + user.token }
    });
    const wallets = await result.json();
    return { data: wallets, error: null };
  }
  async getWallets() {
    const { data: user, error: userError } = await this.getUser();
    if (userError) {
      return { error: userError, data: null };
    }
    const { data: localShards, error: localShardError } = await this.getFromStorage(
      LOCAL_SHARD_KEY + user.id
    );
    if (localShardError) {
      return { error: localShardError, data: null };
    }
    const ids = localShards.map((item) => item.deviceId);
    const params = new URLSearchParams();
    ids.forEach((id) => params.append("ids", id));
    const res = await fetch(
      this.appOrigin + "/api/device?" + params.toString(),
      { headers: { Authorization: "Bearer " + user.token } }
    );
    if (res.ok === false) {
      return {
        data: null,
        error: new WalletServerRetrievalError(
          "Retrieving wallets from the server failed with status " + res.status
        )
      };
    }
    const walletDevices = await res.json();
    const custodialWallets = walletDevices.map((device) => {
      const localShard = localShards.find(
        (item) => item.deviceId === device.deviceId
      );
      const i = {
        deviceId: device.deviceId,
        walletId: device.walletId,
        authShard: device.authShard,
        userAgent: device.userAgent,
        localShard: localShard.keyShard
      };
      return i;
    });
    return {
      data: custodialWallets,
      error: null
    };
  }
  async createWallet(spendingPassword, recoveryQuestion, recoveryAnswer) {
    const userAgent = navigator.userAgent;
    const { data: user, error: userError } = await this.getUser();
    if (userError) {
      return { error: userError, data: null };
    }
    const {
      pubKeyHash,
      stakeCredentialHash,
      encryptedDeviceShard,
      encryptedRecoveryShard,
      authShard,
      bitcoinPubKeyHash
    } = await clientGenerateWallet(spendingPassword, recoveryAnswer);
    const body = {
      userAgent,
      projectId: this.projectId,
      recoveryShard: encryptedRecoveryShard,
      authShard,
      bitcoinPubKeyHash,
      cardanoPubKeyHash: pubKeyHash,
      cardanoStakeCredentialHash: stakeCredentialHash,
      recoveryShardQuestion: recoveryQuestion
    };
    const res = await fetch(this.appOrigin + "/api/wallet", {
      method: "POST",
      headers: { Authorization: "Bearer " + user.token },
      body: JSON.stringify(body)
    });
    if (res.ok === false) {
      return {
        error: new WalletServerCreationError(
          "Retrieving wallets from the server failed with status " + res.status
        ),
        data: null
      };
    }
    const result = await res.json();
    await this.pushDevice({
      deviceId: result.deviceId,
      encryptedDeviceShard,
      walletId: result.walletId
    });
    return {
      data: { deviceId: result.deviceId, walletId: result.walletId },
      error: null
    };
  }
  async getUser() {
    const { data } = await this.getFromStorage(AUTH_KEY);
    if (data === null) {
      return { data: null, error: new NotAuthenticatedError() };
    }
    const parts = data.jwt.split(".");
    const bodyUnparsed = parts[1];
    if (bodyUnparsed === void 0) {
      return { data: null, error: new NotAuthenticatedError() };
    }
    const body = JSON.parse(
      atob(bodyUnparsed.replace(/-/g, "+").replace(/_/g, "/"))
    );
    if (body.exp < Date.now()) {
      return { data: null, error: new SessionExpiredError() };
    }
    return {
      data: {
        id: body.sub,
        scopes: body.scopes,
        provider: body.provider,
        providerId: body.providerId,
        avatarUrl: body.avatarUrl,
        email: body.email,
        username: body.username,
        token: data.jwt
      },
      error: null
    };
  }
  async performRecovery(recoveryAnswer, walletId, spendingPassword) {
    const { data: user, error: userError } = await this.getUser();
    if (userError) {
      return { error: userError };
    }
    const res = await fetch(this.appOrigin + "/api/wallet/" + walletId, {
      headers: { Authorization: "Bearer " + user.token }
    });
    if (res.ok === false) {
      return {
        error: new WalletServerRetrievalError(
          "Retrieving wallet " + walletId + "from the server failed with status " + res.status
        )
      };
    }
    const wallet = await res.json();
    const { authShard, deviceShard } = await clientRecovery(
      wallet.authShard,
      wallet.recoveryShard,
      recoveryAnswer,
      spendingPassword
    );
    const userAgent = navigator.userAgent;
    const createDeviceBody = {
      walletId,
      authShard,
      userAgent
    };
    const createDeviceRes = await fetch(this.appOrigin + "/api/device", {
      method: "POST",
      headers: { Authorization: "Bearer " + user.token },
      body: JSON.stringify(createDeviceBody)
    });
    if (createDeviceRes.ok === false) {
      return {
        error: new WalletServerCreationError(
          "Retrieving wallets from the server failed with status " + createDeviceRes.status
        )
      };
    }
    const newDeviceWallet = await createDeviceRes.json();
    await this.pushDevice({
      deviceId: newDeviceWallet.deviceId,
      encryptedDeviceShard: deviceShard,
      walletId
    });
    return { error: null };
  }
  signInWithProvider(provider, redirectUrl, callback) {
    if (provider === "google") {
      const googleState = JSON.stringify({
        redirect: redirectUrl,
        provider: "google",
        projectId: this.projectId
      });
      const googleSearchParams = new URLSearchParams({
        client_id: this.googleOauth2ClientId,
        response_type: "code",
        redirect_uri: this.appOrigin + "/api/auth",
        scope: "https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile",
        state: btoa(googleState)
      });
      const googleAuthorizeUrl = "https://accounts.google.com/o/oauth2/v2/auth?" + googleSearchParams.toString();
      callback(googleAuthorizeUrl);
      return;
    } else if (provider === "discord") {
      const discordState = JSON.stringify({
        redirect: redirectUrl,
        provider: "discord",
        projectId: this.projectId
      });
      const discordSearchParams = new URLSearchParams({
        client_id: this.discordOauth2ClientId,
        response_type: "code",
        redirect_uri: this.appOrigin + "/api/auth",
        scope: "identify email",
        state: btoa(discordState)
      });
      const discordAuthorizeUrl = "https://discord.com/oauth2/authorize?" + discordSearchParams.toString();
      callback(discordAuthorizeUrl);
      return;
    } else if (provider === "twitter") {
      const twitterState = JSON.stringify({
        redirect: redirectUrl,
        provider: "twitter",
        projectId: this.projectId
      });
      const twitterSearchParams = new URLSearchParams({
        response_type: "code",
        client_id: this.twitterOauth2ClientId,
        redirect_uri: this.appOrigin + "/api/auth",
        scope: "users.read+tweet.read+offline.access",
        state: btoa(twitterState),
        code_challenge: "challenge",
        code_challenge_method: "plain"
      });
      const twitterAuthorizeUrl = "https://x.com/i/oauth2/authorize?" + twitterSearchParams.toString();
      callback(twitterAuthorizeUrl);
      return;
    } else if (provider === "apple") {
      const appleState = JSON.stringify({
        redirect: redirectUrl,
        provider: "apple",
        projectId: this.projectId
      });
      const appleSearchParams = new URLSearchParams({
        client_id: this.appleOauth2ClientId,
        response_type: "code",
        redirect_uri: this.appOrigin + "/api/auth",
        response_mode: "form_post",
        scope: "name email",
        state: btoa(appleState)
      });
      const appleAuthorizeUrl = "https://appleid.apple.com/auth/authorize?" + appleSearchParams.toString();
      callback(appleAuthorizeUrl);
      return;
    }
  }
  /** Always place under /auth/mesh */
  handleAuthenticationRoute() {
    console.log("Logging params:", window.location.search);
    const params = new URLSearchParams(window.location.search);
    const token = params.get("token");
    const redirect = params.get("redirect");
    console.log(
      "Logging from inside handleAuthenticationRoute:",
      token,
      redirect
    );
    if (token && redirect) {
      this.putInStorage(AUTH_KEY, { jwt: token });
      window.location.href = redirect;
      return;
    }
    return {
      error: new AuthRouteError(
        `Either token or redirect are undefined. ?token=${token}, ?redirect=${redirect}`
      )
    };
  }
  async putInStorage(key, data) {
    if (this.storageLocation === "chrome_local") {
      await chrome.storage.local.set({ [key]: data });
    } else if (this.storageLocation === "chrome_sync") {
      await chrome.storage.sync.set({ [key]: data });
    } else if (this.storageLocation === "local_storage") {
      localStorage.setItem(key, JSON.stringify(data));
    }
  }
  async pushDevice(deviceWallet) {
    const { data: user, error: userError } = await this.getUser();
    if (userError) {
      return { error: userError };
    }
    let { data, error } = await this.getFromStorage(
      LOCAL_SHARD_KEY + user.id
    );
    if (data === null) {
      console.log(
        "We are expecting the error here to be that no local shard wallet objects exists yet: " + error.message
      );
      data = [];
    }
    data.push({
      deviceId: deviceWallet.deviceId,
      keyShard: deviceWallet.encryptedDeviceShard,
      walletId: deviceWallet.walletId
    });
    await this.putInStorage(
      LOCAL_SHARD_KEY + user.id,
      data
    );
    return { error: null };
  }
  async getFromStorage(key) {
    if (this.storageLocation === "chrome_local") {
      const query = await chrome.storage.local.get([key]);
      const data = query[key];
      if (data) {
        return { data, error: null };
      } else {
        return {
          data: null,
          error: new StorageRetrievalError(
            `Unable to retrieve key ${key} from chrome.storage.local.`
          )
        };
      }
    } else if (this.storageLocation === "chrome_sync") {
      const query = await chrome.storage.sync.get([key]);
      const data = query[key];
      if (data) {
        return { data, error: null };
      } else {
        return {
          data: null,
          error: new StorageRetrievalError(
            `Unable to retrieve key ${key} from chrome.storage.sync.`
          )
        };
      }
    } else if (this.storageLocation === "local_storage") {
      const data = localStorage.getItem(key);
      if (data) {
        return {
          data: JSON.parse(data),
          error: null
        };
      } else {
        return {
          data: null,
          error: new StorageRetrievalError(
            `Unable to retrieve key ${key} from localStorage.`
          )
        };
      }
    }
    return {
      data: null,
      error: new StorageRetrievalError(
        "Class missing a valid storage location."
      )
    };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ApiError,
  AuthRouteError,
  NotAuthenticatedError,
  SessionExpiredError,
  StorageInsertError,
  StorageRetrievalError,
  WalletServerCreationError,
  WalletServerRetrievalError,
  Web3NonCustodialProvider,
  Web3Sdk,
  Web3Wallet,
  bytesToHex,
  bytesToString,
  clientDeriveWallet,
  clientGenerateWallet,
  clientRecovery,
  combineShardsBuildWallet,
  crypto,
  decryptWithCipher,
  decryptWithPrivateKey,
  encryptWithCipher,
  encryptWithPublicKey,
  generateHash,
  generateKeyPair,
  getAddressFromHashes,
  hashData,
  hexToBytes,
  meshUniversalStaticUtxo,
  openWindow,
  shamirCombine,
  shamirSplit,
  spiltKeyIntoShards,
  stringToBytes
});
