import * as _meshsdk_common from '@meshsdk/common';
import { DeserializedAddress, PubKeyAddress, ScriptAddress, UTxO, Network, SlotConfig, Action, Data, PlutusDataType, TxInput, IMeshTxSerializer, Protocol, MeshTxBuilderBody, BuilderData, IDeserializer, IResolver, Output, Asset, ITxParser, Certificate, CertificateType, PoolParams, PoolMetadata, Relay, TxMetadata, Metadata, Redeemer, MintItem, ScriptSource, SimpleScriptSourceInfo, TxIn, TxInParameter, ScriptTxInParameter, SimpleScriptTxInParameter, Vote, Withdrawal, LanguageVersion, PlutusScript, NativeScript, IEvaluator, IFetcher } from '@meshsdk/common';
import * as csl from '@sidan-lab/whisky-js-nodejs';
export { csl };

declare const serialzeAddress: (deserializedAddress: Partial<DeserializedAddress>, networkId?: number) => string;
declare const addrBech32ToPlutusDataHex: (bech32: string) => string;
declare const addrBech32ToPlutusDataObj: <T>(bech32: string) => T;
declare const serializeAddressObj: (plutusDataAddressObject: PubKeyAddress | ScriptAddress, networkId?: number) => string;
declare const serializePlutusAddressToBech32: (plutusHex: string, networkId?: number) => string;
declare const deserializeBech32Address: (bech32Addr: string) => DeserializedAddress;
declare const scriptHashToBech32: (scriptHash: string, stakeCredentialHash?: string, networkId?: number, isScriptStakeCredentialHash?: boolean) => string;
declare const v2ScriptToBech32: (scriptCbor: string, stakeCredential?: string, networkId?: number, isScriptStakeCredential?: boolean) => string;

declare const parseInlineDatum: <T extends {
    inline_datum?: string;
}, X>(utxo: T) => X;
declare const parseDatumCbor: <T = any>(datumCbor: string) => T;

declare const getV2ScriptHash: (script: string) => string;

declare const skeyToPubKeyHash: (skeyHex: string) => string;

declare const poolIdHexToBech32: (poolIdHash: string) => string;
declare const poolIdBech32ToHex: (poolIdBech32: string) => string;
declare const baseAddressToStakeAddress: (baseAddressBech32: string, network?: number) => string;
declare const rewardAddressToKeyHash: (rewardBech32: string) => string | undefined;
declare const scriptHashToRewardAddress: (scriptHashHex: string, network?: number) => string;
declare const keyHashToRewardAddress: (keyHashHex: string, network?: number) => string;

declare const calculateTxHash: (txHex: string) => string;
declare const signTransaction: (txHex: string, signingKeys: string[]) => string;
declare const evaluateTransaction: (txHex: string, resolvedUtxos: UTxO[], chainedTxs: string[], network: Network, slotConfig: Omit<Omit<SlotConfig, "startEpoch">, "epochLength">) => Omit<Action, "data">[];
declare const getTransactionInputs: (txHex: string) => {
    txHash: string;
    outputIndex: number;
}[];
declare const getTransactionOutputs: (txHex: string) => UTxO[];

/**
 * Apply parameters to a given script blueprint.
 *
 * @param rawScript - The raw script CborHex from blueprint.
 * @param params - The parameters to apply, in an array.
 * @param type - The type of the parameters, default to be Mesh's Data type. It could also be in JSON and raw CBOR.
 * @returns The double-cbor encoded script CborHex with the parameters applied.
 */
declare const applyParamsToScript: (rawScript: string, params: object[] | Data[], type?: PlutusDataType) => string;
/**
 * Apply Cbor encoding.
 *
 * @param rawScript - The raw script CborHex from blueprint.
 * @returns The double-cbor encoded script CborHex.
 */
declare const applyCborEncoding: (rawScript: string) => string;

declare const getDRepIds: (dRepId: string) => {
    cip105: string;
    cip129: string;
};

declare const getRequiredInputs: (transactionHex: string) => TxInput[];

declare class CSLSerializer implements IMeshTxSerializer {
    /**
     * Set to true to enable verbose logging for the txBodyJson prior going into build
     */
    protocolParams: Protocol;
    meshTxBuilderBody: MeshTxBuilderBody;
    parserTxBody: MeshTxBuilderBody;
    constructor(protocolParams?: Protocol);
    serializeTxBody(txBody: MeshTxBuilderBody, protocolParams?: Protocol): string;
    addSigningKeys(txHex: string, signingKeys: string[]): string;
    serializeData(data: BuilderData): string;
    serializeAddress(address: Partial<DeserializedAddress>, networkId?: number): string;
    serializePoolId(hash: string): string;
    serializeRewardAddress(stakeKeyHash: string, isScriptHash?: boolean, network_id?: 0 | 1): string;
    deserializer: IDeserializer;
    resolver: IResolver;
    serializeOutput(output: Output): string;
    serializeTxBodyWithMockSignatures(txBuilderBody: MeshTxBuilderBody, protocolParams: Protocol): string;
    serializeValue(value: Asset[]): string;
    parser: ITxParser;
    private mockPubkey;
    private mockSignature;
    private mockChainCode;
    private numberToIntegerHex;
}

declare const certificateToObj: (certificate: Certificate) => object;
declare const baseCertToObj: (baseCert: CertificateType) => object;
declare const poolParamsToObj: (poolParams: PoolParams) => object;
declare const poolMetadataToObj: (poolMetadata: PoolMetadata) => object;
declare const relayToObj: (relay: Relay) => object;

declare const txMetadataToObj: (metadata: TxMetadata) => Metadata[];

declare const builderDataToCbor: ({ type, content }: BuilderData) => string;
declare const redeemerToObj: (redeemer: Redeemer) => object;

declare const networkToObj: (network: Network | number[][]) => "testnet" | "preview" | "preprod" | "mainnet" | {
    custom: number[][];
};

declare const mintItemToObj: (mintItem: MintItem) => object;
declare const plutusMintItemToObj: (mintItem: Required<MintItem>) => object;
declare const nativeMintItemToObj: (mintItem: Omit<Required<MintItem>, "redeemer">) => object;
declare const mintParametersObj: (mintItem: MintItem) => object;

declare const outputToObj: (output: Output) => object;

declare const scriptSourceToObj: (scriptSource: ScriptSource) => object;
declare const simpleScriptSourceToObj: (scriptSource: SimpleScriptSourceInfo) => object;

declare const txInToObj: (txIn: TxIn) => object;
declare const collateralTxInToObj: (txIn: TxIn) => object;
declare const txInParameterToObj: (txInParameter: TxInParameter) => object;
declare const scriptTxInParameterToObj: (scriptTxInParameter: ScriptTxInParameter) => object;
declare const simpleScriptTxInParameterToObj: (simpleScriptTxInParameter: SimpleScriptTxInParameter) => object | undefined;

declare const voteToObj: (vote: Vote) => object;

declare const utxoToObj: ({ input: { outputIndex, txHash }, output: { address, amount, dataHash, plutusData, scriptRef, scriptHash }, }: UTxO) => object;

declare const withdrawalToObj: (withdrawal: Withdrawal) => object;

declare const meshTxBuilderBodyToObj: ({ inputs, outputs, collaterals, requiredSignatures, referenceInputs, mints, changeAddress, metadata, validityRange, certificates, signingKey, withdrawals, votes, fee, network, }: MeshTxBuilderBody) => {
    inputs: object[];
    outputs: object[];
    collaterals: object[];
    requiredSignatures: string[];
    referenceInputs: _meshsdk_common.RefTxIn[];
    mints: object[];
    changeAddress: string;
    metadata: _meshsdk_common.Metadata[];
    validityRange: object;
    certificates: object[];
    signingKey: string[];
    withdrawals: object[];
    votes: object[];
    fee: string;
    network: "testnet" | "preview" | "preprod" | "mainnet" | {
        custom: number[][];
    };
};

declare const certificateFromObj: (obj: any) => Certificate;
declare const baseCertFromObj: (obj: any) => CertificateType;
declare const poolParamsFromObj: (obj: any) => PoolParams;
declare const poolMetadataFromObj: (obj: any) => PoolMetadata;
declare const relayFromObj: (obj: any) => Relay;

/**
 * Convert CBOR hex string back to BuilderData
 * @param cborHex The CBOR hex string to convert
 * @returns BuilderData object
 */
declare const cborToBuilderData: (cborHex: string) => BuilderData;
/**
 * Convert an object representation back to a Redeemer
 * @param obj The object representation of a Redeemer
 * @returns The Redeemer instance
 */
declare const redeemerFromObj: (obj: any) => Redeemer;
/**
 * Convert an object representation back to Data
 * @param obj The object representation of Data
 * @returns The Data instance
 */
declare const dataFromObj: (obj: any) => any;

declare const metadataFromObj: (metadataArray: Metadata[]) => TxMetadata;

/**
 * Convert an object representation back to a MintItem
 * @param obj The object representation of a MintItem
 * @returns The MintItem instance
 */
declare const mintItemFromObj: (obj: any) => MintItem;
/**
 * Convert a Plutus mint item object representation back to a MintItem
 * @param obj The object representation of a Plutus mint item
 * @returns The MintItem instance with Plutus script
 */
declare const plutusMintItemFromObj: (obj: any) => MintItem;
/**
 * Convert a Native mint item object representation back to a MintItem
 * @param obj The object representation of a Native mint item
 * @returns The MintItem instance with Native script
 */
declare const nativeMintItemFromObj: (obj: any) => MintItem;
/**
 * Convert mint parameters object representation back to MintItem parameters
 * @param obj The object representation of mint parameters
 * @returns The mint parameters
 */
declare const mintParametersFromObj: (obj: any) => Omit<MintItem, "type" | "scriptSource" | "redeemer">;

declare const networkFromObj: (obj: any) => Network | number[][];

/**
 * Convert an object representation back to an Output
 * @param obj The object representation of an Output
 * @returns The Output instance
 */
declare const outputFromObj: (obj: any) => Output;

/**
 * Convert an object representation back to a ScriptSource
 * @param obj The object representation of a ScriptSource
 * @returns The ScriptSource instance
 */
declare const scriptSourceFromObj: (obj: any) => ScriptSource;
/**
 * Convert an object representation back to a SimpleScriptSourceInfo
 * @param obj The object representation of a SimpleScriptSourceInfo
 * @returns The SimpleScriptSourceInfo instance
 */
declare const simpleScriptSourceFromObj: (obj: any) => SimpleScriptSourceInfo;

declare const txInFromObj: (obj: any) => TxIn;
declare const txInParameterFromObj: (obj: any) => TxInParameter;
declare const scriptTxInParameterFromObj: (obj: any) => ScriptTxInParameter;
declare const simpleScriptTxInParameterFromObj: (obj: any) => SimpleScriptTxInParameter;
declare const collateralTxInFromObj: (obj: any) => TxIn;

/**
 * Convert an object representation back to a UTxO
 * @param obj The object representation of the UTxO
 * @returns The UTxO instance
 */
declare const utxoFromObj: (obj: any) => UTxO;

declare const voteFromObj: (obj: any) => Vote;

declare const withdrawalFromObj: (obj: any) => Withdrawal;

/**
 * Convert an object representation back to MeshTxBuilderBody
 * @param obj The object representation of the transaction body
 * @returns The MeshTxBuilderBody instance
 */
declare const txBuilderBodyFromObj: (objJson: any) => MeshTxBuilderBody;

declare const deserializeAddress: (address: string) => csl.Address;
declare const deserializeBip32PrivateKey: (bip32PrivateKey: string) => csl.Bip32PrivateKey;
declare const deserializeDataHash: (dataHash: string) => csl.DataHash;
declare const deserializeEd25519KeyHash: (ed25519KeyHash: string) => csl.Ed25519KeyHash;
declare const deserializeEd25519Signature: (ed25519Signature: string) => csl.Ed25519Signature;
declare const deserializeNativeScript: (nativeScript: string) => csl.NativeScript;
declare const deserializePublicKey: (publicKey: string) => csl.PublicKey;
declare const deserializePlutusData: (plutusData: string) => csl.PlutusData;
declare const deserializePlutusScript: (plutusScript: string, version: LanguageVersion) => csl.PlutusScript;
declare const deserializeScriptRef: (scriptRef: string) => csl.ScriptRef;
declare const deserializeScriptHash: (scriptHash: string) => csl.ScriptHash;
declare const deserializeTx: (tx: string) => csl.Transaction;
declare const deserializeTxBody: (txBody: string) => csl.TransactionBody;
declare const deserializeTxHash: (txHash: string) => csl.TransactionHash;
declare const deserializeTxUnspentOutput: (txUnspentOutput: string) => csl.TransactionUnspentOutput;
declare const deserializeTxWitnessSet: (txWitnessSet: string) => csl.TransactionWitnessSet;
declare const deserializeValue: (value: string) => csl.Value;

declare const toAddress: (bech32: string) => csl.Address;
declare const toBaseAddress: (bech32: string) => csl.BaseAddress | undefined;
declare const toEnterpriseAddress: (bech32: string) => csl.EnterpriseAddress | undefined;
declare const toRewardAddress: (bech32: string) => csl.RewardAddress | undefined;
declare const fromBytes: (bytes: Uint8Array) => string;
declare const toBytes: (hex: string) => Uint8Array;
declare const fromUTF8: (utf8: string) => string;
declare const toUTF8: (hex: string) => string;
declare const fromLovelace: (lovelace: number) => number;
declare const toLovelace: (ada: number) => number;
declare const toScriptRef: (script: PlutusScript | NativeScript) => csl.ScriptRef;
declare const toPlutusData: (data: Data) => csl.PlutusData;
declare const castRawDataToJsonString: (rawData: object | string) => string;
declare const castDataToPlutusData: ({ type, content, }: BuilderData) => csl.PlutusData;
declare const toNativeScript: (script: NativeScript) => csl.NativeScript;
declare const toCslValue: (assets: Asset[]) => csl.Value;

declare const LANGUAGE_VERSIONS: {
    V1: csl.Language;
    V2: csl.Language;
    V3: csl.Language;
};
declare const REDEEMER_TAGS: {
    CERT: csl.RedeemerTag;
    MINT: csl.RedeemerTag;
    REWARD: csl.RedeemerTag;
    SPEND: csl.RedeemerTag;
};
declare const POLICY_ID_LENGTH = 56;

declare const resolveStakeKeyHash: (bech32: string) => string;
declare const resolvePrivateKey: (words: string[]) => string;
declare const resolveNativeScriptAddress: (script: NativeScript, networkId?: number) => string;
declare const resolvePlutusScriptAddress: (script: PlutusScript, networkId?: number) => string;
declare const resolveNativeScriptHash: (script: NativeScript) => string;
declare const resolveScriptHashDRepId: (scriptHash: string) => string;
declare const resolveRewardAddress: (bech32: string) => string;
declare const resolveDataHash: (rawData: BuilderData["content"], type?: PlutusDataType) => string;
declare const resolveNativeScriptHex: (script: NativeScript) => string;
declare const serializePoolId: (hash: string) => string;
declare const resolveScriptRef: (script: PlutusScript | NativeScript) => string;
declare const resolveEd25519KeyHash: (bech32: string) => string;

/**
 * OfflineEvaluator implements the IEvaluator interface to provide offline evaluation of Plutus scripts.
 * This class evaluates Plutus scripts contained in Cardano transactions without requiring network connectivity,
 * determining their execution costs in terms of memory and CPU steps.
 *
 * Each script evaluation returns an Action object (excluding the redeemer data) that contains:
 * - tag: The type of script being executed (CERT | MINT | REWARD | SPEND | VOTE | PROPOSE)
 * - index: Execution index of the script within the transaction
 * - budget: Execution costs including:
 *   - mem: Memory units required
 *   - steps: CPU steps required
 *
 * Example usage:
 * ```typescript
 * import { OfflineEvaluator, OfflineFetcher } from '@meshsdk/core';
 *
 * // Create fetcher and evaluator instances
 * const fetcher = new OfflineFetcher();
 * const evaluator = new OfflineEvaluator(fetcher, 'preprod');
 *
 * // Add required UTXOs that the transaction references
 * fetcher.addUTxOs([
 *   {
 *     input: {
 *       txHash: "1234...",
 *       outputIndex: 0
 *     },
 *     output: {
 *       address: "addr1...",
 *       amount: [{ unit: "lovelace", quantity: "1000000" }],
 *       scriptHash: "abcd..." // If this is a script UTXO
 *     }
 *   }
 * ]);
 *
 * // Evaluate Plutus scripts in a transaction
 * try {
 *   const actions = await evaluator.evaluateTx(transactionCbor);
 *   // Example result for a minting script:
 *   // [{
 *   //   index: 0,
 *   //   tag: "MINT",
 *   //   budget: {
 *   //     mem: 508703,    // Memory units used
 *   //     steps: 164980381 // CPU steps used
 *   //   }
 *   // }]
 * } catch (error) {
 *   console.error('Plutus script evaluation failed:', error);
 * }
 * ```
 */
declare class OfflineEvaluator implements IEvaluator {
    private readonly fetcher;
    private readonly network;
    slotConfig: Omit<Omit<SlotConfig, "startEpoch">, "epochLength">;
    /**
     * Creates a new instance of OfflineEvaluator.
     * @param fetcher - An implementation of IFetcher to resolve transaction UTXOs
     * @param network - The network to evaluate scripts for
     * @param slotConfig - Slot configuration for the network (optional, defaults to network-specific values)
     */
    constructor(fetcher: IFetcher, network: Network, slotConfig?: Omit<Omit<SlotConfig, "startEpoch">, "epochLength">);
    /**
     * Evaluates Plutus scripts in a transaction by resolving its input UTXOs and calculating execution costs.
     *
     * The method performs these steps:
     * 1. Extracts input references from the transaction
     * 2. Resolves the corresponding UTXOs using the fetcher
     * 3. Verifies all required UTXOs are available
     * 4. Evaluates each Plutus script to determine its memory and CPU costs
     *
     * @param tx - Transaction in CBOR hex format
     * @returns Promise resolving to array of script evaluation results, each containing:
     *   - tag: Type of script (CERT | MINT | REWARD | SPEND | VOTE | PROPOSE)
     *   - index: Script execution index
     *   - budget: Memory units and CPU steps required
     * @throws Error if any required UTXOs cannot be resolved or if script evaluation fails
     */
    evaluateTx(tx: string, additionalUtxos: UTxO[], additionalTxs: string[]): Promise<Omit<Action, "data">[]>;
}

export { CSLSerializer, LANGUAGE_VERSIONS, OfflineEvaluator, POLICY_ID_LENGTH, REDEEMER_TAGS, addrBech32ToPlutusDataHex, addrBech32ToPlutusDataObj, applyCborEncoding, applyParamsToScript, baseAddressToStakeAddress, baseCertFromObj, baseCertToObj, builderDataToCbor, calculateTxHash, castDataToPlutusData, castRawDataToJsonString, cborToBuilderData, certificateFromObj, certificateToObj, collateralTxInFromObj, collateralTxInToObj, dataFromObj, deserializeAddress, deserializeBech32Address, deserializeBip32PrivateKey, deserializeDataHash, deserializeEd25519KeyHash, deserializeEd25519Signature, deserializeNativeScript, deserializePlutusData, deserializePlutusScript, deserializePublicKey, deserializeScriptHash, deserializeScriptRef, deserializeTx, deserializeTxBody, deserializeTxHash, deserializeTxUnspentOutput, deserializeTxWitnessSet, deserializeValue, evaluateTransaction, fromBytes, fromLovelace, fromUTF8, getDRepIds, getRequiredInputs, getTransactionInputs, getTransactionOutputs, getV2ScriptHash, keyHashToRewardAddress, meshTxBuilderBodyToObj, metadataFromObj, mintItemFromObj, mintItemToObj, mintParametersFromObj, mintParametersObj, nativeMintItemFromObj, nativeMintItemToObj, networkFromObj, networkToObj, outputFromObj, outputToObj, parseDatumCbor, parseInlineDatum, plutusMintItemFromObj, plutusMintItemToObj, poolIdBech32ToHex, poolIdHexToBech32, poolMetadataFromObj, poolMetadataToObj, poolParamsFromObj, poolParamsToObj, redeemerFromObj, redeemerToObj, relayFromObj, relayToObj, resolveDataHash, resolveEd25519KeyHash, resolveNativeScriptAddress, resolveNativeScriptHash, resolveNativeScriptHex, resolvePlutusScriptAddress, resolvePrivateKey, resolveRewardAddress, resolveScriptHashDRepId, resolveScriptRef, resolveStakeKeyHash, rewardAddressToKeyHash, scriptHashToBech32, scriptHashToRewardAddress, scriptSourceFromObj, scriptSourceToObj, scriptTxInParameterFromObj, scriptTxInParameterToObj, serializeAddressObj, serializePlutusAddressToBech32, serializePoolId, serialzeAddress, signTransaction, simpleScriptSourceFromObj, simpleScriptSourceToObj, simpleScriptTxInParameterFromObj, simpleScriptTxInParameterToObj, skeyToPubKeyHash, toAddress, toBaseAddress, toBytes, toCslValue, toEnterpriseAddress, toLovelace, toNativeScript, toPlutusData, toRewardAddress, toScriptRef, toUTF8, txBuilderBodyFromObj, txInFromObj, txInParameterFromObj, txInParameterToObj, txInToObj, txMetadataToObj, utxoFromObj, utxoToObj, v2ScriptToBech32, voteFromObj, voteToObj, withdrawalFromObj, withdrawalToObj };
